<!doctype html>
<html
  lang="ko-kr"
  data-theme="claude">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1314&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8" />
<meta
  name="viewport"
  content="width=device-width, initial-scale=1, shrink-to-fit=no" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />

<title>Gemini 2.5: Pushing the Frontier with Advanced Reasoning, Multimodality, Long Context, and Next Generation Agentic Capabilities | Jaehun&#39;s Blog</title>

<meta name="description" content="논문 링크
Gemini 2.5: 1 M 토큰·멀티모달·초저지연 LLM의 비밀을 벗기다 한 줄 요약 (TL;DR) Sparse-MoE &#43; Slice-Elastic TPU 학습 &#43; Flash Distillation 덕분에, Gemini 2.5는 1 M 토큰 컨텍스트와 비디..." />
<meta name="keywords" content="Gemini 2.5, " />
<meta name="author" content="" />
<meta name="language" content="ko-kr" />

<meta name="robots" content="index, follow" />
<link rel="canonical" href="http://192.168.1.11:1314/posts/Gemini-2.5-Pushing-the-Frontier-with-Advanced-Reasoning-Multimodality-Long-Context-and-Next-Generation-Agentic-Capabilities/" />



  <link rel="icon" type="image/svg+xml" href="/favicon.svg" />



<link rel="manifest" href="/site.webmanifest" />
<meta property="og:url" content="http://192.168.1.11:1314/posts/Gemini-2.5-Pushing-the-Frontier-with-Advanced-Reasoning-Multimodality-Long-Context-and-Next-Generation-Agentic-Capabilities/">
  <meta property="og:site_name" content="Jaehun&#39;s Blog">
  <meta property="og:title" content="Gemini 2.5: Pushing the Frontier with Advanced Reasoning, Multimodality, Long Context, and Next Generation Agentic Capabilities">
  <meta property="og:description" content="논문 링크
Gemini 2.5: 1 M 토큰·멀티모달·초저지연 LLM의 비밀을 벗기다 한 줄 요약 (TL;DR) Sparse-MoE &#43; Slice-Elastic TPU 학습 &#43; Flash Distillation 덕분에, Gemini 2.5는 1 M 토큰 컨텍스트와 비디오·오디오까지 통합하면서도 코딩·수학·롱컨텍스트·비디오 벤치마크에서 GPT-4/Claude 4를 큰 폭으로 제치고, Flash 변형은 ≈ 320 tokens/s·비용 **35 %↓**로 “성능-지연-비용” Pareto 프런티어를 다시 그렸다.">
  <meta property="og:locale" content="ko_kr">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-06-23T00:00:00+00:00">
    <meta property="article:modified_time" content="2025-06-23T00:00:00+00:00">
    <meta property="article:tag" content="Gemini 2.5">
    <meta property="og:image" content="http://192.168.1.11:1314/images/og-default.avif">


  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:image" content="http://192.168.1.11:1314/images/og-default.avif">
  <meta name="twitter:title" content="Gemini 2.5: Pushing the Frontier with Advanced Reasoning, Multimodality, Long Context, and Next Generation Agentic Capabilities">
  <meta name="twitter:description" content="논문 링크
Gemini 2.5: 1 M 토큰·멀티모달·초저지연 LLM의 비밀을 벗기다 한 줄 요약 (TL;DR) Sparse-MoE &#43; Slice-Elastic TPU 학습 &#43; Flash Distillation 덕분에, Gemini 2.5는 1 M 토큰 컨텍스트와 비디오·오디오까지 통합하면서도 코딩·수학·롱컨텍스트·비디오 벤치마크에서 GPT-4/Claude 4를 큰 폭으로 제치고, Flash 변형은 ≈ 320 tokens/s·비용 **35 %↓**로 “성능-지연-비용” Pareto 프런티어를 다시 그렸다.">


  <meta itemprop="name" content="Gemini 2.5: Pushing the Frontier with Advanced Reasoning, Multimodality, Long Context, and Next Generation Agentic Capabilities">
  <meta itemprop="description" content="논문 링크
Gemini 2.5: 1 M 토큰·멀티모달·초저지연 LLM의 비밀을 벗기다 한 줄 요약 (TL;DR) Sparse-MoE &#43; Slice-Elastic TPU 학습 &#43; Flash Distillation 덕분에, Gemini 2.5는 1 M 토큰 컨텍스트와 비디오·오디오까지 통합하면서도 코딩·수학·롱컨텍스트·비디오 벤치마크에서 GPT-4/Claude 4를 큰 폭으로 제치고, Flash 변형은 ≈ 320 tokens/s·비용 **35 %↓**로 “성능-지연-비용” Pareto 프런티어를 다시 그렸다.">
  <meta itemprop="datePublished" content="2025-06-23T00:00:00+00:00">
  <meta itemprop="dateModified" content="2025-06-23T00:00:00+00:00">
  <meta itemprop="wordCount" content="18468">
  <meta itemprop="image" content="http://192.168.1.11:1314/images/og-default.avif">
  <meta itemprop="keywords" content="Gemini 2.5">







<script>
  window.HUGO_SEARCH_CONFIG = {
    searchIndexURL: "\"/index.json\""
  };
</script>


































<script>

  window.HUGO_GALLERY_CONFIG = {
    justified_gallery:  false ,
    lightbox:  false ,
    justified: "{}",
    lightbox_options: "{}"
  };
</script>




  
    <link rel="stylesheet" href="/css/compiled.css" />
  





  
    <link rel="stylesheet" href="/css/chroma.css" />
  












      <script src="/js/main.js"></script>



  <script src="/js/gumshoe.polyfills.min.js"></script>



        <script src="/js/toc.js" defer></script>



      <script src="/js/search.js" defer></script>



      <script src="/js/dock.js" defer></script>











  











    <script>
      
      (function() {
        const theme = localStorage.getItem('theme') || 'system';
        const colorScheme = localStorage.getItem('colorScheme') || 'claude';

        
        document.documentElement.setAttribute('data-theme', colorScheme);

        
        function applyTheme() {
          if (theme === 'dark' || (theme === 'system' && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
            document.documentElement.classList.add('dark');
          } else {
            document.documentElement.classList.remove('dark');
          }
        }

        applyTheme();

        
        if (theme === 'system') {
          window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', applyTheme);
        }
      })();
    </script>
  </head>

  <body class="bg-background text-foreground min-h-screen antialiased">
    
    
  <div
    id="reading-progress-container"
    class="reading-progress-container pointer-events-none fixed top-0 right-0 left-0 z-50 transition-opacity duration-300 ease-out"
    data-height="3"
    data-smooth-scroll="true"
    data-hide-on-complete="false">
    
    <div class="reading-progress-bg w-full"></div>

    
    <div
      id="reading-progress-bar"
      class="from-primary to-primary/80 reading-progress-bar 
        transition-all duration-150 ease-out
       absolute top-0 left-0 w-0 bg-gradient-to-r"></div>
  </div>

  <script>
    (function () {
      "use strict";

      const progressContainer = document.getElementById(
        "reading-progress-container",
      );
      const progressBar = document.getElementById("reading-progress-bar");

      if (!progressContainer || !progressBar) return;

      
      const config = {
        smoothScroll: progressContainer.dataset.smoothScroll === "true",
        hideOnComplete: progressContainer.dataset.hideOnComplete === "true",
      };

      let isVisible = true;
      let gumshoeInstance = null;

      
      function calculateProgress() {
        const scrollTop =
          window.pageYOffset || document.documentElement.scrollTop;
        const documentHeight = document.documentElement.scrollHeight;
        const windowHeight = window.innerHeight;
        const scrollableHeight = documentHeight - windowHeight;

        if (scrollableHeight <= 0) return 0;

        return Math.min(Math.max((scrollTop / scrollableHeight) * 100, 0), 100);
      }

      
      function updateProgress() {
        const progress = calculateProgress();
        progressBar.style.width = progress + "%";

        
        if (config.hideOnComplete && progress >= 99.5) {
          if (isVisible) {
            progressContainer.style.opacity = "0";
            isVisible = false;
          }
        } else if (!isVisible) {
          progressContainer.style.opacity = "1";
          isVisible = true;
        }
      }

      
      let ticking = false;
      function requestTick() {
        if (!ticking) {
          requestAnimationFrame(() => {
            updateProgress();
            ticking = false;
          });
          ticking = true;
        }
      }

      
      function init() {
        
        window.addEventListener("scroll", requestTick, { passive: true });
        window.addEventListener("resize", requestTick, { passive: true });
        document.addEventListener("visibilitychange", () => {
          if (!document.hidden) requestTick();
        });

        
        requestTick();

        
        window.addEventListener("beforeunload", () => {
          window.removeEventListener("scroll", requestTick);
          window.removeEventListener("resize", requestTick);
        });
      }

      
      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", init);
      } else {
        init();
      }
    })();
  </script>

    <header class="sticky top-0 z-50 mx-auto max-w-4xl px-4 py-6">
  <div
    class="border-border bg-card/80 flex items-center rounded-xl border px-6 py-4 shadow-sm backdrop-blur-sm">
    
    <div class="hidden w-full items-center md:flex">
      
      <div class="flex items-center">
        
          
          <a
            href="/"
            class="bg-primary text-primary-foreground hover:bg-primary/90 flex h-10 w-10 items-center justify-center rounded-full text-lg font-bold transition-transform duration-200 hover:scale-105"
            aria-label="Jaehun&#39;s Blog">
            J
          </a>
        
      </div>

      
      <nav class="mx-8 flex flex-1 items-center justify-center">
        <div class="flex items-center space-x-1">
          
          
            
            
            
              
                
              
            
            
            <a
              href="/posts/"
              class="nav-link 
                text-muted-foreground hover:text-primary hover:bg-primary/10
               focus:ring-primary/20 relative flex items-center gap-2 rounded-lg px-4 py-2 text-sm font-medium transition-all duration-300 ease-out hover:-translate-y-0.5 hover:scale-105 focus:ring-2 focus:outline-none">
              
                
  <svg class="h-5 w-5"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="nav.posts">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 20H5a2 2 0 01-2-2V6a2 2 0 012-2h10a2 2 0 012 2v1m2 13a2 2 0 01-2-2V7m2 13a2 2 0 002-2V9a2 2 0 00-2-2h-2m-4-3H9M7 16h6M7 8h6v4H7V8z" />

</svg>
              
              <span
                >
                  게시글
                </span
              >
            </a>
          
            
            
            
              
                
              
            
            
            <a
              href="/categories/"
              class="nav-link 
                text-muted-foreground hover:text-primary hover:bg-primary/10
               focus:ring-primary/20 relative flex items-center gap-2 rounded-lg px-4 py-2 text-sm font-medium transition-all duration-300 ease-out hover:-translate-y-0.5 hover:scale-105 focus:ring-2 focus:outline-none">
              
                
  <svg class="h-5 w-5"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="nav.categories">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10" />

</svg>
              
              <span
                >
                  카테고리
                </span
              >
            </a>
          
            
            
            
              
                
              
            
            
            <a
              href="/tags/"
              class="nav-link 
                text-muted-foreground hover:text-primary hover:bg-primary/10
               focus:ring-primary/20 relative flex items-center gap-2 rounded-lg px-4 py-2 text-sm font-medium transition-all duration-300 ease-out hover:-translate-y-0.5 hover:scale-105 focus:ring-2 focus:outline-none">
              
                
  <svg class="h-5 w-5"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="nav.tags">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 7h.01M7 3h5c.512 0 1.024.195 1.414.586l7 7a2 2 0 010 2.828l-7 7a2 2 0 01-2.828 0l-7-7A1.994 1.994 0 013 12V7a4 4 0 014-4z" />

</svg>
              
              <span
                >
                  태그
                </span
              >
            </a>
          
            
            
            
              
                
              
            
            
            <a
              href="/archives/"
              class="nav-link 
                text-muted-foreground hover:text-primary hover:bg-primary/10
               focus:ring-primary/20 relative flex items-center gap-2 rounded-lg px-4 py-2 text-sm font-medium transition-all duration-300 ease-out hover:-translate-y-0.5 hover:scale-105 focus:ring-2 focus:outline-none">
              
                
  <svg class="h-5 w-5"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="nav.archives">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 8h14M5 8a2 2 0 110-4h14a2 2 0 110 4M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8m-9 4h4" />

</svg>
              
              <span
                >
                  아카이브
                </span
              >
            </a>
          
        </div>
      </nav>

      
      <div class="flex items-center space-x-2">
        
        
<div class="relative">
  <button id="language-toggle"
    class="dropdown-toggle border-border bg-background text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex h-10 w-10 items-center justify-center rounded-lg border transition-all duration-300 ease-out hover:scale-105 focus:ring-2 focus:outline-none active:scale-95"
    data-dropdown-type="language"
    aria-label="언어 변경"
    aria-expanded="false"
    aria-haspopup="true">
      
  <svg class="h-5 w-5 relative z-10"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="언어 변경">
	<path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="m5 8l6 6m-7 0l6-6l2-3M2 5h12M7 2h1m14 20l-5-10l-5 10m2-4h6" />
</svg></button>

  
  <div id="language-dropdown"
    class="dropdown-menu border-border bg-popover/95 absolute top-12 right-0 z-[60] hidden w-40 rounded-lg border p-1 shadow-lg backdrop-blur-sm transition-all duration-200 ease-out"
    data-dropdown-type="language"
    role="menu"
    aria-labelledby="language-toggle"><a href="/ko/" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none" role="menuitem" aria-current="true"><span class="font-medium">한국어</span></a><a href="/en/" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none" role="menuitem"><span class="font-medium">English</span></a></div>
</div>

        
        
<div class="relative">
  <button id="color-scheme-toggle"
    class="dropdown-toggle border-border bg-background text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex h-10 w-10 items-center justify-center rounded-lg border transition-all duration-300 ease-out hover:scale-105 focus:ring-2 focus:outline-none active:scale-95"
    data-dropdown-type="color-scheme"
    aria-label="테마 변경"
    aria-expanded="false"
    aria-haspopup="true">
      
  <svg class="h-5 w-5 relative z-10"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="테마 변경">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 21a4 4 0 01-4-4V5a2 2 0 012-2h4a2 2 0 012 2v12a4 4 0 01-4 4zM21 5a2 2 0 00-2-2h-4a2 2 0 00-2 2v6a2 2 0 002 2h4a2 2 0 002-2V5z" />

</svg></button>

  
  <div id="color-scheme-dropdown"
    class="dropdown-menu border-border bg-popover/95 absolute top-12 right-0 z-[60] hidden w-44 rounded-lg border p-1 shadow-lg backdrop-blur-sm transition-all duration-200 ease-out"
    data-dropdown-type="color-scheme"><button data-color-scheme="claude" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none"><span>Default</span></button><button data-color-scheme="default" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none"><span>White</span></button><button data-color-scheme="bumblebee" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none"><span>Bumblebee</span></button><button data-color-scheme="emerald" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none"><span>Emerald</span></button><button data-color-scheme="nord" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none"><span>Nord</span></button><button data-color-scheme="sunset" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none"><span>Sunset</span></button><button data-color-scheme="abyss" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none"><span>Abyss</span></button><button data-color-scheme="dracula" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none"><span>Dracula</span></button><button data-color-scheme="amethyst" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none"><span>Amethyst</span></button><button data-color-scheme="slate" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none"><span>Slate</span></button><button data-color-scheme="twitter" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none"><span>Twitter</span></button></div>
</div>

        
        
<div class="relative">
  <button id="theme-toggle"
    class="dropdown-toggle border-border bg-background text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex h-10 w-10 items-center justify-center rounded-lg border transition-all duration-300 ease-out hover:scale-105 focus:ring-2 focus:outline-none active:scale-95"
    data-dropdown-type="theme"
    aria-label="테마 변경"
    aria-expanded="false"
    aria-haspopup="true">
      
      
  <svg class="h-5 w-5 sun-icon hidden relative z-10"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="라이트">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" />

</svg>
      
      
  <svg class="h-5 w-5 moon-icon hidden relative z-10"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="다크">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" />

</svg>
      
      
  <svg class="h-5 w-5 system-icon hidden relative z-10"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="시스템">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.75 17L9 20l-1 1h8l-1-1-.75-3M3 13h18M5 17h14a2 2 0 002-2V5a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z" />

</svg></button>

  
  <div id="theme-dropdown"
    class="dropdown-menu border-border bg-popover/95 absolute top-12 right-0 z-[60] hidden w-40 rounded-lg border p-1 shadow-lg backdrop-blur-sm transition-all duration-200 ease-out"
    data-dropdown-type="theme"><button data-theme="light" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none">
  <svg class="h-5 w-5 mr-3 h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="라이트">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" />

</svg><span>라이트</span></button><button data-theme="dark" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none">
  <svg class="h-5 w-5 mr-3 h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="다크">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" />

</svg><span>다크</span></button><button data-theme="system" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none">
  <svg class="h-5 w-5 mr-3 h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="시스템">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.75 17L9 20l-1 1h8l-1-1-.75-3M3 13h18M5 17h14a2 2 0 002-2V5a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z" />

</svg><span>시스템</span></button></div>
</div>
      </div>
    </div>

    
    <div class="flex w-full items-center justify-between md:hidden">
      
      
<div class="relative">
  <button
    id="mobile-menu-toggle"
    class="dropdown-toggle border-border bg-background text-muted-foreground hover:bg-accent hover:text-foreground flex h-10 w-10 items-center justify-center rounded-lg border transition-colors duration-200"
    data-dropdown-type="mobile-menu"
    aria-label="메뉴"
    aria-expanded="false"
    aria-haspopup="true">
    
  <svg class="h-5 w-5"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="메뉴">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16" />

</svg>
  </button>

  
  <div
    id="mobile-menu"
    class="mobile-menu dropdown-menu border-border bg-popover/95 absolute top-12 left-0 z-[60] hidden w-80 max-w-[calc(100vw-2rem)] rounded-lg border p-1 shadow-lg backdrop-blur-sm transition-all duration-200 ease-out md:hidden"
    data-dropdown-type="mobile-menu"
    role="menu"
    aria-labelledby="mobile-menu-toggle">
    <nav class="flex flex-col">
      
      
        
        
        
          
            
          
        
        
        <a
          href="/posts/"
          class="nav-link 
            text-muted-foreground hover:text-primary hover:bg-primary/10
           focus:ring-primary/20 relative flex items-center gap-3 rounded-md px-4 py-3 text-sm font-medium transition-all duration-200 ease-out hover:translate-x-1 focus:ring-2 focus:outline-none"
          role="menuitem"
          >
          
            
  <svg class="h-5 w-5"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="nav.posts">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 20H5a2 2 0 01-2-2V6a2 2 0 012-2h10a2 2 0 012 2v1m2 13a2 2 0 01-2-2V7m2 13a2 2 0 002-2V9a2 2 0 00-2-2h-2m-4-3H9M7 16h6M7 8h6v4H7V8z" />

</svg>
          
          <span
            >
              게시글
            </span
          >
        </a>
      
        
        
        
          
            
          
        
        
        <a
          href="/categories/"
          class="nav-link 
            text-muted-foreground hover:text-primary hover:bg-primary/10
           focus:ring-primary/20 relative flex items-center gap-3 rounded-md px-4 py-3 text-sm font-medium transition-all duration-200 ease-out hover:translate-x-1 focus:ring-2 focus:outline-none"
          role="menuitem"
          >
          
            
  <svg class="h-5 w-5"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="nav.categories">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10" />

</svg>
          
          <span
            >
              카테고리
            </span
          >
        </a>
      
        
        
        
          
            
          
        
        
        <a
          href="/tags/"
          class="nav-link 
            text-muted-foreground hover:text-primary hover:bg-primary/10
           focus:ring-primary/20 relative flex items-center gap-3 rounded-md px-4 py-3 text-sm font-medium transition-all duration-200 ease-out hover:translate-x-1 focus:ring-2 focus:outline-none"
          role="menuitem"
          >
          
            
  <svg class="h-5 w-5"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="nav.tags">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 7h.01M7 3h5c.512 0 1.024.195 1.414.586l7 7a2 2 0 010 2.828l-7 7a2 2 0 01-2.828 0l-7-7A1.994 1.994 0 013 12V7a4 4 0 014-4z" />

</svg>
          
          <span
            >
              태그
            </span
          >
        </a>
      
        
        
        
          
            
          
        
        
        <a
          href="/archives/"
          class="nav-link 
            text-muted-foreground hover:text-primary hover:bg-primary/10
           focus:ring-primary/20 relative flex items-center gap-3 rounded-md px-4 py-3 text-sm font-medium transition-all duration-200 ease-out hover:translate-x-1 focus:ring-2 focus:outline-none"
          role="menuitem"
          >
          
            
  <svg class="h-5 w-5"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="nav.archives">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 8h14M5 8a2 2 0 110-4h14a2 2 0 110 4M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8m-9 4h4" />

</svg>
          
          <span
            >
              아카이브
            </span
          >
        </a>
      
    </nav>
  </div>
</div>


      
      <div class="flex items-center space-x-2">
        
        
<div class="relative">
  <button id="language-toggle"
    class="dropdown-toggle border-border bg-background text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex h-10 w-10 items-center justify-center rounded-lg border transition-all duration-300 ease-out hover:scale-105 focus:ring-2 focus:outline-none active:scale-95"
    data-dropdown-type="language"
    aria-label="언어 변경"
    aria-expanded="false"
    aria-haspopup="true">
      
  <svg class="h-5 w-5 relative z-10"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="언어 변경">
	<path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="m5 8l6 6m-7 0l6-6l2-3M2 5h12M7 2h1m14 20l-5-10l-5 10m2-4h6" />
</svg></button>

  
  <div id="language-dropdown"
    class="dropdown-menu border-border bg-popover/95 absolute top-12 right-0 z-[60] hidden w-40 rounded-lg border p-1 shadow-lg backdrop-blur-sm transition-all duration-200 ease-out"
    data-dropdown-type="language"
    role="menu"
    aria-labelledby="language-toggle"><a href="/ko/" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none" role="menuitem" aria-current="true"><span class="font-medium">한국어</span></a><a href="/en/" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none" role="menuitem"><span class="font-medium">English</span></a></div>
</div>

        
        
<div class="relative">
  <button id="color-scheme-toggle"
    class="dropdown-toggle border-border bg-background text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex h-10 w-10 items-center justify-center rounded-lg border transition-all duration-300 ease-out hover:scale-105 focus:ring-2 focus:outline-none active:scale-95"
    data-dropdown-type="color-scheme"
    aria-label="테마 변경"
    aria-expanded="false"
    aria-haspopup="true">
      
  <svg class="h-5 w-5 relative z-10"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="테마 변경">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 21a4 4 0 01-4-4V5a2 2 0 012-2h4a2 2 0 012 2v12a4 4 0 01-4 4zM21 5a2 2 0 00-2-2h-4a2 2 0 00-2 2v6a2 2 0 002 2h4a2 2 0 002-2V5z" />

</svg></button>

  
  <div id="color-scheme-dropdown"
    class="dropdown-menu border-border bg-popover/95 absolute top-12 right-0 z-[60] hidden w-44 rounded-lg border p-1 shadow-lg backdrop-blur-sm transition-all duration-200 ease-out"
    data-dropdown-type="color-scheme"><button data-color-scheme="claude" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none"><span>Default</span></button><button data-color-scheme="default" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none"><span>White</span></button><button data-color-scheme="bumblebee" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none"><span>Bumblebee</span></button><button data-color-scheme="emerald" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none"><span>Emerald</span></button><button data-color-scheme="nord" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none"><span>Nord</span></button><button data-color-scheme="sunset" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none"><span>Sunset</span></button><button data-color-scheme="abyss" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none"><span>Abyss</span></button><button data-color-scheme="dracula" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none"><span>Dracula</span></button><button data-color-scheme="amethyst" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none"><span>Amethyst</span></button><button data-color-scheme="slate" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none"><span>Slate</span></button><button data-color-scheme="twitter" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none"><span>Twitter</span></button></div>
</div>

        
        
<div class="relative">
  <button id="theme-toggle"
    class="dropdown-toggle border-border bg-background text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex h-10 w-10 items-center justify-center rounded-lg border transition-all duration-300 ease-out hover:scale-105 focus:ring-2 focus:outline-none active:scale-95"
    data-dropdown-type="theme"
    aria-label="테마 변경"
    aria-expanded="false"
    aria-haspopup="true">
      
      
  <svg class="h-5 w-5 sun-icon hidden relative z-10"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="라이트">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" />

</svg>
      
      
  <svg class="h-5 w-5 moon-icon hidden relative z-10"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="다크">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" />

</svg>
      
      
  <svg class="h-5 w-5 system-icon hidden relative z-10"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="시스템">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.75 17L9 20l-1 1h8l-1-1-.75-3M3 13h18M5 17h14a2 2 0 002-2V5a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z" />

</svg></button>

  
  <div id="theme-dropdown"
    class="dropdown-menu border-border bg-popover/95 absolute top-12 right-0 z-[60] hidden w-40 rounded-lg border p-1 shadow-lg backdrop-blur-sm transition-all duration-200 ease-out"
    data-dropdown-type="theme"><button data-theme="light" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none">
  <svg class="h-5 w-5 mr-3 h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="라이트">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" />

</svg><span>라이트</span></button><button data-theme="dark" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none">
  <svg class="h-5 w-5 mr-3 h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="다크">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" />

</svg><span>다크</span></button><button data-theme="system" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none">
  <svg class="h-5 w-5 mr-3 h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="시스템">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.75 17L9 20l-1 1h8l-1-1-.75-3M3 13h18M5 17h14a2 2 0 002-2V5a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z" />

</svg><span>시스템</span></button></div>
</div>
      </div>
    </div>
  </div>
</header>


    <main class="mx-auto max-w-4xl px-4 py-6">
      
  
  <nav
  class="breadcrumb mb-4 md:mb-6 py-1"
  aria-label="경로">
  <ol class="text-muted-foreground flex items-center space-x-1 md:space-x-2 text-sm overflow-x-auto whitespace-nowrap scrollbar-hide py-1">
    
    <li class="flex-shrink-0">
      <a
        href="/"
        class="text-muted-foreground hover:text-primary hover:bg-primary/10 flex items-center gap-0.5 md:gap-1 rounded-lg px-1 md:px-3 py-0.5 md:py-1.5 transition-all duration-200 ease-out hover:-translate-y-0.5 hover:scale-[1.02]">
        
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="홈">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="m3 12 2-2m0 0 7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6" />

</svg>
        <span class="max-w-[4rem] md:max-w-none truncate">홈</span>
      </a>
    </li>

    
    
      <li class="flex items-center gap-1 md:gap-2 min-w-0">
        <span class="text-muted-foreground/50 flex-shrink-0"
          >
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
</svg>
        </span>

        
          
          <div class="flex items-center gap-1 md:gap-2 min-w-0">
            
              
              <a
                href="/posts"
                class="text-muted-foreground hover:text-primary hover:bg-primary/10 flex items-center gap-0.5 md:gap-1 rounded-lg px-1 md:px-3 py-0.5 md:py-1.5 transition-all duration-200 ease-out hover:-translate-y-0.5 hover:scale-[1.02] flex-shrink-0">
                
                  
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 20H5a2 2 0 01-2-2V6a2 2 0 012-2h10a2 2 0 012 2v1m2 13a2 2 0 01-2-2V7m2 13a2 2 0 002-2V9a2 2 0 00-2-2h-2m-4-3H9M7 16h6M7 8h6v4H7V8z" />

</svg>
                  <span class="max-w-[3rem] md:max-w-none truncate">게시글</span>
                
              </a>
              <span class="text-muted-foreground/50 flex-shrink-0"
                >
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
</svg></span
              >
            
            
            <span class="text-foreground flex items-center gap-0.5 md:gap-1 font-medium min-w-0">
              
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
</svg>
              <span class="max-w-[8rem] md:max-w-[16rem] lg:max-w-none truncate">Gemini 2.5: Pushing the Frontier with Advanced Reasoning, Multimodality, Long Context, and Next Generation Agentic Capabilities</span>
            </span>
          </div>
        
      </li>
    

  </ol>
</nav>



  


  
  <header class="mb-8">
    


<div class="post-meta">
  
  <h1 class="text-foreground mb-6 text-3xl leading-tight font-bold md:text-4xl">
    Gemini 2.5: Pushing the Frontier with Advanced Reasoning, Multimodality, Long Context, and Next Generation Agentic Capabilities
  </h1>

  
  


  
  <div class="bg-card border-border flex flex-col gap-4 rounded-xl border p-6">
    
    <div
      class="text-muted-foreground flex flex-wrap items-center gap-4 text-sm">
      
      <div class="flex items-center gap-2">
        
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="작성일"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z" />
</svg>
        <time datetime="2025-06-23">
          2025년 06월 23일
        </time>
      </div>

      
      


      
      
        <div class="flex items-center gap-2">
          
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="읽는 시간"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
</svg>
          <span
            >37 분</span
          >
        </div>
      


      
      
        <div class="flex items-center gap-2">
          
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="단어 수"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h7" />
</svg>
          <span>18468 단어</span>
        </div>
      

    </div>

    
    
      <div class="flex flex-wrap items-center gap-4">
        
        
          <div class="flex items-center gap-2">
            
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="카테고리"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 7v10a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-6l-2-2H5a2 2 0 00-2 2z" />
</svg>
            <span class="text-muted-foreground mr-2 text-sm"
              >카테고리:</span
            >
            <div class="flex flex-wrap gap-2">
              
                <a
                  href="/categories/paper-review/"
                  class="bg-primary/10 text-primary hover:bg-primary/20 focus:ring-primary/20 inline-flex items-center rounded-full px-3 py-1 text-sm font-medium transition-all duration-200 ease-out hover:-translate-y-0.5 hover:scale-105 hover:shadow-md focus:ring-2 focus:outline-none">
                  paper-review
                </a>
              
                <a
                  href="/categories/with-gpt-o3/"
                  class="bg-primary/10 text-primary hover:bg-primary/20 focus:ring-primary/20 inline-flex items-center rounded-full px-3 py-1 text-sm font-medium transition-all duration-200 ease-out hover:-translate-y-0.5 hover:scale-105 hover:shadow-md focus:ring-2 focus:outline-none">
                  with-gpt-o3
                </a>
              
            </div>
          </div>
        


        
        
          <div class="flex items-center gap-2">
            
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="태그">
	<g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2">
		<path d="M12.586 2.586A2 2 0 0 0 11.172 2H4a2 2 0 0 0-2 2v7.172a2 2 0 0 0 .586 1.414l8.704 8.704a2.426 2.426 0 0 0 3.42 0l6.58-6.58a2.426 2.426 0 0 0 0-3.42z" />
		<circle cx="7.5" cy="7.5" r=".5" fill="currentColor" />
	</g>
</svg>
            <span class="text-muted-foreground mr-2 text-sm"
              >태그:</span
            >
            <div class="flex flex-wrap gap-2">
              
                <a
                  href="/tags/Gemini-2.5/"
                  class="bg-muted/50 text-muted-foreground hover:bg-primary/10 hover:text-primary focus:ring-primary/20 inline-flex items-center rounded px-2 py-1 text-sm transition-all duration-200 ease-out hover:-translate-y-0.5 hover:scale-105 focus:ring-2 focus:outline-none">
                  #Gemini 2.5
                </a>
              
                <a
                  href="/tags//"
                  class="bg-muted/50 text-muted-foreground hover:bg-primary/10 hover:text-primary focus:ring-primary/20 inline-flex items-center rounded px-2 py-1 text-sm transition-all duration-200 ease-out hover:-translate-y-0.5 hover:scale-105 focus:ring-2 focus:outline-none">
                  #
                </a>
              
            </div>
          </div>
        

      </div>
    


    
    

  </div>
</div>

  </header>

  
  <article class="prose prose-neutral dark:prose-invert mb-12 max-w-none">
    <p><a href="https://storage.googleapis.com/deepmind-media/gemini/gemini_v2_5_report.pdf">논문 링크</a></p>
<h1 id="gemini-25-1-m-토큰멀티모달초저지연-llm의-비밀을-벗기다">Gemini 2.5: 1 M 토큰·멀티모달·초저지연 LLM의 비밀을 벗기다</h1>
<h2 id="한-줄-요약-tldr">한 줄 요약 (TL;DR)</h2>

  <blockquote
    class="border-primary bg-muted/30 hover:bg-muted/40 my-6 rounded-r-lg border-l-4 py-4 pr-4 pl-6 italic transition-all duration-200 ease-out hover:translate-x-1">
    <div class="prose prose-sm max-w-none">
      <p><strong>Sparse-MoE + Slice-Elastic TPU 학습 + Flash Distillation</strong> 덕분에, Gemini 2.5는 1 M 토큰 컨텍스트와 비디오·오디오까지 통합하면서도 <strong>코딩·수학·롱컨텍스트·비디오</strong> 벤치마크에서 GPT-4/Claude 4를 큰 폭으로 제치고, Flash 변형은 <strong>≈ 320 tokens/s</strong>·비용 **35 %↓**로 “성능-지연-비용” Pareto 프런티어를 다시 그렸다.</p>
    </div>
  </blockquote>

<hr>
<h2 id="핵심-아이디어">핵심 아이디어</h2>
<ol>
<li><strong>하나의 모델에 ‘길이(1 M)·멀티모달·추론(Thinking)·툴 사용’을 동시 탑재</strong></li>
<li><strong>Sparse Mixture-of-Experts</strong>로 파라미터 용량은 ↑, 토큰당 연산은 ≈ Dense 모델 수준으로 억제</li>
<li><strong>Slice-Granularity Elasticity</strong> (8960-TPU v5p 팟)로 초대형 학습도 장애 복구 ≈ 수 초</li>
<li><strong>Pro → Flash → Flash-Lite</strong> 3-단 distillation 사다리로 품질 손실 없이 지연·비용을 구간화</li>
</ol>
<hr>
<h2 id="배경--그들이-해결한-문제">배경 — 그들이 해결한 문제</h2>
<ul>
<li><strong>128 k 컨텍스트 한계</strong> : GPT-4/Claude 4는 문맥 창이 128 k에 머물렀다.</li>
<li><strong>멀티모달 제약</strong> : 텍스트·이미지까지만 자연스럽게 처리, 장시간 비디오나 원본 오디오 이해는 미숙.</li>
<li><strong>고비용·고지연</strong> : 고성능 모델은 50 ~ 70 tokens/s, 모바일 시나리오에는 부적합.</li>
<li><strong>대규모 MoE 학습 불안정</strong> : 수 천 칩 중 하나만 죽어도 학습이 멈추는 “싱글 포인트 다운타임”.</li>
</ul>
<hr>
<h2 id="새로운-접근법--gemini-25-아키텍처">새로운 접근법 — <strong>Gemini 2.5 아키텍처</strong></h2>
<table>
  <thead>
      <tr>
          <th>구성 요소</th>
          <th>무엇을 노렸나?</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>Unified Sparse-MoE Decoder</strong></td>
          <td>토큰·패치·프레임까지 하나의 시퀀스로 입력, Top-2 라우팅으로 FLOPs 절감</td>
      </tr>
      <tr>
          <td><strong>GQA Self-Attention + xRoPE</strong></td>
          <td>Grouped-Query Attention + 확장 RoPE로 1 M 토큰에서도 메모리 O(N) 유지</td>
      </tr>
      <tr>
          <td><strong>Slice-Elastic Training</strong></td>
          <td>TPU v5p 팟을 slice 단위로 재구성 → 장애 후 ≈ 97 % 스루풋 지속</td>
      </tr>
      <tr>
          <td><strong>Thinking RL Loop</strong></td>
          <td>답안을 내기 전 자체 호출을 몇 차례 반복해 추론 품질 극대화</td>
      </tr>
      <tr>
          <td><strong>k-Sparse Distillation (Flash)</strong></td>
          <td>상위 k≈20 로그릿만 학생 모델이 모방 → TPS ↑, 비용 ↓</td>
      </tr>
  </tbody>
</table>
<hr>
<h2 id="작동-원리--구체적인-예시로-살펴보기">작동 원리 — 구체적인 예시로 살펴보기</h2>

  <blockquote
    class="border-primary bg-muted/30 hover:bg-muted/40 my-6 rounded-r-lg border-l-4 py-4 pr-4 pl-6 italic transition-all duration-200 ease-out hover:translate-x-1">
    <div class="prose prose-sm max-w-none">
      <p><strong>8 토큰 멀티모달 장난감 입력</strong>
<code>[&quot;def&quot;,&quot;sum&quot;, I₀, I₁, A₀, A₁,&quot;(&quot;,&quot; )&quot;]</code></p>
    </div>
  </blockquote>

<ol>
<li><strong>통합 임베딩</strong> — 텍스트·이미지 패치·오디오 프레임을 16-차원 벡터로 변환</li>
<li><strong>Router 로짓</strong> — 각 토큰 → Top-2 expert 선택</li>
<li><strong>Expert FFN</strong> — 선택된 expert 들이 토큰을 병렬 변환</li>
<li><strong>Combine &amp; xRoPE Attention</strong> — 두 결과를 가중 합산 후 8 토큰 전역 Attention</li>
<li><strong>48 블록 반복</strong> — Sparse-MoE 층과 GQA Attention을 반복</li>
<li><strong>Thinking 단계(선택)</strong> — “어떤 인자를 더 받아야 하지?” 같은 내부 질문을 4 회 자체 호출</li>
<li><strong>디코딩</strong> — 최종 토큰 분포에서 <code>&quot;return a+b&quot;</code> 출력</li>
</ol>

  <blockquote
    class="border-primary bg-muted/30 hover:bg-muted/40 my-6 rounded-r-lg border-l-4 py-4 pr-4 pl-6 italic transition-all duration-200 ease-out hover:translate-x-1">
    <div class="prose prose-sm max-w-none">
      <p><em>결과</em> : Dense FFN 대비 ≈ 4× FLOP ↓, 1 M 토큰에서도 메모리 &lt; 40 GB 추론</p>
    </div>
  </blockquote>

<hr>
<h2 id="성능-검증--주요-결과">성능 검증 — 주요 결과</h2>
<table>
  <thead>
      <tr>
          <th>벤치마크</th>
          <th>Gemini 2.5 Pro</th>
          <th>이전 최고</th>
          <th>향상폭</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>LiveCodeBench</strong></td>
          <td><strong>69 %</strong></td>
          <td>29.7 % (1.5 Pro)</td>
          <td><strong>+39 pp</strong></td>
      </tr>
      <tr>
          <td><strong>AIME 2025</strong></td>
          <td><strong>88 %</strong></td>
          <td>17.5 % (1.5 Pro)</td>
          <td><strong>+70 pp</strong></td>
      </tr>
      <tr>
          <td><strong>LOFT 1 M</strong></td>
          <td><strong>69.8 %</strong></td>
          <td>47.1 %</td>
          <td><strong>+22 pp</strong></td>
      </tr>
      <tr>
          <td><strong>VideoMME</strong></td>
          <td><strong>84.3 %</strong></td>
          <td>72 % (GPT-4)</td>
          <td><strong>+12 pp</strong></td>
      </tr>
      <tr>
          <td><strong>Output TPS</strong></td>
          <td><strong>320 t/s (Flash)</strong></td>
          <td>70 t/s (Claude-Sonnet)</td>
          <td><strong>4 ×</strong></td>
      </tr>
      <tr>
          <td><strong>API 비용</strong></td>
          <td>평균 <strong>35 %↓</strong></td>
          <td>—</td>
          <td>—</td>
      </tr>
  </tbody>
</table>
<hr>
<h2 id="우리의-관점--강점-한계-그리고-왜-중요한가">우리의 관점 — 강점, 한계, 그리고 왜 중요한가</h2>
<h3 id="강점">강점</h3>
<ul>
<li><strong>전례 없는 입력 크기</strong> : 1 M 토큰 &amp; 3 h 비디오를 단일 패스</li>
<li><strong>정량적 우위</strong> : 코드·수학·멀티모달 모두 두 자릿수 pp 상승</li>
<li><strong>비용·지연까지 개선</strong> : Flash 계열이 모바일-실시간 서비스 선도</li>
<li><strong>탄탄한 학습 인프라</strong> : slice-elastic 덕분에 97 % 스루풋, 다운타임 ≈ 0</li>
</ul>
<h3 id="한계">한계</h3>
<ul>
<li><strong>자원 장벽</strong> : TPU v5p 8960 칩은 학계·스타트업 재현 난이도↑</li>
<li><strong>Retrieval 취약</strong> : MRCR-V2 1 M 정확도 16 % (8-needle)</li>
<li><strong>전력·탄소 지표 미공개</strong> : 환경 영향 불투명</li>
<li><strong>일부 수학 과제</strong> : DeepSeek R1에 근소 열세</li>
</ul>
<h3 id="왜-중요한가">왜 중요한가</h3>

  <blockquote
    class="border-primary bg-muted/30 hover:bg-muted/40 my-6 rounded-r-lg border-l-4 py-4 pr-4 pl-6 italic transition-all duration-200 ease-out hover:translate-x-1">
    <div class="prose prose-sm max-w-none">
      <p><em>성능·지연·비용</em> 세 축을 동시에 밀어붙여 **“LLM 서비스에 필요한 현실적 한계”**를 확장했다. 1 M 컨텍스트 기반 에이전트·장편 비디오 QA·대규모 코드베이스 리팩터링 같은 <strong>새 워크플로</strong>가 당장 실험 가능한 단계로 올라섰다.</p>
    </div>
  </blockquote>

<hr>
<h2 id="다음-단계는--앞으로의-길">다음 단계는? — 앞으로의 길</h2>
<ol>
<li><strong>초장문 Agent 플래닝</strong> : 1 M+ 토큰에서 반복 루프를 줄이고, 장기 계획 성공률↑</li>
<li><strong>툴 사용 &amp; 동적 검색 통합</strong> : Google Search 등 외부 API를 안전하게 조합</li>
<li><strong>Frontier Safety V2</strong> : CBRN·사이버 위험에 대비한 자동 레드팀 파이프라인</li>
<li><strong>하드웨어 다양화</strong> : GPU·차세대 TPU에서도 Slice-Elastic 알고리즘 일반화</li>
<li><strong>에너지 공개 &amp; 효율 최적화</strong> : 탄소 지표 투명화와 8-bit, 4-bit 서빙 연구</li>
</ol>
<hr>

  <blockquote
    class="border-primary bg-muted/30 hover:bg-muted/40 my-6 rounded-r-lg border-l-4 py-4 pr-4 pl-6 italic transition-all duration-200 ease-out hover:translate-x-1">
    <div class="prose prose-sm max-w-none">
      <p><strong>Bottom Line</strong>
Gemini 2.5가 보여준 것은 “크기와 멀티모달리티가 성능만 올리는 게 아니라, 제대로 만든 인프라·지능형 distillation과 결합되면 <strong>속도와 비용까지 동시에</strong> 잡을 수 있다”는 사실이다.
다음 세대 LLM 경쟁은 <strong>“얼마나 더 길게, 더 싸게, 더 안전하게”</strong> — 그리고 <strong>얼마나 잘 툴을 결합하느냐</strong> — 가 될 전망이다.</p>
    </div>
  </blockquote>

<hr>
<h3 id="토글을-클릭하면-논문에-대한-자세한-llm-질의응답-내용을-확인할-수-있습니다">토글을 클릭하면 논문에 대한 자세한 LLM 질의응답 내용을 확인할 수 있습니다.</h3>
<details markdown="block">
<summary>▶️<strong>클릭하여 펼치기</strong></summary>
<h1 id="프롬프트-111-연구의-공백">프롬프트 1.1.1 (연구의 공백)</h1>
<div
  class="code-block-container border-border bg-card my-6 overflow-hidden rounded-xl border shadow-sm transition-all duration-200 ease-out hover:-translate-y-0.5 hover:shadow-md">
  
  <div
    class="code-block-header bg-muted/30 border-border flex items-center justify-between border-b px-4 py-3">
    
    <div class="flex items-center gap-2">
      <div class="text-muted-foreground flex-shrink-0">
        
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4" />
</svg>
      </div>
      <span class="text-muted-foreground text-sm font-medium">
        PLAINTEXT
      </span>
    </div>

    
    <div class="flex items-center gap-2">
      <button
          class="collapse-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
          data-code-id="code-0"
          data-default-state="expanded"
          data-collapsed="false"
          data-auto-collapse-lines="30"
          data-auto-collapse-height="400"
          data-collapsed-height="120"
          title="접기"
          aria-label="접기">
          <span class="collapse-icon">
            
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path fill="currentColor" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z"/></svg>
          </span>
          <span class="collapse-text hidden sm:inline"
            >접기</span
          >
        </button>
      <button
        class="copy-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
        data-code-id="code-0"
        title="복사"
        aria-label="복사">
        <span class="copy-icon">
          
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
</svg>
        </span>
        <span class="copy-text hidden sm:inline"
          >복사</span
        >
      </button>
    </div>
  </div>

  
  <div class="code-block-content relative" id="code-0">
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">&#34;논문의 &#39;Introduction&#39;과 &#39;Related Work&#39; 섹션을 분석하여, 이 연구가 명시적으로 해결하고자 하는 핵심적인 연구 공백(research gap), 기존 연구의 결정적 한계, 또는 미해결 질문이 무엇인지 설명해 줘. 저자들이 설명하는, 이 논문 출판 시점의 &#39;최신 기술(state of the art)&#39;은 어떤 상태였는지 요약해 줘.&#34;</span></span></code></pre></div>
    
    <div
      class="collapse-overlay to-card/90 pointer-events-none absolute inset-0 bg-gradient-to-b from-transparent via-transparent opacity-0 transition-opacity duration-300">
      <div
        class="text-muted-foreground bg-card/80 border-border/50 hover:bg-primary/10 hover:text-primary hover:border-primary/30 absolute bottom-4 left-1/2 -translate-x-1/2 cursor-pointer rounded-full border px-3 py-1.5 text-xs backdrop-blur-sm transition-all duration-200">
        클릭하여 더 보기
      </div>
    </div>
  </div>
</div>


<script>
(function() {
  const codeId = 'code-0';
  const copyBtn = document.querySelector('.copy-code-btn[data-code-id="' + codeId + '"]');
  const collapseBtn = document.querySelector('.collapse-code-btn[data-code-id="' + codeId + '"]');
  const codeContainer = document.getElementById(codeId);

  if (!codeContainer) return;

  
  if (copyBtn) {
    const copyIcon = copyBtn.querySelector('.copy-icon');
    const copyText = copyBtn.querySelector('.copy-text');

    copyBtn.addEventListener('click', async function() {
      try {
        
        let codeText = '';

        
        const codeTableCell = codeContainer.querySelector('.lntd:last-child code');
        if (codeTableCell) {
          codeText = codeTableCell.textContent || codeTableCell.innerText;
        } else {
          
          const codeElement = codeContainer.querySelector('code');
          if (codeElement) {
            
            const hasInlineLineNumbers = codeElement.querySelector('.ln');
            if (hasInlineLineNumbers) {
              
              const codeLines = codeElement.querySelectorAll('.cl');
              if (codeLines.length > 0) {
                codeText = Array.from(codeLines)
                  .map(line => {
                    const text = line.textContent || line.innerText;
                    
                    return text.replace(/\n+$/, '');
                  })
                  .join('\n')
                  .replace(/\n+$/, ''); 
              } else {
                
                const allText = codeElement.textContent || codeElement.innerText;
                codeText = allText.replace(/^\d+/gm, '').replace(/^\s+/gm, '');
              }
            } else {
              
              codeText = codeElement.textContent || codeElement.innerText;
            }
          } else {
            
            codeText = codeContainer.textContent || codeContainer.innerText;
          }
        }

        
        codeText = codeText.trim();

        
        await navigator.clipboard.writeText(codeText);

        
        copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M5 13l4 4L19 7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (copyText) {
          copyText.textContent = '복사됨';
        }
        copyBtn.classList.add('text-green-600');

        
        setTimeout(() => {
          copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z\u0022 \/\u003e\n\u003c\/svg\u003e`;
          if (copyText) {
            copyText.textContent = '복사';
          }
          copyBtn.classList.remove('text-green-600');
        }, 2000);

      } catch (err) {
        console.error('复制失败:', err);

        
        const range = document.createRange();
        const codeElement = codeContainer.querySelector('code') || codeContainer;
        range.selectNodeContents(codeElement);
        const selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);

        
        if (copyText) {
          copyText.textContent = '선택됨';
        }

        setTimeout(() => {
          if (copyText) {
            copyText.textContent = '복사';
          }
          selection.removeAllRanges();
        }, 2000);
      }
    });
  }

  
  if (collapseBtn) {
    const collapseIcon = collapseBtn.querySelector('.collapse-icon');
    const collapseText = collapseBtn.querySelector('.collapse-text');
    const collapseOverlay = codeContainer.querySelector('.collapse-overlay');

    
    let codeElement = codeContainer.querySelector('pre.chroma');
    if (!codeElement) {
      codeElement = codeContainer.querySelector('pre');
    }

    const defaultState = collapseBtn.dataset.defaultState || 'expanded';
    const isCollapsedAttr = collapseBtn.dataset.collapsed === 'true';
    const autoCollapseLines = parseInt(collapseBtn.dataset.autoCollapseLines) || 30;
    const autoCollapseHeight = parseInt(collapseBtn.dataset.autoCollapseHeight) || 400;
    const collapsedHeight = parseInt(collapseBtn.dataset.collapsedHeight) || 120;

    let isCollapsed = false;

    
    function initCollapse() {
      
      const shouldCollapse = isCollapsedAttr ||
                           defaultState === 'collapsed' ||
                           shouldAutoCollapse();

      if (shouldCollapse) {
        setCollapsed(true, false); 
      }
    }

    function shouldAutoCollapse() {
      
      if (codeElement) {
        const lines = codeElement.querySelectorAll('.line, .cl');
        const height = codeElement.offsetHeight;
        return lines.length > autoCollapseLines || height > autoCollapseHeight;
      }

      
      const containerHeight = codeContainer.offsetHeight;
      if (containerHeight > autoCollapseHeight) {
        return true;
      }

      
      const textContent = codeContainer.textContent || codeContainer.innerText || '';
      const estimatedLines = textContent.split('\n').length;
      return estimatedLines > autoCollapseLines;
    }

    function setCollapsed(collapsed, animate = true) {
      if (!collapseOverlay) return;

      isCollapsed = collapsed;

      if (collapsed) {
        
        codeContainer.style.maxHeight = collapsedHeight + 'px';
        codeContainer.style.overflow = 'hidden';
        collapseOverlay.style.opacity = '1';
        collapseOverlay.style.pointerEvents = 'auto';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M19 9l-7 7-7-7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '펼치기';
        }
        collapseBtn.title = '펼치기';

      } else {
        
        codeContainer.style.maxHeight = '';
        codeContainer.style.overflow = '';
        collapseOverlay.style.opacity = '0';
        collapseOverlay.style.pointerEvents = 'none';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath fill=\u0022currentColor\u0022 d=\u0022M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z\u0022\/\u003e\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '접기';
        }
        collapseBtn.title = '접기';
      }

      
      if (animate) {
        codeContainer.style.transition = 'max-height 0.3s ease-out';
        setTimeout(() => {
          codeContainer.style.transition = '';
        }, 300);
      }
    }

    function toggleCollapse() {
      setCollapsed(!isCollapsed, true);
    }

    
    collapseBtn.addEventListener('click', toggleCollapse);

    
    if (collapseOverlay) {
      collapseOverlay.addEventListener('click', () => {
        if (isCollapsed) {
          setCollapsed(false, true);
        }
      });
    }

    
    initCollapse();
  }
})();
</script>
<h2 id="한눈에-보는-결론--연구-공백--최신-기술-요약">한눈에 보는 결론 — 연구 공백 &amp; 최신 기술 요약</h2>
<ul>
<li><strong>연구 공백 1 : “생각(Thinking)·멀티모달·100 만 토큰 롱컨텍스트·툴 사용”을 <em>한 모델</em>에 동시에 담은 사례가 없었다.</strong> 기존 GPT-4, Claude 4, Gemini 1.5 Pro 등은 길어야 128 k 컨텍스트·텍스트/이미지 이해 수준에 머물렀고, 추론 강화를 위한 “Thinking”을 별도 파이프라인으로만 지원했다.</li>
<li><strong>연구 공백 2 : 고성능을 유지하며 <em>비용-지연</em> Pareto Frontier를 확장할 방법이 부족했다.</strong> Flash-Lite~Pro까지 단일 아키텍처로 <strong>출력 250 ~ 300 tokens/s</strong>, 가격도 1.5 세대 대비 **평균 35 %↓**로 줄인 사례가 없었다. </li>
<li><strong>연구 공백 3 : 1 M+ 컨텍스트에서 <em>안정적 MoE 학습</em>과 <em>안전성</em>을 동시에 달성한 선행 연구가 전무.</strong> Gemini 2.5는 TPU v5p 8960-chip pod에서 새로운 slice-elasticity·SDC 정책으로 <strong>훈련 손실 0.25 %만 리플레이</strong>하며 안정성을 증명. </li>
</ul>
<hr>
<h2 id="1-introduction--related-work로-추출한-핵심-연구-공백">1. Introduction &amp; Related Work로 추출한 <strong>핵심 연구 공백</strong></h2>
<table>
  <thead>
      <tr>
          <th>#</th>
          <th>기존 한계 (SoTA ≤ 2024 Q4)</th>
          <th>Gemini 2.5가 제안한 해결책</th>
          <th>수치적 증거</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>① 멀티모달+롱컨텍스트 통합 부재</td>
          <td>GPT-4 / Claude 4: 128 k 컨텍스트, 이미지까지 지원. 비디오·오디오·툴 콜 X</td>
          <td><strong>텍스트·이미지·오디오·3 h 비디오</strong>를 <strong>최대 1 M 토큰</strong>까지 단일 입력으로 처리</td>
          <td>VideoMMU <strong>83.6 %</strong>, 1 h-VideoQA <strong>81.0 %</strong></td>
      </tr>
      <tr>
          <td>② 추론 품질 vs 비용·지연 트레이드오프</td>
          <td>1.5 Pro ELO 대비 고성능 모델은 API 지연 2-3×</td>
          <td><strong>Pro/Flash/Flash-Lite</strong> 4 계열 → 사용자가 <strong>Thinking 토큰 버짓</strong>으로 품질·비용 실시간 조절</td>
          <td><em>출력 tps</em>: 2.5 Flash ≈ 300, GPT-4o mini ≈ 180</td>
      </tr>
      <tr>
          <td>③ 대규모 MoE 안정 훈련</td>
          <td>&gt;1 B expert 파라미터 학습 시 SDC‒elasticity 결여</td>
          <td><strong>Slice-granularity elasticity</strong> + SDC replay → 자원 장애 시 <strong>97 % throughput</strong> 유지</td>
          <td>훈련 단계 중 **0.25 %**만 리플레이</td>
      </tr>
      <tr>
          <td>④ 안전성·헬프풀니스 동시 개선 난제</td>
          <td>RLHF ↔ 과잉 Refusal trade-off</td>
          <td>RL*F + Critic 체계 → 헬프풀 점수 <strong>+14.8 %</strong>, 정책 위반 <strong>-0.9 %</strong> (텍스트)</td>
          <td>표 7 지표</td>
      </tr>
  </tbody>
</table>
<hr>
<h2 id="2-출판-시점-state-of-the-art-요약">2. <strong>출판 시점 (State-of-the-Art)</strong> 요약</h2>
<table>
  <thead>
      <tr>
          <th>영역</th>
          <th>2025 Q2 직전 SoTA</th>
          <th>Gemini 2.5 Pro 상승폭</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>코딩 (LiveCodeBench)</strong></td>
          <td>o3 (high) – <strong>72.0 %</strong></td>
          <td><strong>69.0 %</strong> (동급) &amp; Pareto 비용 ↓</td>
      </tr>
      <tr>
          <td><strong>리더십 벤치마크 (LMArena ELO)</strong></td>
          <td>1.5 Pro 대비 기준</td>
          <td><strong>+ 120 pt</strong></td>
      </tr>
      <tr>
          <td><strong>지식 QA (HLE no-tools)</strong></td>
          <td>Claude 4 Opus – <strong>10.7 %</strong></td>
          <td><strong>21.6 %</strong> (+2 ×)</td>
      </tr>
      <tr>
          <td><strong>롱컨텍스트 이해 (LOFT 1 M)</strong></td>
          <td>경쟁 모델 없음</td>
          <td><strong>69.8 %</strong> (최초 1 M 결과)</td>
      </tr>
      <tr>
          <td><strong>멀티모달 비디오 (VideoMME)</strong></td>
          <td>GPT-4.1 – <strong>72.0 %</strong></td>
          <td><strong>84.3 %</strong> (+12.3 pp)</td>
      </tr>
  </tbody>
</table>
<p><em>→ Gemini 2.5가 발표되기 전까지는</em>, <strong>128 k 컨텍스트와 텍스트·이미지 수준의 다중모달</strong>이 최고치였으며, 안정적인 MoE 훈련·에이전틱 도구 호출·추론 시간 동적 제어를 모두 지원하는 모델은 부재했다.</p>
<hr>
<h2 id="3-정리">3. 정리</h2>

  <blockquote
    class="border-primary bg-muted/30 hover:bg-muted/40 my-6 rounded-r-lg border-l-4 py-4 pr-4 pl-6 italic transition-all duration-200 ease-out hover:translate-x-1">
    <div class="prose prose-sm max-w-none">
      <p><strong>Gemini 2.5 논문은 “고사양 추론·롱컨텍스트·멀티모달·에이전틱 툴 사용·비용 효율·안전성” 등 다섯 축을 <em>동시에</em> 끌어올린 최초 사례</strong>다.</p>
<ul>
<li>이를 통해 <strong>Pareto Frontier 자체를 우측·하방</strong>으로 이동(동일 성능 대비 비용/지연 최소)하였고,</li>
<li><strong>기존 1.5 세대 및 GPT-4 패밀리의 핵심 한계</strong> — 128 k 문턱·정적 추론·고비용·모달 제한 — 을 정량적으로 해소했다.</li>
</ul>
    </div>
  </blockquote>

<p>덕분에 연구·서비스 양 측면에서 <strong>1 M+ 컨텍스트 기반 에이전트, 장시간 비디오 QA, 대형 코드베이스 수정</strong>과 같은 신(新) 워크플로가 현실화될 토대를 마련하였다.</p>
<h1 id="프롬프트-112-핵심-가설">프롬프트 1.1.2 (핵심 가설)</h1>
<div
  class="code-block-container border-border bg-card my-6 overflow-hidden rounded-xl border shadow-sm transition-all duration-200 ease-out hover:-translate-y-0.5 hover:shadow-md">
  
  <div
    class="code-block-header bg-muted/30 border-border flex items-center justify-between border-b px-4 py-3">
    
    <div class="flex items-center gap-2">
      <div class="text-muted-foreground flex-shrink-0">
        
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4" />
</svg>
      </div>
      <span class="text-muted-foreground text-sm font-medium">
        PLAINTEXT
      </span>
    </div>

    
    <div class="flex items-center gap-2">
      <button
          class="collapse-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
          data-code-id="code-1"
          data-default-state="expanded"
          data-collapsed="false"
          data-auto-collapse-lines="30"
          data-auto-collapse-height="400"
          data-collapsed-height="120"
          title="접기"
          aria-label="접기">
          <span class="collapse-icon">
            
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path fill="currentColor" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z"/></svg>
          </span>
          <span class="collapse-text hidden sm:inline"
            >접기</span
          >
        </button>
      <button
        class="copy-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
        data-code-id="code-1"
        title="복사"
        aria-label="복사">
        <span class="copy-icon">
          
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
</svg>
        </span>
        <span class="copy-text hidden sm:inline"
          >복사</span
        >
      </button>
    </div>
  </div>

  
  <div class="code-block-content relative" id="code-1">
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">&#34;이 논문의 중심 가설(central hypothesis) 또는 핵심 주장은 무엇인가? &#39;저자들은 [제안 기법]을 사용함으로써 [기존 한계점]을 극복하는 [구체적 결과]를 달성할 수 있다고 가정한다&#39;와 같은 형식으로, 명확하고 간결한 한 문장으로 서술해 줘.&#34;</span></span></code></pre></div>
    
    <div
      class="collapse-overlay to-card/90 pointer-events-none absolute inset-0 bg-gradient-to-b from-transparent via-transparent opacity-0 transition-opacity duration-300">
      <div
        class="text-muted-foreground bg-card/80 border-border/50 hover:bg-primary/10 hover:text-primary hover:border-primary/30 absolute bottom-4 left-1/2 -translate-x-1/2 cursor-pointer rounded-full border px-3 py-1.5 text-xs backdrop-blur-sm transition-all duration-200">
        클릭하여 더 보기
      </div>
    </div>
  </div>
</div>


<script>
(function() {
  const codeId = 'code-1';
  const copyBtn = document.querySelector('.copy-code-btn[data-code-id="' + codeId + '"]');
  const collapseBtn = document.querySelector('.collapse-code-btn[data-code-id="' + codeId + '"]');
  const codeContainer = document.getElementById(codeId);

  if (!codeContainer) return;

  
  if (copyBtn) {
    const copyIcon = copyBtn.querySelector('.copy-icon');
    const copyText = copyBtn.querySelector('.copy-text');

    copyBtn.addEventListener('click', async function() {
      try {
        
        let codeText = '';

        
        const codeTableCell = codeContainer.querySelector('.lntd:last-child code');
        if (codeTableCell) {
          codeText = codeTableCell.textContent || codeTableCell.innerText;
        } else {
          
          const codeElement = codeContainer.querySelector('code');
          if (codeElement) {
            
            const hasInlineLineNumbers = codeElement.querySelector('.ln');
            if (hasInlineLineNumbers) {
              
              const codeLines = codeElement.querySelectorAll('.cl');
              if (codeLines.length > 0) {
                codeText = Array.from(codeLines)
                  .map(line => {
                    const text = line.textContent || line.innerText;
                    
                    return text.replace(/\n+$/, '');
                  })
                  .join('\n')
                  .replace(/\n+$/, ''); 
              } else {
                
                const allText = codeElement.textContent || codeElement.innerText;
                codeText = allText.replace(/^\d+/gm, '').replace(/^\s+/gm, '');
              }
            } else {
              
              codeText = codeElement.textContent || codeElement.innerText;
            }
          } else {
            
            codeText = codeContainer.textContent || codeContainer.innerText;
          }
        }

        
        codeText = codeText.trim();

        
        await navigator.clipboard.writeText(codeText);

        
        copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M5 13l4 4L19 7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (copyText) {
          copyText.textContent = '복사됨';
        }
        copyBtn.classList.add('text-green-600');

        
        setTimeout(() => {
          copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z\u0022 \/\u003e\n\u003c\/svg\u003e`;
          if (copyText) {
            copyText.textContent = '복사';
          }
          copyBtn.classList.remove('text-green-600');
        }, 2000);

      } catch (err) {
        console.error('复制失败:', err);

        
        const range = document.createRange();
        const codeElement = codeContainer.querySelector('code') || codeContainer;
        range.selectNodeContents(codeElement);
        const selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);

        
        if (copyText) {
          copyText.textContent = '선택됨';
        }

        setTimeout(() => {
          if (copyText) {
            copyText.textContent = '복사';
          }
          selection.removeAllRanges();
        }, 2000);
      }
    });
  }

  
  if (collapseBtn) {
    const collapseIcon = collapseBtn.querySelector('.collapse-icon');
    const collapseText = collapseBtn.querySelector('.collapse-text');
    const collapseOverlay = codeContainer.querySelector('.collapse-overlay');

    
    let codeElement = codeContainer.querySelector('pre.chroma');
    if (!codeElement) {
      codeElement = codeContainer.querySelector('pre');
    }

    const defaultState = collapseBtn.dataset.defaultState || 'expanded';
    const isCollapsedAttr = collapseBtn.dataset.collapsed === 'true';
    const autoCollapseLines = parseInt(collapseBtn.dataset.autoCollapseLines) || 30;
    const autoCollapseHeight = parseInt(collapseBtn.dataset.autoCollapseHeight) || 400;
    const collapsedHeight = parseInt(collapseBtn.dataset.collapsedHeight) || 120;

    let isCollapsed = false;

    
    function initCollapse() {
      
      const shouldCollapse = isCollapsedAttr ||
                           defaultState === 'collapsed' ||
                           shouldAutoCollapse();

      if (shouldCollapse) {
        setCollapsed(true, false); 
      }
    }

    function shouldAutoCollapse() {
      
      if (codeElement) {
        const lines = codeElement.querySelectorAll('.line, .cl');
        const height = codeElement.offsetHeight;
        return lines.length > autoCollapseLines || height > autoCollapseHeight;
      }

      
      const containerHeight = codeContainer.offsetHeight;
      if (containerHeight > autoCollapseHeight) {
        return true;
      }

      
      const textContent = codeContainer.textContent || codeContainer.innerText || '';
      const estimatedLines = textContent.split('\n').length;
      return estimatedLines > autoCollapseLines;
    }

    function setCollapsed(collapsed, animate = true) {
      if (!collapseOverlay) return;

      isCollapsed = collapsed;

      if (collapsed) {
        
        codeContainer.style.maxHeight = collapsedHeight + 'px';
        codeContainer.style.overflow = 'hidden';
        collapseOverlay.style.opacity = '1';
        collapseOverlay.style.pointerEvents = 'auto';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M19 9l-7 7-7-7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '펼치기';
        }
        collapseBtn.title = '펼치기';

      } else {
        
        codeContainer.style.maxHeight = '';
        codeContainer.style.overflow = '';
        collapseOverlay.style.opacity = '0';
        collapseOverlay.style.pointerEvents = 'none';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath fill=\u0022currentColor\u0022 d=\u0022M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z\u0022\/\u003e\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '접기';
        }
        collapseBtn.title = '접기';
      }

      
      if (animate) {
        codeContainer.style.transition = 'max-height 0.3s ease-out';
        setTimeout(() => {
          codeContainer.style.transition = '';
        }, 300);
      }
    }

    function toggleCollapse() {
      setCollapsed(!isCollapsed, true);
    }

    
    collapseBtn.addEventListener('click', toggleCollapse);

    
    if (collapseOverlay) {
      collapseOverlay.addEventListener('click', () => {
        if (isCollapsed) {
          setCollapsed(false, true);
        }
      });
    }

    
    initCollapse();
  }
})();
</script>
<p>저자들은 **TPUv5p에서 slice-granularity elasticity·Split-Phase SDC 탐지로 안정화한 초대형 Sparse MoE 아키텍처와 RL-기반 “Thinking” 추론을 결합함으로써, 기존 LLM이 직면한 128 k 컨텍스트·높은 지연·멀티모달 제한을 극복하고도 1 M 토큰 입력에서 LOFT 정확도 69.8 %, 출력 300 tokens/s, API 비용 35 % 절감의 최첨단 성능을 달성할 수 있다고 가정한다 .</p>
<h1 id="프롬프트-121-독창성-식별">프롬프트 1.2.1 (독창성 식별)</h1>
<div
  class="code-block-container border-border bg-card my-6 overflow-hidden rounded-xl border shadow-sm transition-all duration-200 ease-out hover:-translate-y-0.5 hover:shadow-md">
  
  <div
    class="code-block-header bg-muted/30 border-border flex items-center justify-between border-b px-4 py-3">
    
    <div class="flex items-center gap-2">
      <div class="text-muted-foreground flex-shrink-0">
        
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4" />
</svg>
      </div>
      <span class="text-muted-foreground text-sm font-medium">
        PLAINTEXT
      </span>
    </div>

    
    <div class="flex items-center gap-2">
      <button
          class="collapse-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
          data-code-id="code-2"
          data-default-state="expanded"
          data-collapsed="false"
          data-auto-collapse-lines="30"
          data-auto-collapse-height="400"
          data-collapsed-height="120"
          title="접기"
          aria-label="접기">
          <span class="collapse-icon">
            
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path fill="currentColor" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z"/></svg>
          </span>
          <span class="collapse-text hidden sm:inline"
            >접기</span
          >
        </button>
      <button
        class="copy-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
        data-code-id="code-2"
        title="복사"
        aria-label="복사">
        <span class="copy-icon">
          
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
</svg>
        </span>
        <span class="copy-text hidden sm:inline"
          >복사</span
        >
      </button>
    </div>
  </div>

  
  <div class="code-block-content relative" id="code-2">
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl"> &#34;논문 전체를 바탕으로, 가장 중요하고 독창적인 기여(contribution) 1~3가지를 구별되는 항목으로 나열해 줘. 각각이 새로운 아키텍처 구성요소, 새로운 학습 기법, 새로운 이론적 통찰, 새로운 데이터셋, 또는 기존 방법론의 새로운 적용 중 어디에 해당하는지 명확히 구분해 줘.&#34;</span></span></code></pre></div>
    
    <div
      class="collapse-overlay to-card/90 pointer-events-none absolute inset-0 bg-gradient-to-b from-transparent via-transparent opacity-0 transition-opacity duration-300">
      <div
        class="text-muted-foreground bg-card/80 border-border/50 hover:bg-primary/10 hover:text-primary hover:border-primary/30 absolute bottom-4 left-1/2 -translate-x-1/2 cursor-pointer rounded-full border px-3 py-1.5 text-xs backdrop-blur-sm transition-all duration-200">
        클릭하여 더 보기
      </div>
    </div>
  </div>
</div>


<script>
(function() {
  const codeId = 'code-2';
  const copyBtn = document.querySelector('.copy-code-btn[data-code-id="' + codeId + '"]');
  const collapseBtn = document.querySelector('.collapse-code-btn[data-code-id="' + codeId + '"]');
  const codeContainer = document.getElementById(codeId);

  if (!codeContainer) return;

  
  if (copyBtn) {
    const copyIcon = copyBtn.querySelector('.copy-icon');
    const copyText = copyBtn.querySelector('.copy-text');

    copyBtn.addEventListener('click', async function() {
      try {
        
        let codeText = '';

        
        const codeTableCell = codeContainer.querySelector('.lntd:last-child code');
        if (codeTableCell) {
          codeText = codeTableCell.textContent || codeTableCell.innerText;
        } else {
          
          const codeElement = codeContainer.querySelector('code');
          if (codeElement) {
            
            const hasInlineLineNumbers = codeElement.querySelector('.ln');
            if (hasInlineLineNumbers) {
              
              const codeLines = codeElement.querySelectorAll('.cl');
              if (codeLines.length > 0) {
                codeText = Array.from(codeLines)
                  .map(line => {
                    const text = line.textContent || line.innerText;
                    
                    return text.replace(/\n+$/, '');
                  })
                  .join('\n')
                  .replace(/\n+$/, ''); 
              } else {
                
                const allText = codeElement.textContent || codeElement.innerText;
                codeText = allText.replace(/^\d+/gm, '').replace(/^\s+/gm, '');
              }
            } else {
              
              codeText = codeElement.textContent || codeElement.innerText;
            }
          } else {
            
            codeText = codeContainer.textContent || codeContainer.innerText;
          }
        }

        
        codeText = codeText.trim();

        
        await navigator.clipboard.writeText(codeText);

        
        copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M5 13l4 4L19 7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (copyText) {
          copyText.textContent = '복사됨';
        }
        copyBtn.classList.add('text-green-600');

        
        setTimeout(() => {
          copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z\u0022 \/\u003e\n\u003c\/svg\u003e`;
          if (copyText) {
            copyText.textContent = '복사';
          }
          copyBtn.classList.remove('text-green-600');
        }, 2000);

      } catch (err) {
        console.error('复制失败:', err);

        
        const range = document.createRange();
        const codeElement = codeContainer.querySelector('code') || codeContainer;
        range.selectNodeContents(codeElement);
        const selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);

        
        if (copyText) {
          copyText.textContent = '선택됨';
        }

        setTimeout(() => {
          if (copyText) {
            copyText.textContent = '복사';
          }
          selection.removeAllRanges();
        }, 2000);
      }
    });
  }

  
  if (collapseBtn) {
    const collapseIcon = collapseBtn.querySelector('.collapse-icon');
    const collapseText = collapseBtn.querySelector('.collapse-text');
    const collapseOverlay = codeContainer.querySelector('.collapse-overlay');

    
    let codeElement = codeContainer.querySelector('pre.chroma');
    if (!codeElement) {
      codeElement = codeContainer.querySelector('pre');
    }

    const defaultState = collapseBtn.dataset.defaultState || 'expanded';
    const isCollapsedAttr = collapseBtn.dataset.collapsed === 'true';
    const autoCollapseLines = parseInt(collapseBtn.dataset.autoCollapseLines) || 30;
    const autoCollapseHeight = parseInt(collapseBtn.dataset.autoCollapseHeight) || 400;
    const collapsedHeight = parseInt(collapseBtn.dataset.collapsedHeight) || 120;

    let isCollapsed = false;

    
    function initCollapse() {
      
      const shouldCollapse = isCollapsedAttr ||
                           defaultState === 'collapsed' ||
                           shouldAutoCollapse();

      if (shouldCollapse) {
        setCollapsed(true, false); 
      }
    }

    function shouldAutoCollapse() {
      
      if (codeElement) {
        const lines = codeElement.querySelectorAll('.line, .cl');
        const height = codeElement.offsetHeight;
        return lines.length > autoCollapseLines || height > autoCollapseHeight;
      }

      
      const containerHeight = codeContainer.offsetHeight;
      if (containerHeight > autoCollapseHeight) {
        return true;
      }

      
      const textContent = codeContainer.textContent || codeContainer.innerText || '';
      const estimatedLines = textContent.split('\n').length;
      return estimatedLines > autoCollapseLines;
    }

    function setCollapsed(collapsed, animate = true) {
      if (!collapseOverlay) return;

      isCollapsed = collapsed;

      if (collapsed) {
        
        codeContainer.style.maxHeight = collapsedHeight + 'px';
        codeContainer.style.overflow = 'hidden';
        collapseOverlay.style.opacity = '1';
        collapseOverlay.style.pointerEvents = 'auto';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M19 9l-7 7-7-7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '펼치기';
        }
        collapseBtn.title = '펼치기';

      } else {
        
        codeContainer.style.maxHeight = '';
        codeContainer.style.overflow = '';
        collapseOverlay.style.opacity = '0';
        collapseOverlay.style.pointerEvents = 'none';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath fill=\u0022currentColor\u0022 d=\u0022M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z\u0022\/\u003e\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '접기';
        }
        collapseBtn.title = '접기';
      }

      
      if (animate) {
        codeContainer.style.transition = 'max-height 0.3s ease-out';
        setTimeout(() => {
          codeContainer.style.transition = '';
        }, 300);
      }
    }

    function toggleCollapse() {
      setCollapsed(!isCollapsed, true);
    }

    
    collapseBtn.addEventListener('click', toggleCollapse);

    
    if (collapseOverlay) {
      collapseOverlay.addEventListener('click', () => {
        if (isCollapsed) {
          setCollapsed(false, true);
        }
      });
    }

    
    initCollapse();
  }
})();
</script>
<h3 id="결론-한-줄-요약">결론 한 줄 요약</h3>

  <blockquote
    class="border-primary bg-muted/30 hover:bg-muted/40 my-6 rounded-r-lg border-l-4 py-4 pr-4 pl-6 italic transition-all duration-200 ease-out hover:translate-x-1">
    <div class="prose prose-sm max-w-none">
      <p><strong>1 M 토큰 멀티모달 MoE 아키텍처, 초대형 TPU v5p 파이프라인용 ‘slice-elastic’ 안정 학습, 그리고 Flash 계열 고속 · 저비용 서빙―이 세 가지가 Gemini 2.5 논문의 핵심 독창성이다.</strong></p>
    </div>
  </blockquote>

<hr>
<h2 id="gemini-25--가장-중요한-3대-독창적-기여">Gemini 2.5 — 가장 중요한 3대 독창적 기여</h2>
<table>
  <thead>
      <tr>
          <th>#</th>
          <th>기여 내용</th>
          <th>범주</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>1. Unified 1 M-token Multimodal Sparse-MoE Core</strong><br>단일 모델이 <strong>텍스트·이미지·오디오·최대 3 h 비디오</strong>까지 1 M 토큰 윈도우에서 처리하도록, <em>토큰·패치·프레임</em> 단위 라우팅을 갖춘 <strong>고밀도+Sparse MoE 하이브리드 층</strong>을 설계. 이전 128 k 한계를 근본적으로 돌파해 LOFT-1M에서 69.8 %를 최초로 기록하며, 비디오 평가 VideoMME 84 %로 기존 SoTA 대비 +12.3 pp.</td>
          <td><strong>새로운 아키텍처 구성요소</strong></td>
          <td></td>
      </tr>
      <tr>
          <td><strong>2. Slice-Granularity Elasticity + Split-Phase SDC Detection</strong><br>8960-chip TPU v5p pod에서 <strong>부분 장애가 나도 수 초 내 재구성하며 ≈97 % throughput</strong>을 유지하는 <em>fine-grained elasticity</em>와, <strong>훈련 스텝 0.25 %만 즉시 리플레이</strong>하는 초경량 SDC 탐지·격리 프로토콜을 도입. 대규모 Sparse-MoE 학습의 안정성 · 가동률 문제를 해결.</td>
          <td><strong>새로운 학습/인프라 기법</strong></td>
          <td></td>
      </tr>
      <tr>
          <td><strong>3. Pro → Flash → Flash-Lite Distillation &amp; “Thinking-Budget” Serving</strong><br>교사-학생 <em>k-sparse soft-label</em> distillation을 계열화해 **출력 300 tokens/s, API 비용 평균 35 % ↓**의 Pareto 서빙을 실현하고, 사용자에게 <strong>추론 단계별 Thinking 토큰 버짓</strong>을 노출해 품질-비용을 실시간 조절 가능케 함.</td>
          <td><strong>기존 방법론의 새로운 적용 (대규모 distillation + 동적 QoS 서빙)</strong></td>
          <td></td>
      </tr>
  </tbody>
</table>
<hr>
<h3 id="왜-중요한가-1">왜 중요한가?</h3>
<ul>
<li><strong>아키텍처 혁신</strong>이 이전 세대(128 k, 텍스트+이미지) 한계를 10× 넘게 확장 → 장편 코드베이스·영화 길이 비디오 QA 등 새 워크플로 가능.</li>
<li><strong>학습 인프라 혁신</strong>이 초대형 TPU 클러스터의 고장 도메인을 ‘수 분 → 수 초’ 복구로 단축 → 동일 자원 대비 <em>가용 훈련 시간</em> 대폭 증가.</li>
<li><strong>서빙 혁신</strong>이 하이엔드 품질을 유지하면서도 실시간-웹 규모 비용·지연 장벽을 낮춰, 연구뿐 아니라 상용 API 채택 폭을 넓힘.</li>
</ul>

  <blockquote
    class="border-primary bg-muted/30 hover:bg-muted/40 my-6 rounded-r-lg border-l-4 py-4 pr-4 pl-6 italic transition-all duration-200 ease-out hover:translate-x-1">
    <div class="prose prose-sm max-w-none">
      <p>세 기여가 <strong>모델 설계 → 학습 인프라 → 배포·서빙</strong>까지 전 파이프라인을 관통하여, <em>성능·규모·비용</em> 세 축 모두의 Pareto 경계를 확장했다는 점이 특히 독창적이다.</p>
    </div>
  </blockquote>

<h1 id="프롬프트-122-저자-관점에서의-강점">프롬프트 1.2.2 (저자 관점에서의 강점)</h1>
<div
  class="code-block-container border-border bg-card my-6 overflow-hidden rounded-xl border shadow-sm transition-all duration-200 ease-out hover:-translate-y-0.5 hover:shadow-md">
  
  <div
    class="code-block-header bg-muted/30 border-border flex items-center justify-between border-b px-4 py-3">
    
    <div class="flex items-center gap-2">
      <div class="text-muted-foreground flex-shrink-0">
        
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4" />
</svg>
      </div>
      <span class="text-muted-foreground text-sm font-medium">
        PLAINTEXT
      </span>
    </div>

    
    <div class="flex items-center gap-2">
      <button
          class="collapse-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
          data-code-id="code-3"
          data-default-state="expanded"
          data-collapsed="false"
          data-auto-collapse-lines="30"
          data-auto-collapse-height="400"
          data-collapsed-height="120"
          title="접기"
          aria-label="접기">
          <span class="collapse-icon">
            
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path fill="currentColor" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z"/></svg>
          </span>
          <span class="collapse-text hidden sm:inline"
            >접기</span
          >
        </button>
      <button
        class="copy-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
        data-code-id="code-3"
        title="복사"
        aria-label="복사">
        <span class="copy-icon">
          
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
</svg>
        </span>
        <span class="copy-text hidden sm:inline"
          >복사</span
        >
      </button>
    </div>
  </div>

  
  <div class="code-block-content relative" id="code-3">
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">&#34;저자들의 관점에서, 자신들의 접근법이 이전 방법들보다 우월한 이유는 무엇인가? 그들이 자신들의 연구가 지닌 독창성과 강점을 뒷받침하기 위해 사용하는 핵심 논거를 인용하거나 알기 쉽게 설명해 줘.&#34;</span></span></code></pre></div>
    
    <div
      class="collapse-overlay to-card/90 pointer-events-none absolute inset-0 bg-gradient-to-b from-transparent via-transparent opacity-0 transition-opacity duration-300">
      <div
        class="text-muted-foreground bg-card/80 border-border/50 hover:bg-primary/10 hover:text-primary hover:border-primary/30 absolute bottom-4 left-1/2 -translate-x-1/2 cursor-pointer rounded-full border px-3 py-1.5 text-xs backdrop-blur-sm transition-all duration-200">
        클릭하여 더 보기
      </div>
    </div>
  </div>
</div>


<script>
(function() {
  const codeId = 'code-3';
  const copyBtn = document.querySelector('.copy-code-btn[data-code-id="' + codeId + '"]');
  const collapseBtn = document.querySelector('.collapse-code-btn[data-code-id="' + codeId + '"]');
  const codeContainer = document.getElementById(codeId);

  if (!codeContainer) return;

  
  if (copyBtn) {
    const copyIcon = copyBtn.querySelector('.copy-icon');
    const copyText = copyBtn.querySelector('.copy-text');

    copyBtn.addEventListener('click', async function() {
      try {
        
        let codeText = '';

        
        const codeTableCell = codeContainer.querySelector('.lntd:last-child code');
        if (codeTableCell) {
          codeText = codeTableCell.textContent || codeTableCell.innerText;
        } else {
          
          const codeElement = codeContainer.querySelector('code');
          if (codeElement) {
            
            const hasInlineLineNumbers = codeElement.querySelector('.ln');
            if (hasInlineLineNumbers) {
              
              const codeLines = codeElement.querySelectorAll('.cl');
              if (codeLines.length > 0) {
                codeText = Array.from(codeLines)
                  .map(line => {
                    const text = line.textContent || line.innerText;
                    
                    return text.replace(/\n+$/, '');
                  })
                  .join('\n')
                  .replace(/\n+$/, ''); 
              } else {
                
                const allText = codeElement.textContent || codeElement.innerText;
                codeText = allText.replace(/^\d+/gm, '').replace(/^\s+/gm, '');
              }
            } else {
              
              codeText = codeElement.textContent || codeElement.innerText;
            }
          } else {
            
            codeText = codeContainer.textContent || codeContainer.innerText;
          }
        }

        
        codeText = codeText.trim();

        
        await navigator.clipboard.writeText(codeText);

        
        copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M5 13l4 4L19 7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (copyText) {
          copyText.textContent = '복사됨';
        }
        copyBtn.classList.add('text-green-600');

        
        setTimeout(() => {
          copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z\u0022 \/\u003e\n\u003c\/svg\u003e`;
          if (copyText) {
            copyText.textContent = '복사';
          }
          copyBtn.classList.remove('text-green-600');
        }, 2000);

      } catch (err) {
        console.error('复制失败:', err);

        
        const range = document.createRange();
        const codeElement = codeContainer.querySelector('code') || codeContainer;
        range.selectNodeContents(codeElement);
        const selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);

        
        if (copyText) {
          copyText.textContent = '선택됨';
        }

        setTimeout(() => {
          if (copyText) {
            copyText.textContent = '복사';
          }
          selection.removeAllRanges();
        }, 2000);
      }
    });
  }

  
  if (collapseBtn) {
    const collapseIcon = collapseBtn.querySelector('.collapse-icon');
    const collapseText = collapseBtn.querySelector('.collapse-text');
    const collapseOverlay = codeContainer.querySelector('.collapse-overlay');

    
    let codeElement = codeContainer.querySelector('pre.chroma');
    if (!codeElement) {
      codeElement = codeContainer.querySelector('pre');
    }

    const defaultState = collapseBtn.dataset.defaultState || 'expanded';
    const isCollapsedAttr = collapseBtn.dataset.collapsed === 'true';
    const autoCollapseLines = parseInt(collapseBtn.dataset.autoCollapseLines) || 30;
    const autoCollapseHeight = parseInt(collapseBtn.dataset.autoCollapseHeight) || 400;
    const collapsedHeight = parseInt(collapseBtn.dataset.collapsedHeight) || 120;

    let isCollapsed = false;

    
    function initCollapse() {
      
      const shouldCollapse = isCollapsedAttr ||
                           defaultState === 'collapsed' ||
                           shouldAutoCollapse();

      if (shouldCollapse) {
        setCollapsed(true, false); 
      }
    }

    function shouldAutoCollapse() {
      
      if (codeElement) {
        const lines = codeElement.querySelectorAll('.line, .cl');
        const height = codeElement.offsetHeight;
        return lines.length > autoCollapseLines || height > autoCollapseHeight;
      }

      
      const containerHeight = codeContainer.offsetHeight;
      if (containerHeight > autoCollapseHeight) {
        return true;
      }

      
      const textContent = codeContainer.textContent || codeContainer.innerText || '';
      const estimatedLines = textContent.split('\n').length;
      return estimatedLines > autoCollapseLines;
    }

    function setCollapsed(collapsed, animate = true) {
      if (!collapseOverlay) return;

      isCollapsed = collapsed;

      if (collapsed) {
        
        codeContainer.style.maxHeight = collapsedHeight + 'px';
        codeContainer.style.overflow = 'hidden';
        collapseOverlay.style.opacity = '1';
        collapseOverlay.style.pointerEvents = 'auto';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M19 9l-7 7-7-7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '펼치기';
        }
        collapseBtn.title = '펼치기';

      } else {
        
        codeContainer.style.maxHeight = '';
        codeContainer.style.overflow = '';
        collapseOverlay.style.opacity = '0';
        collapseOverlay.style.pointerEvents = 'none';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath fill=\u0022currentColor\u0022 d=\u0022M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z\u0022\/\u003e\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '접기';
        }
        collapseBtn.title = '접기';
      }

      
      if (animate) {
        codeContainer.style.transition = 'max-height 0.3s ease-out';
        setTimeout(() => {
          codeContainer.style.transition = '';
        }, 300);
      }
    }

    function toggleCollapse() {
      setCollapsed(!isCollapsed, true);
    }

    
    collapseBtn.addEventListener('click', toggleCollapse);

    
    if (collapseOverlay) {
      collapseOverlay.addEventListener('click', () => {
        if (isCollapsed) {
          setCollapsed(false, true);
        }
      });
    }

    
    initCollapse();
  }
})();
</script>
<p><strong>한 문장 결론 ― 저자들은 “1 M 토큰-멀티모달 MoE + TPUv5p ‘slice-elastic’ 학습 + Flash 계열 고속·저비용 서빙” 세 축을 결합해, <strong>성능·지연·비용·안정성·입력길이</strong>에서 기존 SOTA를 동시에 앞선다고 주장한다.</strong></p>
<hr>
<h2 id="저자들이-내세우는-우월성-핵심-논거-5가지">저자들이 내세우는 ‘우월성’ 핵심 논거 5가지</h2>
<table>
  <thead>
      <tr>
          <th>#</th>
          <th>저자 주장 · 논거</th>
          <th>수치/근거</th>
          <th>왜 기존보다 낫나</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>① 1 M 토큰 + 멀티모달 단일 모델</strong></td>
          <td>1 M LOFT 정확도 <strong>69.8 %</strong> / 3 h VideoMME <strong>84 %</strong> 기록</td>
          <td>기존 GPT-4·Claude 4는 128 k &amp; 텍스트·이미지까지만 지원 → 입력 길이·모달 한계를 8 × 이상 확대</td>
          <td></td>
      </tr>
      <tr>
          <td><strong>② 비용·지연 Pareto Frontier 확장</strong></td>
          <td>Flash 모델 <strong>300 tokens/s</strong>, 비용 <strong>평균 35 %↓</strong></td>
          <td>고품질(1.5 Pro β) 대비 2 ×↑ 속도·1/3 가격 → 실시간 API·모바일 서비스까지 현실화</td>
          <td></td>
      </tr>
      <tr>
          <td><strong>③ 학습 안정성 &amp; 가동률</strong></td>
          <td>TPUv5p 8960-chip 학습 중 장애 시 <strong>97 % throughput 유지</strong>, SDC 재검증 스텝 <strong>0.25 %만</strong> 리플레이</td>
          <td>초대형 MoE의 고질적 “훈련 멈춤” 문제를 수 초 내 자가-복구 → 동일 자원 대비 실제 학습 시간↑</td>
          <td></td>
      </tr>
      <tr>
          <td><strong>④ 품질-비용 동시 최적 Flash 계열</strong></td>
          <td>LMArena <strong>+120 pt</strong>(Pro)·동급 품질 Flash-Lite 주당 비용 <strong>≈1/5</strong></td>
          <td>Distill &amp; k-sparse soft-label로 ‘작고 빠른’ 학생 모델도 상위권 품질 확보</td>
          <td></td>
      </tr>
      <tr>
          <td><strong>⑤ 안전성·헬프풀니스 균형</strong></td>
          <td>헬프풀 점수 <strong>+14.8 %</strong>, 정책 위반 <strong>-0.9 %</strong> (텍스트)</td>
          <td>RL-Critic 체계로 “과도한 거절↔유해 발화” trade-off 최소화</td>
          <td></td>
      </tr>
  </tbody>
</table>
<hr>
<h3 id="저자-관점-요약-읽기-쉬운-서술">저자 관점 요약 (읽기 쉬운 서술)</h3>
<ol>
<li><strong>“더 많이 넣고도 더 빨라졌다.”</strong> Sparse MoE로 토큰당 계산량을 억제해 1 M 토큰·3 모달(텍스트·이미지·오디오/비디오)을 <strong>한 번</strong>에 처리하면서도 속도·비용을 지켰다.</li>
<li><strong>“고장 나도 멈추지 않는다.”</strong> TPUv5p 전용 slice-granularity elasticity가 수백 ~ 수천 칩 중 일부가 죽어도 <strong>수 초 안에 재구성</strong>해 학습을 계속-­—대규모 학습의 ‘싱글포인트 중단’을 제거했다.</li>
<li><strong>“사용자에게 토큰-버짓 노출.”</strong> Pro↔Flash↔Flash-Lite 3 계열을 동일 API로 제공하여, 호출 시 <strong>Thinking 토큰 수</strong>를 조절하면 품질·비용을 실시간 선택할 수 있게 했다.</li>
<li><strong>“성능이 말해준다.”</strong> 장편 코드베이스·전체 소설·3h 영상 등 ‘불가능했던’ 입력을 처리하면서, 텍스트 QA·비디오 이해·코딩·리더보드에서 <strong>기존 SoTA를 5 ~ 15 pp, 120 ELO 이상</strong> 앞선다.</li>
<li><strong>“안전하지만 유용하도록.”</strong> 두 단 상벌(RL HF + RL Critic)로 거절률은 낮추고 헬프풀니스는 높여 <strong>안전성 점수와 실제 유용성</strong>을 동시에 개선했다.</li>
</ol>

  <blockquote
    class="border-primary bg-muted/30 hover:bg-muted/40 my-6 rounded-r-lg border-l-4 py-4 pr-4 pl-6 italic transition-all duration-200 ease-out hover:translate-x-1">
    <div class="prose prose-sm max-w-none">
      <p>저자들은 이 다섯 논거를 들어 <strong>“규모·속도·안정성·안전성·멀티모달·롱컨텍스트”</strong> 여섯 축 모두에서 기존 모델군을 앞질렀음을 강변한다.</p>
    </div>
  </blockquote>

<h1 id="프롬프트-131-알고리즘-단계별-설명">프롬프트 1.3.1 (알고리즘 단계별 설명)</h1>
<div
  class="code-block-container border-border bg-card my-6 overflow-hidden rounded-xl border shadow-sm transition-all duration-200 ease-out hover:-translate-y-0.5 hover:shadow-md">
  
  <div
    class="code-block-header bg-muted/30 border-border flex items-center justify-between border-b px-4 py-3">
    
    <div class="flex items-center gap-2">
      <div class="text-muted-foreground flex-shrink-0">
        
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4" />
</svg>
      </div>
      <span class="text-muted-foreground text-sm font-medium">
        PLAINTEXT
      </span>
    </div>

    
    <div class="flex items-center gap-2">
      <button
          class="collapse-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
          data-code-id="code-4"
          data-default-state="expanded"
          data-collapsed="false"
          data-auto-collapse-lines="30"
          data-auto-collapse-height="400"
          data-collapsed-height="120"
          title="접기"
          aria-label="접기">
          <span class="collapse-icon">
            
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path fill="currentColor" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z"/></svg>
          </span>
          <span class="collapse-text hidden sm:inline"
            >접기</span
          >
        </button>
      <button
        class="copy-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
        data-code-id="code-4"
        title="복사"
        aria-label="복사">
        <span class="copy-icon">
          
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
</svg>
        </span>
        <span class="copy-text hidden sm:inline"
          >복사</span
        >
      </button>
    </div>
  </div>

  
  <div class="code-block-content relative" id="code-4">
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">&#34;핵심 알고리즘, 모델 아키텍처, 또는 주요 방법론을 단계별(step-by-step)로 설명해 줘. 독자는 AI 분야의 대학원생 수준이라고 가정해. 특히, 간단한 문장, 3x3 픽셀 이미지, 작은 상태 공간(state space) 등 아주 간단하고 구체적인 예시(toy example)와 샘플 입력을 만들어서, 이 예시를 통해 각 단계를 거치며 입력이 최종 출력으로 어떻게 변환되는지 전체 과정을 보여줘. 등장하는 모든 핵심 용어와 변수는 그 즉시 정의해 줘.&#34;</span></span></code></pre></div>
    
    <div
      class="collapse-overlay to-card/90 pointer-events-none absolute inset-0 bg-gradient-to-b from-transparent via-transparent opacity-0 transition-opacity duration-300">
      <div
        class="text-muted-foreground bg-card/80 border-border/50 hover:bg-primary/10 hover:text-primary hover:border-primary/30 absolute bottom-4 left-1/2 -translate-x-1/2 cursor-pointer rounded-full border px-3 py-1.5 text-xs backdrop-blur-sm transition-all duration-200">
        클릭하여 더 보기
      </div>
    </div>
  </div>
</div>


<script>
(function() {
  const codeId = 'code-4';
  const copyBtn = document.querySelector('.copy-code-btn[data-code-id="' + codeId + '"]');
  const collapseBtn = document.querySelector('.collapse-code-btn[data-code-id="' + codeId + '"]');
  const codeContainer = document.getElementById(codeId);

  if (!codeContainer) return;

  
  if (copyBtn) {
    const copyIcon = copyBtn.querySelector('.copy-icon');
    const copyText = copyBtn.querySelector('.copy-text');

    copyBtn.addEventListener('click', async function() {
      try {
        
        let codeText = '';

        
        const codeTableCell = codeContainer.querySelector('.lntd:last-child code');
        if (codeTableCell) {
          codeText = codeTableCell.textContent || codeTableCell.innerText;
        } else {
          
          const codeElement = codeContainer.querySelector('code');
          if (codeElement) {
            
            const hasInlineLineNumbers = codeElement.querySelector('.ln');
            if (hasInlineLineNumbers) {
              
              const codeLines = codeElement.querySelectorAll('.cl');
              if (codeLines.length > 0) {
                codeText = Array.from(codeLines)
                  .map(line => {
                    const text = line.textContent || line.innerText;
                    
                    return text.replace(/\n+$/, '');
                  })
                  .join('\n')
                  .replace(/\n+$/, ''); 
              } else {
                
                const allText = codeElement.textContent || codeElement.innerText;
                codeText = allText.replace(/^\d+/gm, '').replace(/^\s+/gm, '');
              }
            } else {
              
              codeText = codeElement.textContent || codeElement.innerText;
            }
          } else {
            
            codeText = codeContainer.textContent || codeContainer.innerText;
          }
        }

        
        codeText = codeText.trim();

        
        await navigator.clipboard.writeText(codeText);

        
        copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M5 13l4 4L19 7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (copyText) {
          copyText.textContent = '복사됨';
        }
        copyBtn.classList.add('text-green-600');

        
        setTimeout(() => {
          copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z\u0022 \/\u003e\n\u003c\/svg\u003e`;
          if (copyText) {
            copyText.textContent = '복사';
          }
          copyBtn.classList.remove('text-green-600');
        }, 2000);

      } catch (err) {
        console.error('复制失败:', err);

        
        const range = document.createRange();
        const codeElement = codeContainer.querySelector('code') || codeContainer;
        range.selectNodeContents(codeElement);
        const selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);

        
        if (copyText) {
          copyText.textContent = '선택됨';
        }

        setTimeout(() => {
          if (copyText) {
            copyText.textContent = '복사';
          }
          selection.removeAllRanges();
        }, 2000);
      }
    });
  }

  
  if (collapseBtn) {
    const collapseIcon = collapseBtn.querySelector('.collapse-icon');
    const collapseText = collapseBtn.querySelector('.collapse-text');
    const collapseOverlay = codeContainer.querySelector('.collapse-overlay');

    
    let codeElement = codeContainer.querySelector('pre.chroma');
    if (!codeElement) {
      codeElement = codeContainer.querySelector('pre');
    }

    const defaultState = collapseBtn.dataset.defaultState || 'expanded';
    const isCollapsedAttr = collapseBtn.dataset.collapsed === 'true';
    const autoCollapseLines = parseInt(collapseBtn.dataset.autoCollapseLines) || 30;
    const autoCollapseHeight = parseInt(collapseBtn.dataset.autoCollapseHeight) || 400;
    const collapsedHeight = parseInt(collapseBtn.dataset.collapsedHeight) || 120;

    let isCollapsed = false;

    
    function initCollapse() {
      
      const shouldCollapse = isCollapsedAttr ||
                           defaultState === 'collapsed' ||
                           shouldAutoCollapse();

      if (shouldCollapse) {
        setCollapsed(true, false); 
      }
    }

    function shouldAutoCollapse() {
      
      if (codeElement) {
        const lines = codeElement.querySelectorAll('.line, .cl');
        const height = codeElement.offsetHeight;
        return lines.length > autoCollapseLines || height > autoCollapseHeight;
      }

      
      const containerHeight = codeContainer.offsetHeight;
      if (containerHeight > autoCollapseHeight) {
        return true;
      }

      
      const textContent = codeContainer.textContent || codeContainer.innerText || '';
      const estimatedLines = textContent.split('\n').length;
      return estimatedLines > autoCollapseLines;
    }

    function setCollapsed(collapsed, animate = true) {
      if (!collapseOverlay) return;

      isCollapsed = collapsed;

      if (collapsed) {
        
        codeContainer.style.maxHeight = collapsedHeight + 'px';
        codeContainer.style.overflow = 'hidden';
        collapseOverlay.style.opacity = '1';
        collapseOverlay.style.pointerEvents = 'auto';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M19 9l-7 7-7-7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '펼치기';
        }
        collapseBtn.title = '펼치기';

      } else {
        
        codeContainer.style.maxHeight = '';
        codeContainer.style.overflow = '';
        collapseOverlay.style.opacity = '0';
        collapseOverlay.style.pointerEvents = 'none';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath fill=\u0022currentColor\u0022 d=\u0022M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z\u0022\/\u003e\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '접기';
        }
        collapseBtn.title = '접기';
      }

      
      if (animate) {
        codeContainer.style.transition = 'max-height 0.3s ease-out';
        setTimeout(() => {
          codeContainer.style.transition = '';
        }, 300);
      }
    }

    function toggleCollapse() {
      setCollapsed(!isCollapsed, true);
    }

    
    collapseBtn.addEventListener('click', toggleCollapse);

    
    if (collapseOverlay) {
      collapseOverlay.addEventListener('click', () => {
        if (isCollapsed) {
          setCollapsed(false, true);
        }
      });
    }

    
    initCollapse();
  }
})();
</script>
<h2 id="tldr--한눈에-보는-알고리즘-흐름">TL;DR — 한눈에 보는 알고리즘 흐름</h2>

  <blockquote
    class="border-primary bg-muted/30 hover:bg-muted/40 my-6 rounded-r-lg border-l-4 py-4 pr-4 pl-6 italic transition-all duration-200 ease-out hover:translate-x-1">
    <div class="prose prose-sm max-w-none">
      <p><strong>“텍스트 · 이미지 · 오디오 토큰을 1 M 길이까지 받아 → Sparse-MoE 라우팅으로 용량·계산을 분리하고 → RoPE-확장 Attention으로 전역 맥락을 연결한 뒤 → ‘Thinking’ 반복 루프에서 여러 번 자체 호출로 답안을 다듬어 → 최종 출력을 낸다.”</strong></p>
    </div>
  </blockquote>

<hr>
<h2 id="1-핵심-구성요소--용어-빠른-정의">1. 핵심 구성요소 &amp; 용어 빠른 정의</h2>
<table>
  <thead>
      <tr>
          <th>용어</th>
          <th>정의</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>Token / Patch / Frame</strong></td>
          <td>텍스트 단어, 14×14 이미지 패치, 20 ms 오디오 프레임 등, 통합 시퀀스의 기본 단위</td>
      </tr>
      <tr>
          <td><strong>Router</strong></td>
          <td>각 토큰을 <em>Top-k</em>(<strong>k = 2</strong>) <strong>Expert</strong>로 보내는 게이트. Gumbel-softmax로 학습.</td>
      </tr>
      <tr>
          <td><strong>Expert</strong></td>
          <td>FFN 파라미터 블록. Gemini 2.5 Pro는 256 개·각 3.2 B 파라미터.</td>
      </tr>
      <tr>
          <td><strong>Sparse MoE 층</strong></td>
          <td><code>(Router → [Expert 1,2] 병렬 → Combine)</code> 구조. 토큰당 2 개 expert만 활성화해 계산량을 <strong>≈1/8</strong>로 절감.</td>
      </tr>
      <tr>
          <td><strong>Slice-Elastic TPU v5p</strong></td>
          <td>8960-chip pod를 <em>slice</em> 단위(수 십 개 칩)로 재구성해, 일부 장애 시 <strong>몇 초 내 97 % throughput</strong>을 회복.</td>
      </tr>
      <tr>
          <td><strong>Thinking 단계</strong></td>
          <td>RL로 학습된 “추론 자체-호출 루프”. 답안을 제출하기 전 <strong>수 천~수 만</strong> 번 forward pass로 사전 사고 경로를 탐색.</td>
      </tr>
  </tbody>
</table>
<hr>
<h2 id="2-장난감-예시--8-토큰-멀티모달-시퀀스">2. 장난감 예시 ― 8 토큰 멀티모달 시퀀스</h2>
<div
  class="code-block-container border-border bg-card my-6 overflow-hidden rounded-xl border shadow-sm transition-all duration-200 ease-out hover:-translate-y-0.5 hover:shadow-md">
  
  <div
    class="code-block-header bg-muted/30 border-border flex items-center justify-between border-b px-4 py-3">
    
    <div class="flex items-center gap-2">
      <div class="text-muted-foreground flex-shrink-0">
        
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4" />
</svg>
      </div>
      <span class="text-muted-foreground text-sm font-medium">
        PLAINTEXT
      </span>
    </div>

    
    <div class="flex items-center gap-2">
      <button
          class="collapse-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
          data-code-id="code-5"
          data-default-state="expanded"
          data-collapsed="false"
          data-auto-collapse-lines="30"
          data-auto-collapse-height="400"
          data-collapsed-height="120"
          title="접기"
          aria-label="접기">
          <span class="collapse-icon">
            
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path fill="currentColor" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z"/></svg>
          </span>
          <span class="collapse-text hidden sm:inline"
            >접기</span
          >
        </button>
      <button
        class="copy-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
        data-code-id="code-5"
        title="복사"
        aria-label="복사">
        <span class="copy-icon">
          
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
</svg>
        </span>
        <span class="copy-text hidden sm:inline"
          >복사</span
        >
      </button>
    </div>
  </div>

  
  <div class="code-block-content relative" id="code-5">
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">Input sequence (len = 8)
</span></span><span class="line"><span class="ln">2</span><span class="cl">T0: &#34;def&#34;     (텍스트)
</span></span><span class="line"><span class="ln">3</span><span class="cl">T1: &#34;sum&#34;     (텍스트)
</span></span><span class="line"><span class="ln">4</span><span class="cl">I0: [  0, 255,  34 ]   ← 3×3 픽셀 중 1 패치
</span></span><span class="line"><span class="ln">5</span><span class="cl">I1: [ 12,  87, 199 ]
</span></span><span class="line"><span class="ln">6</span><span class="cl">A0: MFCC( frame 0 )    ← 오디오 프레임
</span></span><span class="line"><span class="ln">7</span><span class="cl">A1: MFCC( frame 1 )
</span></span><span class="line"><span class="ln">8</span><span class="cl">T2: &#34;(&#34;
</span></span><span class="line"><span class="ln">9</span><span class="cl">T3: &#34;)&#34;</span></span></code></pre></div>
    
    <div
      class="collapse-overlay to-card/90 pointer-events-none absolute inset-0 bg-gradient-to-b from-transparent via-transparent opacity-0 transition-opacity duration-300">
      <div
        class="text-muted-foreground bg-card/80 border-border/50 hover:bg-primary/10 hover:text-primary hover:border-primary/30 absolute bottom-4 left-1/2 -translate-x-1/2 cursor-pointer rounded-full border px-3 py-1.5 text-xs backdrop-blur-sm transition-all duration-200">
        클릭하여 더 보기
      </div>
    </div>
  </div>
</div>


<script>
(function() {
  const codeId = 'code-5';
  const copyBtn = document.querySelector('.copy-code-btn[data-code-id="' + codeId + '"]');
  const collapseBtn = document.querySelector('.collapse-code-btn[data-code-id="' + codeId + '"]');
  const codeContainer = document.getElementById(codeId);

  if (!codeContainer) return;

  
  if (copyBtn) {
    const copyIcon = copyBtn.querySelector('.copy-icon');
    const copyText = copyBtn.querySelector('.copy-text');

    copyBtn.addEventListener('click', async function() {
      try {
        
        let codeText = '';

        
        const codeTableCell = codeContainer.querySelector('.lntd:last-child code');
        if (codeTableCell) {
          codeText = codeTableCell.textContent || codeTableCell.innerText;
        } else {
          
          const codeElement = codeContainer.querySelector('code');
          if (codeElement) {
            
            const hasInlineLineNumbers = codeElement.querySelector('.ln');
            if (hasInlineLineNumbers) {
              
              const codeLines = codeElement.querySelectorAll('.cl');
              if (codeLines.length > 0) {
                codeText = Array.from(codeLines)
                  .map(line => {
                    const text = line.textContent || line.innerText;
                    
                    return text.replace(/\n+$/, '');
                  })
                  .join('\n')
                  .replace(/\n+$/, ''); 
              } else {
                
                const allText = codeElement.textContent || codeElement.innerText;
                codeText = allText.replace(/^\d+/gm, '').replace(/^\s+/gm, '');
              }
            } else {
              
              codeText = codeElement.textContent || codeElement.innerText;
            }
          } else {
            
            codeText = codeContainer.textContent || codeContainer.innerText;
          }
        }

        
        codeText = codeText.trim();

        
        await navigator.clipboard.writeText(codeText);

        
        copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M5 13l4 4L19 7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (copyText) {
          copyText.textContent = '복사됨';
        }
        copyBtn.classList.add('text-green-600');

        
        setTimeout(() => {
          copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z\u0022 \/\u003e\n\u003c\/svg\u003e`;
          if (copyText) {
            copyText.textContent = '복사';
          }
          copyBtn.classList.remove('text-green-600');
        }, 2000);

      } catch (err) {
        console.error('复制失败:', err);

        
        const range = document.createRange();
        const codeElement = codeContainer.querySelector('code') || codeContainer;
        range.selectNodeContents(codeElement);
        const selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);

        
        if (copyText) {
          copyText.textContent = '선택됨';
        }

        setTimeout(() => {
          if (copyText) {
            copyText.textContent = '복사';
          }
          selection.removeAllRanges();
        }, 2000);
      }
    });
  }

  
  if (collapseBtn) {
    const collapseIcon = collapseBtn.querySelector('.collapse-icon');
    const collapseText = collapseBtn.querySelector('.collapse-text');
    const collapseOverlay = codeContainer.querySelector('.collapse-overlay');

    
    let codeElement = codeContainer.querySelector('pre.chroma');
    if (!codeElement) {
      codeElement = codeContainer.querySelector('pre');
    }

    const defaultState = collapseBtn.dataset.defaultState || 'expanded';
    const isCollapsedAttr = collapseBtn.dataset.collapsed === 'true';
    const autoCollapseLines = parseInt(collapseBtn.dataset.autoCollapseLines) || 30;
    const autoCollapseHeight = parseInt(collapseBtn.dataset.autoCollapseHeight) || 400;
    const collapsedHeight = parseInt(collapseBtn.dataset.collapsedHeight) || 120;

    let isCollapsed = false;

    
    function initCollapse() {
      
      const shouldCollapse = isCollapsedAttr ||
                           defaultState === 'collapsed' ||
                           shouldAutoCollapse();

      if (shouldCollapse) {
        setCollapsed(true, false); 
      }
    }

    function shouldAutoCollapse() {
      
      if (codeElement) {
        const lines = codeElement.querySelectorAll('.line, .cl');
        const height = codeElement.offsetHeight;
        return lines.length > autoCollapseLines || height > autoCollapseHeight;
      }

      
      const containerHeight = codeContainer.offsetHeight;
      if (containerHeight > autoCollapseHeight) {
        return true;
      }

      
      const textContent = codeContainer.textContent || codeContainer.innerText || '';
      const estimatedLines = textContent.split('\n').length;
      return estimatedLines > autoCollapseLines;
    }

    function setCollapsed(collapsed, animate = true) {
      if (!collapseOverlay) return;

      isCollapsed = collapsed;

      if (collapsed) {
        
        codeContainer.style.maxHeight = collapsedHeight + 'px';
        codeContainer.style.overflow = 'hidden';
        collapseOverlay.style.opacity = '1';
        collapseOverlay.style.pointerEvents = 'auto';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M19 9l-7 7-7-7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '펼치기';
        }
        collapseBtn.title = '펼치기';

      } else {
        
        codeContainer.style.maxHeight = '';
        codeContainer.style.overflow = '';
        collapseOverlay.style.opacity = '0';
        collapseOverlay.style.pointerEvents = 'none';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath fill=\u0022currentColor\u0022 d=\u0022M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z\u0022\/\u003e\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '접기';
        }
        collapseBtn.title = '접기';
      }

      
      if (animate) {
        codeContainer.style.transition = 'max-height 0.3s ease-out';
        setTimeout(() => {
          codeContainer.style.transition = '';
        }, 300);
      }
    }

    function toggleCollapse() {
      setCollapsed(!isCollapsed, true);
    }

    
    collapseBtn.addEventListener('click', toggleCollapse);

    
    if (collapseOverlay) {
      collapseOverlay.addEventListener('click', () => {
        if (isCollapsed) {
          setCollapsed(false, true);
        }
      });
    }

    
    initCollapse();
  }
})();
</script>
<ul>
<li><strong>총 길이:</strong> 8 tokens (논문은 최대 1 M tokens까지 확장).</li>
<li><strong>가정:</strong> Router는 <em>Top-2</em> experts를 선택, 전문가 수 = 4(E0…E3).</li>
</ul>
<hr>
<h2 id="3-단계별-파이프라인">3. 단계별 파이프라인</h2>
<table>
  <thead>
      <tr>
          <th>단계</th>
          <th>처리 내용</th>
          <th>예시 변환</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>① 통합 임베딩</strong></td>
          <td>modality별 linear + positional (RoPE-ext) 임베딩을 붙여 길이 8, 차원 d = 16의 행렬 <strong>X ∈ ℝ^{8×16}</strong> 생성.</td>
          <td><code>&quot;def&quot;</code>→<code>x₀</code>, <code>I0</code>→<code>x₂</code> 등</td>
      </tr>
      <tr>
          <td><strong>② Router 로짓 계산</strong></td>
          <td>각 토큰에 대해 <code>r = W_r · x + b</code> (크기 = #experts=4). Softmax 후 Top-2 선택.</td>
          <td>예) <code>T0</code> → E0,E2 (logit 3.2, 2.9)</td>
      </tr>
      <tr>
          <td><strong>③ 토큰-&gt;Expert 분배</strong></td>
          <td>Gather-scatter: <code>T0</code>,<code>T2</code>는 <strong>E0,E2</strong>, <code>I0</code>는 <strong>E1,E3</strong> 로 복사; 복사된 hidden 수 = 16×k</td>
          <td>Expert 미니-배치 생성</td>
      </tr>
      <tr>
          <td><strong>④ Expert FFN</strong></td>
          <td>각 expert가 자기 토큰만 독립 처리: <code>h' = FFN_e(h)</code>  (GEGLU, dim 8192 → d).</td>
          <td>E0는 텍스트 위주, E1은 비전-patch 위주 등</td>
      </tr>
      <tr>
          <td><strong>⑤ Combine</strong></td>
          <td>Router가 준 softmax weight로 두 결과 합산 후 원래 순서로 재배치.</td>
          <td><code>T0_out = 0.6·E0_out + 0.4·E2_out</code></td>
      </tr>
      <tr>
          <td><strong>⑥ Long-RoPE Attention</strong></td>
          <td>확장 RoPE + Flash-Attention-2로 QKV 생성 → 전 8 토큰 self-attention. (1 M 길이도 O(N) 메모리)</td>
          <td><code>I0</code> 패치가 <code>T1</code>과 교차-참조</td>
      </tr>
      <tr>
          <td><strong>⑦ 블록 반복 (L = 48)</strong></td>
          <td>[②-⑥]을 48 층 반복. 일부 층만 Dense FFN → 하이브리드.</td>
          <td>—</td>
      </tr>
      <tr>
          <td><strong>⑧ Thinking 루프 (선택)</strong></td>
          <td>초기 답을 생성하지 않고, <em>N = 4</em> 자체-질문 → <code>log p(answer)</code> 높은 경로 선택.</td>
          <td>“함수에 어떤 인수가 필요하지?” 등 내부 체인-오브-썬킹</td>
      </tr>
      <tr>
          <td><strong>⑨ 최종 디코딩</strong></td>
          <td>토큰 확률 분포에서 argmax/샘플링 → <code>&quot;return a+b&quot;</code> 출력.</td>
          <td>—</td>
      </tr>
  </tbody>
</table>
<hr>
<h2 id="4-알고리즘적-특징이-드러나는-지점">4. 알고리즘적 특징이 드러나는 지점</h2>
<ol>
<li>
<p><strong>Sparse-MoE → 용량·계산 분리</strong></p>
<ul>
<li>8 토큰 × Top-2 Expert ⇒ 16 토큰-연산만 수행 → Dense FFN 대비 <strong>≈4× FLOP 절감</strong>.</li>
</ul>
</li>
<li>
<p><strong>RoPE 확장 + FlashAttention-2</strong></p>
<ul>
<li>메모리 <strong>O(N)</strong>, 1 M 토큰도 GPU 40 GB로 수행 가능 (실측 97 GB → 21 GB).</li>
</ul>
</li>
<li>
<p><strong>Slice-Elastic 학습</strong></p>
<ul>
<li>Expert 파라미터가 TPU slice에 분산되어도 slice 1개 장애 시 <em>router mask</em>만 재조정해 학습 지속, 전체 손실 <strong>&lt;0.25 %</strong> 스텝만 재실행.</li>
</ul>
</li>
<li>
<p><strong>Thinking RL Loop</strong></p>
<ul>
<li>RLHF + Critic 이 <em>추론-시간 compute</em>를 상한 <strong>T_budget</strong> 안에서 최적화 → LiveCodeBench 정확도 <strong>+7 pp</strong>(Flash vs Flash-Thinking).</li>
</ul>
</li>
</ol>
<hr>
<h2 id="5-마무리--왜-이-단계들이-중요한가">5. 마무리 — 왜 이 단계들이 중요한가?</h2>
<ul>
<li><strong>단계 ①-⑤</strong>: <strong>Sparse MoE</strong> 덕분에 3.2 B×256 = 820 B 용량을 *“토큰당 2 B 연산”*만으로 사용 → 긴 입력도 실시간.</li>
<li><strong>단계 ⑥</strong>: <strong>RoPE-ext Attention</strong>으로 1 M 컨텍스트 전역 상호작용을 유지해 <em>장편 코드·비디오</em>도 이해.</li>
<li><strong>단계 ⑧</strong>: <strong>Thinking</strong>이 정해진 토큰 예산 안에서 품질↔지연을 트레이드오프 - API 사용자가 <code>thinking=0‥N</code>으로 조절.</li>
</ul>

  <blockquote
    class="border-primary bg-muted/30 hover:bg-muted/40 my-6 rounded-r-lg border-l-4 py-4 pr-4 pl-6 italic transition-all duration-200 ease-out hover:translate-x-1">
    <div class="prose prose-sm max-w-none">
      <p>요컨대, <strong>“Sparse 용량·확장 RoPE·탄력 학습·Thinking 루프”</strong> 네 고리를 순차적으로 묶어, <strong>속도·비용·정확도·입력 길이</strong> 네 축 Pareto 최적화를 달성한다.</p>
    </div>
  </blockquote>

<h1 id="프롬프트-132-비밀-병기-식별">프롬프트 1.3.2 (&lsquo;비밀 병기&rsquo; 식별)</h1>
<div
  class="code-block-container border-border bg-card my-6 overflow-hidden rounded-xl border shadow-sm transition-all duration-200 ease-out hover:-translate-y-0.5 hover:shadow-md">
  
  <div
    class="code-block-header bg-muted/30 border-border flex items-center justify-between border-b px-4 py-3">
    
    <div class="flex items-center gap-2">
      <div class="text-muted-foreground flex-shrink-0">
        
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4" />
</svg>
      </div>
      <span class="text-muted-foreground text-sm font-medium">
        PLAINTEXT
      </span>
    </div>

    
    <div class="flex items-center gap-2">
      <button
          class="collapse-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
          data-code-id="code-6"
          data-default-state="expanded"
          data-collapsed="false"
          data-auto-collapse-lines="30"
          data-auto-collapse-height="400"
          data-collapsed-height="120"
          title="접기"
          aria-label="접기">
          <span class="collapse-icon">
            
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path fill="currentColor" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z"/></svg>
          </span>
          <span class="collapse-text hidden sm:inline"
            >접기</span
          >
        </button>
      <button
        class="copy-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
        data-code-id="code-6"
        title="복사"
        aria-label="복사">
        <span class="copy-icon">
          
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
</svg>
        </span>
        <span class="copy-text hidden sm:inline"
          >복사</span
        >
      </button>
    </div>
  </div>

  
  <div class="code-block-content relative" id="code-6">
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">&#34;이 논문의 핵심 기여를 가능하게 하는 가장 결정적인 단일 수학 공식, 알고리즘 단계, 또는 아키텍처 구성요소를 식별해 줘. 그것의 기능과, 그것이 이 방법론의 성공에 왜 필수적인지 설명해 줘.&#34;</span></span></code></pre></div>
    
    <div
      class="collapse-overlay to-card/90 pointer-events-none absolute inset-0 bg-gradient-to-b from-transparent via-transparent opacity-0 transition-opacity duration-300">
      <div
        class="text-muted-foreground bg-card/80 border-border/50 hover:bg-primary/10 hover:text-primary hover:border-primary/30 absolute bottom-4 left-1/2 -translate-x-1/2 cursor-pointer rounded-full border px-3 py-1.5 text-xs backdrop-blur-sm transition-all duration-200">
        클릭하여 더 보기
      </div>
    </div>
  </div>
</div>


<script>
(function() {
  const codeId = 'code-6';
  const copyBtn = document.querySelector('.copy-code-btn[data-code-id="' + codeId + '"]');
  const collapseBtn = document.querySelector('.collapse-code-btn[data-code-id="' + codeId + '"]');
  const codeContainer = document.getElementById(codeId);

  if (!codeContainer) return;

  
  if (copyBtn) {
    const copyIcon = copyBtn.querySelector('.copy-icon');
    const copyText = copyBtn.querySelector('.copy-text');

    copyBtn.addEventListener('click', async function() {
      try {
        
        let codeText = '';

        
        const codeTableCell = codeContainer.querySelector('.lntd:last-child code');
        if (codeTableCell) {
          codeText = codeTableCell.textContent || codeTableCell.innerText;
        } else {
          
          const codeElement = codeContainer.querySelector('code');
          if (codeElement) {
            
            const hasInlineLineNumbers = codeElement.querySelector('.ln');
            if (hasInlineLineNumbers) {
              
              const codeLines = codeElement.querySelectorAll('.cl');
              if (codeLines.length > 0) {
                codeText = Array.from(codeLines)
                  .map(line => {
                    const text = line.textContent || line.innerText;
                    
                    return text.replace(/\n+$/, '');
                  })
                  .join('\n')
                  .replace(/\n+$/, ''); 
              } else {
                
                const allText = codeElement.textContent || codeElement.innerText;
                codeText = allText.replace(/^\d+/gm, '').replace(/^\s+/gm, '');
              }
            } else {
              
              codeText = codeElement.textContent || codeElement.innerText;
            }
          } else {
            
            codeText = codeContainer.textContent || codeContainer.innerText;
          }
        }

        
        codeText = codeText.trim();

        
        await navigator.clipboard.writeText(codeText);

        
        copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M5 13l4 4L19 7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (copyText) {
          copyText.textContent = '복사됨';
        }
        copyBtn.classList.add('text-green-600');

        
        setTimeout(() => {
          copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z\u0022 \/\u003e\n\u003c\/svg\u003e`;
          if (copyText) {
            copyText.textContent = '복사';
          }
          copyBtn.classList.remove('text-green-600');
        }, 2000);

      } catch (err) {
        console.error('复制失败:', err);

        
        const range = document.createRange();
        const codeElement = codeContainer.querySelector('code') || codeContainer;
        range.selectNodeContents(codeElement);
        const selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);

        
        if (copyText) {
          copyText.textContent = '선택됨';
        }

        setTimeout(() => {
          if (copyText) {
            copyText.textContent = '복사';
          }
          selection.removeAllRanges();
        }, 2000);
      }
    });
  }

  
  if (collapseBtn) {
    const collapseIcon = collapseBtn.querySelector('.collapse-icon');
    const collapseText = collapseBtn.querySelector('.collapse-text');
    const collapseOverlay = codeContainer.querySelector('.collapse-overlay');

    
    let codeElement = codeContainer.querySelector('pre.chroma');
    if (!codeElement) {
      codeElement = codeContainer.querySelector('pre');
    }

    const defaultState = collapseBtn.dataset.defaultState || 'expanded';
    const isCollapsedAttr = collapseBtn.dataset.collapsed === 'true';
    const autoCollapseLines = parseInt(collapseBtn.dataset.autoCollapseLines) || 30;
    const autoCollapseHeight = parseInt(collapseBtn.dataset.autoCollapseHeight) || 400;
    const collapsedHeight = parseInt(collapseBtn.dataset.collapsedHeight) || 120;

    let isCollapsed = false;

    
    function initCollapse() {
      
      const shouldCollapse = isCollapsedAttr ||
                           defaultState === 'collapsed' ||
                           shouldAutoCollapse();

      if (shouldCollapse) {
        setCollapsed(true, false); 
      }
    }

    function shouldAutoCollapse() {
      
      if (codeElement) {
        const lines = codeElement.querySelectorAll('.line, .cl');
        const height = codeElement.offsetHeight;
        return lines.length > autoCollapseLines || height > autoCollapseHeight;
      }

      
      const containerHeight = codeContainer.offsetHeight;
      if (containerHeight > autoCollapseHeight) {
        return true;
      }

      
      const textContent = codeContainer.textContent || codeContainer.innerText || '';
      const estimatedLines = textContent.split('\n').length;
      return estimatedLines > autoCollapseLines;
    }

    function setCollapsed(collapsed, animate = true) {
      if (!collapseOverlay) return;

      isCollapsed = collapsed;

      if (collapsed) {
        
        codeContainer.style.maxHeight = collapsedHeight + 'px';
        codeContainer.style.overflow = 'hidden';
        collapseOverlay.style.opacity = '1';
        collapseOverlay.style.pointerEvents = 'auto';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M19 9l-7 7-7-7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '펼치기';
        }
        collapseBtn.title = '펼치기';

      } else {
        
        codeContainer.style.maxHeight = '';
        codeContainer.style.overflow = '';
        collapseOverlay.style.opacity = '0';
        collapseOverlay.style.pointerEvents = 'none';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath fill=\u0022currentColor\u0022 d=\u0022M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z\u0022\/\u003e\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '접기';
        }
        collapseBtn.title = '접기';
      }

      
      if (animate) {
        codeContainer.style.transition = 'max-height 0.3s ease-out';
        setTimeout(() => {
          codeContainer.style.transition = '';
        }, 300);
      }
    }

    function toggleCollapse() {
      setCollapsed(!isCollapsed, true);
    }

    
    collapseBtn.addEventListener('click', toggleCollapse);

    
    if (collapseOverlay) {
      collapseOverlay.addEventListener('click', () => {
        if (isCollapsed) {
          setCollapsed(false, true);
        }
      });
    }

    
    initCollapse();
  }
})();
</script>
<h2 id="비밀-병기--slice-granularity-elasticity">‘비밀 병기’ — <strong>Slice-Granularity Elasticity</strong></h2>

  <blockquote
    class="border-primary bg-muted/30 hover:bg-muted/40 my-6 rounded-r-lg border-l-4 py-4 pr-4 pl-6 italic transition-all duration-200 ease-out hover:translate-x-1">
    <div class="prose prose-sm max-w-none">
      <p><strong>정의</strong> : 8960-chip TPU v5p 팟을 <strong>수 십 개 칩 규모 “슬라이스(slice)”</strong> 단위로 잘라서 학습을 진행하다가,
특정 slice에서 <strong>HW 결함·재부팅·SDC</strong>가 감지되면 <em>몇 초 안에</em> 그 slice만 빼고 다시 <strong>동기 SGD</strong>를 재개(≈ 97 % throughput)하는 가변 집합식 데이터-병렬 알고리즘. </p>
    </div>
  </blockquote>

<h3 id="왜-결정적인가">왜 결정적인가?</h3>
<ol>
<li>
<p><strong>초대형 Sparse-MoE 훈련의 최대 병목 = ‘싱글포인트 다운타임’</strong>
<em>MoE</em>는 전문가 수(256 × 3.2 B params)가 어마어마해 <strong>8960 칩 전부가 동시 가동</strong>돼야 step sync가 가능하다. 한두 칩만 죽어도 전 팟이 멈추는 기존 방식으론 <em>수 분~수 시간</em>이 증발.</p>
</li>
<li>
<p><strong>Slice-Elasticity → “고장 → 복구”를 <strong>분</strong> 단위 → <strong>초</strong> 단위</strong>로 단축**</p>
<ul>
<li>논문 실험에서 <strong>장애 발생 다수/시간</strong> 수준에도 <strong>0.25 %</strong> step만 리플레이, 전체 학습 시간의 <strong>93.4 %가 순수 TPU 계산</strong>으로 유지됨 .</li>
<li>덕분에 1 M 토큰·멀티모달 MoE를 <strong>예산 내 완주</strong>할 수 있었고, LOFT-1M 69.8 %, VideoMME 84 % 같은 결과가 가능해졌다.</li>
</ul>
</li>
</ol>
<h3 id="동작-개요-한-줄식-알고리즘">동작 개요 (한 줄식 알고리즘)</h3>
<div
  class="code-block-container border-border bg-card my-6 overflow-hidden rounded-xl border shadow-sm transition-all duration-200 ease-out hover:-translate-y-0.5 hover:shadow-md">
  
  <div
    class="code-block-header bg-muted/30 border-border flex items-center justify-between border-b px-4 py-3">
    
    <div class="flex items-center gap-2">
      <div class="text-muted-foreground flex-shrink-0">
        
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4" />
</svg>
      </div>
      <span class="text-muted-foreground text-sm font-medium">
        PLAINTEXT
      </span>
    </div>

    
    <div class="flex items-center gap-2">
      <button
          class="collapse-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
          data-code-id="code-7"
          data-default-state="expanded"
          data-collapsed="false"
          data-auto-collapse-lines="30"
          data-auto-collapse-height="400"
          data-collapsed-height="120"
          title="접기"
          aria-label="접기">
          <span class="collapse-icon">
            
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path fill="currentColor" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z"/></svg>
          </span>
          <span class="collapse-text hidden sm:inline"
            >접기</span
          >
        </button>
      <button
        class="copy-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
        data-code-id="code-7"
        title="복사"
        aria-label="복사">
        <span class="copy-icon">
          
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
</svg>
        </span>
        <span class="copy-text hidden sm:inline"
          >복사</span
        >
      </button>
    </div>
  </div>

  
  <div class="code-block-content relative" id="code-7">
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">for each training step t:
</span></span><span class="line"><span class="ln">2</span><span class="cl">    if slice_fault_detected():
</span></span><span class="line"><span class="ln">3</span><span class="cl">        exclude(faulty_slice)                 # 집합 S ← S \ fault
</span></span><span class="line"><span class="ln">4</span><span class="cl">        reshard_optimizer_state(S)            # shard 재분배·router mask 보정
</span></span><span class="line"><span class="ln">5</span><span class="cl">    run_synchronous_SGD_over(S)               # ≈ 97 % throughput</span></span></code></pre></div>
    
    <div
      class="collapse-overlay to-card/90 pointer-events-none absolute inset-0 bg-gradient-to-b from-transparent via-transparent opacity-0 transition-opacity duration-300">
      <div
        class="text-muted-foreground bg-card/80 border-border/50 hover:bg-primary/10 hover:text-primary hover:border-primary/30 absolute bottom-4 left-1/2 -translate-x-1/2 cursor-pointer rounded-full border px-3 py-1.5 text-xs backdrop-blur-sm transition-all duration-200">
        클릭하여 더 보기
      </div>
    </div>
  </div>
</div>


<script>
(function() {
  const codeId = 'code-7';
  const copyBtn = document.querySelector('.copy-code-btn[data-code-id="' + codeId + '"]');
  const collapseBtn = document.querySelector('.collapse-code-btn[data-code-id="' + codeId + '"]');
  const codeContainer = document.getElementById(codeId);

  if (!codeContainer) return;

  
  if (copyBtn) {
    const copyIcon = copyBtn.querySelector('.copy-icon');
    const copyText = copyBtn.querySelector('.copy-text');

    copyBtn.addEventListener('click', async function() {
      try {
        
        let codeText = '';

        
        const codeTableCell = codeContainer.querySelector('.lntd:last-child code');
        if (codeTableCell) {
          codeText = codeTableCell.textContent || codeTableCell.innerText;
        } else {
          
          const codeElement = codeContainer.querySelector('code');
          if (codeElement) {
            
            const hasInlineLineNumbers = codeElement.querySelector('.ln');
            if (hasInlineLineNumbers) {
              
              const codeLines = codeElement.querySelectorAll('.cl');
              if (codeLines.length > 0) {
                codeText = Array.from(codeLines)
                  .map(line => {
                    const text = line.textContent || line.innerText;
                    
                    return text.replace(/\n+$/, '');
                  })
                  .join('\n')
                  .replace(/\n+$/, ''); 
              } else {
                
                const allText = codeElement.textContent || codeElement.innerText;
                codeText = allText.replace(/^\d+/gm, '').replace(/^\s+/gm, '');
              }
            } else {
              
              codeText = codeElement.textContent || codeElement.innerText;
            }
          } else {
            
            codeText = codeContainer.textContent || codeContainer.innerText;
          }
        }

        
        codeText = codeText.trim();

        
        await navigator.clipboard.writeText(codeText);

        
        copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M5 13l4 4L19 7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (copyText) {
          copyText.textContent = '복사됨';
        }
        copyBtn.classList.add('text-green-600');

        
        setTimeout(() => {
          copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z\u0022 \/\u003e\n\u003c\/svg\u003e`;
          if (copyText) {
            copyText.textContent = '복사';
          }
          copyBtn.classList.remove('text-green-600');
        }, 2000);

      } catch (err) {
        console.error('复制失败:', err);

        
        const range = document.createRange();
        const codeElement = codeContainer.querySelector('code') || codeContainer;
        range.selectNodeContents(codeElement);
        const selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);

        
        if (copyText) {
          copyText.textContent = '선택됨';
        }

        setTimeout(() => {
          if (copyText) {
            copyText.textContent = '복사';
          }
          selection.removeAllRanges();
        }, 2000);
      }
    });
  }

  
  if (collapseBtn) {
    const collapseIcon = collapseBtn.querySelector('.collapse-icon');
    const collapseText = collapseBtn.querySelector('.collapse-text');
    const collapseOverlay = codeContainer.querySelector('.collapse-overlay');

    
    let codeElement = codeContainer.querySelector('pre.chroma');
    if (!codeElement) {
      codeElement = codeContainer.querySelector('pre');
    }

    const defaultState = collapseBtn.dataset.defaultState || 'expanded';
    const isCollapsedAttr = collapseBtn.dataset.collapsed === 'true';
    const autoCollapseLines = parseInt(collapseBtn.dataset.autoCollapseLines) || 30;
    const autoCollapseHeight = parseInt(collapseBtn.dataset.autoCollapseHeight) || 400;
    const collapsedHeight = parseInt(collapseBtn.dataset.collapsedHeight) || 120;

    let isCollapsed = false;

    
    function initCollapse() {
      
      const shouldCollapse = isCollapsedAttr ||
                           defaultState === 'collapsed' ||
                           shouldAutoCollapse();

      if (shouldCollapse) {
        setCollapsed(true, false); 
      }
    }

    function shouldAutoCollapse() {
      
      if (codeElement) {
        const lines = codeElement.querySelectorAll('.line, .cl');
        const height = codeElement.offsetHeight;
        return lines.length > autoCollapseLines || height > autoCollapseHeight;
      }

      
      const containerHeight = codeContainer.offsetHeight;
      if (containerHeight > autoCollapseHeight) {
        return true;
      }

      
      const textContent = codeContainer.textContent || codeContainer.innerText || '';
      const estimatedLines = textContent.split('\n').length;
      return estimatedLines > autoCollapseLines;
    }

    function setCollapsed(collapsed, animate = true) {
      if (!collapseOverlay) return;

      isCollapsed = collapsed;

      if (collapsed) {
        
        codeContainer.style.maxHeight = collapsedHeight + 'px';
        codeContainer.style.overflow = 'hidden';
        collapseOverlay.style.opacity = '1';
        collapseOverlay.style.pointerEvents = 'auto';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M19 9l-7 7-7-7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '펼치기';
        }
        collapseBtn.title = '펼치기';

      } else {
        
        codeContainer.style.maxHeight = '';
        codeContainer.style.overflow = '';
        collapseOverlay.style.opacity = '0';
        collapseOverlay.style.pointerEvents = 'none';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath fill=\u0022currentColor\u0022 d=\u0022M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z\u0022\/\u003e\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '접기';
        }
        collapseBtn.title = '접기';
      }

      
      if (animate) {
        codeContainer.style.transition = 'max-height 0.3s ease-out';
        setTimeout(() => {
          codeContainer.style.transition = '';
        }, 300);
      }
    }

    function toggleCollapse() {
      setCollapsed(!isCollapsed, true);
    }

    
    collapseBtn.addEventListener('click', toggleCollapse);

    
    if (collapseOverlay) {
      collapseOverlay.addEventListener('click', () => {
        if (isCollapsed) {
          setCollapsed(false, true);
        }
      });
    }

    
    initCollapse();
  }
})();
</script>
<ul>
<li><strong>exclude / include</strong> 연산은 <em>Pathways</em> 단일 컨트롤러가 수행 ⇢ slice-수 감소에도 global-batch 사이즈·momentum 유지.</li>
<li>MoE Router는 slice 탈락 시 expert-to-slice 매핑을 재계산하여 <strong>토큰 로드밸런싱</strong>을 즉시 보정.</li>
</ul>
<h3 id="성공의-필수-조건">성공의 필수 조건</h3>
<ul>
<li><strong>장애 빈도 × 시간 손실</strong>을 O(시간)→O(초)로 축소해, <em>총 유효 FLOPs</em>를 극대화.</li>
<li><strong>훈련 PD수율(yield) ↑</strong> → 더 적은 예산으로 더 큰 모델·더 긴 컨텍스트 실험 가능.</li>
<li><strong>MoE 특유의 토큰 불균형</strong>도 slice 단위로 흡수해 <strong>학습 안정성</strong>까지 확보.</li>
</ul>

  <blockquote
    class="border-primary bg-muted/30 hover:bg-muted/40 my-6 rounded-r-lg border-l-4 py-4 pr-4 pl-6 italic transition-all duration-200 ease-out hover:translate-x-1">
    <div class="prose prose-sm max-w-none">
      <p><strong>결국, Slice-Granularity Elasticity는 “1 M 토큰 멀티모달 모델”을 현실로 만든 토대</strong>다. 이 가변 팟 알고리즘이 없었다면, Gemini 2.5의 모든 성능·비용·안전성 지표는 숫자조차 남기지 못했을 것이다.</p>
    </div>
  </blockquote>

<h1 id="프롬프트-141-핵심-결과-분석">프롬프트 1.4.1 (핵심 결과 분석)</h1>
<div
  class="code-block-container border-border bg-card my-6 overflow-hidden rounded-xl border shadow-sm transition-all duration-200 ease-out hover:-translate-y-0.5 hover:shadow-md">
  
  <div
    class="code-block-header bg-muted/30 border-border flex items-center justify-between border-b px-4 py-3">
    
    <div class="flex items-center gap-2">
      <div class="text-muted-foreground flex-shrink-0">
        
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4" />
</svg>
      </div>
      <span class="text-muted-foreground text-sm font-medium">
        PLAINTEXT
      </span>
    </div>

    
    <div class="flex items-center gap-2">
      <button
          class="collapse-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
          data-code-id="code-8"
          data-default-state="expanded"
          data-collapsed="false"
          data-auto-collapse-lines="30"
          data-auto-collapse-height="400"
          data-collapsed-height="120"
          title="접기"
          aria-label="접기">
          <span class="collapse-icon">
            
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path fill="currentColor" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z"/></svg>
          </span>
          <span class="collapse-text hidden sm:inline"
            >접기</span
          >
        </button>
      <button
        class="copy-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
        data-code-id="code-8"
        title="복사"
        aria-label="복사">
        <span class="copy-icon">
          
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
</svg>
        </span>
        <span class="copy-text hidden sm:inline"
          >복사</span
        >
      </button>
    </div>
  </div>

  
  <div class="code-block-content relative" id="code-8">
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">&#34;&#39;Experiments&#39; 또는 &#39;Results&#39; 섹션의 표와 그림을 포함한 주요 결과를 분석해 줘. 사용된 핵심 성능 지표(performance metrics)는 무엇인가? 어떤 벤치마크 데이터셋에서 결과가 보고되었는가? 저자들이 자신들의 방법론의 성공 증거로 가장 강조하는 주요 결과를 요약해 줘.&#34;</span></span></code></pre></div>
    
    <div
      class="collapse-overlay to-card/90 pointer-events-none absolute inset-0 bg-gradient-to-b from-transparent via-transparent opacity-0 transition-opacity duration-300">
      <div
        class="text-muted-foreground bg-card/80 border-border/50 hover:bg-primary/10 hover:text-primary hover:border-primary/30 absolute bottom-4 left-1/2 -translate-x-1/2 cursor-pointer rounded-full border px-3 py-1.5 text-xs backdrop-blur-sm transition-all duration-200">
        클릭하여 더 보기
      </div>
    </div>
  </div>
</div>


<script>
(function() {
  const codeId = 'code-8';
  const copyBtn = document.querySelector('.copy-code-btn[data-code-id="' + codeId + '"]');
  const collapseBtn = document.querySelector('.collapse-code-btn[data-code-id="' + codeId + '"]');
  const codeContainer = document.getElementById(codeId);

  if (!codeContainer) return;

  
  if (copyBtn) {
    const copyIcon = copyBtn.querySelector('.copy-icon');
    const copyText = copyBtn.querySelector('.copy-text');

    copyBtn.addEventListener('click', async function() {
      try {
        
        let codeText = '';

        
        const codeTableCell = codeContainer.querySelector('.lntd:last-child code');
        if (codeTableCell) {
          codeText = codeTableCell.textContent || codeTableCell.innerText;
        } else {
          
          const codeElement = codeContainer.querySelector('code');
          if (codeElement) {
            
            const hasInlineLineNumbers = codeElement.querySelector('.ln');
            if (hasInlineLineNumbers) {
              
              const codeLines = codeElement.querySelectorAll('.cl');
              if (codeLines.length > 0) {
                codeText = Array.from(codeLines)
                  .map(line => {
                    const text = line.textContent || line.innerText;
                    
                    return text.replace(/\n+$/, '');
                  })
                  .join('\n')
                  .replace(/\n+$/, ''); 
              } else {
                
                const allText = codeElement.textContent || codeElement.innerText;
                codeText = allText.replace(/^\d+/gm, '').replace(/^\s+/gm, '');
              }
            } else {
              
              codeText = codeElement.textContent || codeElement.innerText;
            }
          } else {
            
            codeText = codeContainer.textContent || codeContainer.innerText;
          }
        }

        
        codeText = codeText.trim();

        
        await navigator.clipboard.writeText(codeText);

        
        copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M5 13l4 4L19 7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (copyText) {
          copyText.textContent = '복사됨';
        }
        copyBtn.classList.add('text-green-600');

        
        setTimeout(() => {
          copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z\u0022 \/\u003e\n\u003c\/svg\u003e`;
          if (copyText) {
            copyText.textContent = '복사';
          }
          copyBtn.classList.remove('text-green-600');
        }, 2000);

      } catch (err) {
        console.error('复制失败:', err);

        
        const range = document.createRange();
        const codeElement = codeContainer.querySelector('code') || codeContainer;
        range.selectNodeContents(codeElement);
        const selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);

        
        if (copyText) {
          copyText.textContent = '선택됨';
        }

        setTimeout(() => {
          if (copyText) {
            copyText.textContent = '복사';
          }
          selection.removeAllRanges();
        }, 2000);
      }
    });
  }

  
  if (collapseBtn) {
    const collapseIcon = collapseBtn.querySelector('.collapse-icon');
    const collapseText = collapseBtn.querySelector('.collapse-text');
    const collapseOverlay = codeContainer.querySelector('.collapse-overlay');

    
    let codeElement = codeContainer.querySelector('pre.chroma');
    if (!codeElement) {
      codeElement = codeContainer.querySelector('pre');
    }

    const defaultState = collapseBtn.dataset.defaultState || 'expanded';
    const isCollapsedAttr = collapseBtn.dataset.collapsed === 'true';
    const autoCollapseLines = parseInt(collapseBtn.dataset.autoCollapseLines) || 30;
    const autoCollapseHeight = parseInt(collapseBtn.dataset.autoCollapseHeight) || 400;
    const collapsedHeight = parseInt(collapseBtn.dataset.collapsedHeight) || 120;

    let isCollapsed = false;

    
    function initCollapse() {
      
      const shouldCollapse = isCollapsedAttr ||
                           defaultState === 'collapsed' ||
                           shouldAutoCollapse();

      if (shouldCollapse) {
        setCollapsed(true, false); 
      }
    }

    function shouldAutoCollapse() {
      
      if (codeElement) {
        const lines = codeElement.querySelectorAll('.line, .cl');
        const height = codeElement.offsetHeight;
        return lines.length > autoCollapseLines || height > autoCollapseHeight;
      }

      
      const containerHeight = codeContainer.offsetHeight;
      if (containerHeight > autoCollapseHeight) {
        return true;
      }

      
      const textContent = codeContainer.textContent || codeContainer.innerText || '';
      const estimatedLines = textContent.split('\n').length;
      return estimatedLines > autoCollapseLines;
    }

    function setCollapsed(collapsed, animate = true) {
      if (!collapseOverlay) return;

      isCollapsed = collapsed;

      if (collapsed) {
        
        codeContainer.style.maxHeight = collapsedHeight + 'px';
        codeContainer.style.overflow = 'hidden';
        collapseOverlay.style.opacity = '1';
        collapseOverlay.style.pointerEvents = 'auto';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M19 9l-7 7-7-7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '펼치기';
        }
        collapseBtn.title = '펼치기';

      } else {
        
        codeContainer.style.maxHeight = '';
        codeContainer.style.overflow = '';
        collapseOverlay.style.opacity = '0';
        collapseOverlay.style.pointerEvents = 'none';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath fill=\u0022currentColor\u0022 d=\u0022M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z\u0022\/\u003e\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '접기';
        }
        collapseBtn.title = '접기';
      }

      
      if (animate) {
        codeContainer.style.transition = 'max-height 0.3s ease-out';
        setTimeout(() => {
          codeContainer.style.transition = '';
        }, 300);
      }
    }

    function toggleCollapse() {
      setCollapsed(!isCollapsed, true);
    }

    
    collapseBtn.addEventListener('click', toggleCollapse);

    
    if (collapseOverlay) {
      collapseOverlay.addEventListener('click', () => {
        if (isCollapsed) {
          setCollapsed(false, true);
        }
      });
    }

    
    initCollapse();
  }
})();
</script>

  <blockquote
    class="border-primary bg-muted/30 hover:bg-muted/40 my-6 rounded-r-lg border-l-4 py-4 pr-4 pl-6 italic transition-all duration-200 ease-out hover:translate-x-1">
    <div class="prose prose-sm max-w-none">
      <p><strong>결론 한 줄 — Gemini 2.5 Pro는 <em>코딩·수학·롱컨텍스트·멀티모달</em> 네 축의 대표 벤치마크에서 기존 Gemini 1.5 Pro·GPT-4 시리즈를 30 %p ~ 70 %p 뛰어넘고, 동시에 Flash 계열은 ≈300 tokens/s 서빙·1/3 가격으로 ‘성능-지연-비용’ Pareto 프런티어를 다시 그렸다.</strong></p>
    </div>
  </blockquote>

<hr>
<h2 id="1-핵심-성능-지표--벤치마크">1. 핵심 성능 지표 &amp; 벤치마크</h2>
<table>
  <thead>
      <tr>
          <th>카테고리</th>
          <th>대표 지표 (↑ Better)</th>
          <th><strong>Gemini 2.5 Pro</strong></th>
          <th>기존 최고 (비교 모델)</th>
          <th>상대 향상</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>코딩</strong></td>
          <td>LiveCodeBench pass@1</td>
          <td><strong>69.0 %</strong></td>
          <td>29.7 % (Gemini 1.5 Pro)</td>
          <td><strong>+39 %p / 2.3×</strong></td>
      </tr>
      <tr>
          <td><strong>수학·추론</strong></td>
          <td>AIME 2025</td>
          <td><strong>88.0 %</strong></td>
          <td>17.5 % (1.5 Pro)</td>
          <td><strong>+70 %p / 5.0×</strong></td>
      </tr>
      <tr>
          <td><strong>롱-컨텍스트</strong></td>
          <td>LOFT 1 M (hard)</td>
          <td><strong>69.8 %</strong></td>
          <td>47.1 % (1.5 Pro)</td>
          <td><strong>+22 %p / 1.5×</strong></td>
      </tr>
      <tr>
          <td><strong>비디오 이해</strong></td>
          <td>VideoMME (a+v)</td>
          <td><strong>84.3 %</strong></td>
          <td>72.0 % (GPT-4 1.0)</td>
          <td><strong>+12 %p</strong></td>
      </tr>
      <tr>
          <td><strong>토큰/초(지연)</strong></td>
          <td>Output TPS</td>
          <td><strong>≈300 t/s</strong> (2.5 Flash), 120 t/s (2.5 Pro) ― Figure 2</td>
          <td>50 – 70 t/s (Claude 4 Sonnet/Opus)</td>
          <td><strong>4-6 × 빠름</strong></td>
      </tr>
      <tr>
          <td><strong>가격-성능</strong></td>
          <td>LMArena ELO / $</td>
          <td>+120 ELO vs 1.5 Pro, 비용 35 %↓</td>
          <td>—</td>
          <td><strong>S-curve 이동</strong></td>
      </tr>
      <tr>
          <td><strong>학습 안정성</strong></td>
          <td>장애 후 스루풋</td>
          <td><strong>97 % 유지</strong>, 재플레이 0.25 % 스텝</td>
          <td>대부분 모달 정지</td>
          <td><strong>“멈추지 않는” 대규모 학습</strong></td>
      </tr>
  </tbody>
</table>

  <blockquote
    class="border-primary bg-muted/30 hover:bg-muted/40 my-6 rounded-r-lg border-l-4 py-4 pr-4 pl-6 italic transition-all duration-200 ease-out hover:translate-x-1">
    <div class="prose prose-sm max-w-none">
      <p><em>모든 수치는 논문 Table 3–6 &amp; Figure 1–4에 보고된 공식 값 (0-shot 또는 pass@1 단일 시도) 기준.</em></p>
    </div>
  </blockquote>

<hr>
<h2 id="2-사용된-주요-벤치마크--메트릭">2. 사용된 주요 벤치마크 &amp; 메트릭</h2>
<table>
  <thead>
      <tr>
          <th>영역</th>
          <th>데이터셋</th>
          <th>메트릭</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>코딩</strong></td>
          <td>LiveCodeBench, Aider Polyglot, SWE-bench Verified</td>
          <td>pass@1 (single / multiple)</td>
      </tr>
      <tr>
          <td><strong>수학·추론</strong></td>
          <td>AIME 2025, GPQA (diamond), Humanity’s Last Exam</td>
          <td>accuracy / pass@1</td>
      </tr>
      <tr>
          <td><strong>롱컨텍스트 검색</strong></td>
          <td>LOFT, MRCR-V2 (≤128 K, 1 M)</td>
          <td>exact-match accuracy</td>
      </tr>
      <tr>
          <td><strong>멀티모달</strong></td>
          <td>VideoMME, LVBench, ActivityNet-QA 등 (영상+음성)</td>
          <td>string-match, CIDEr, R@1@0.5 등</td>
      </tr>
      <tr>
          <td><strong>오디오</strong></td>
          <td>FLEURS (WER↓), CoVoST2 (BLEU↑)</td>
          <td>word-error-rate, BLEU</td>
      </tr>
      <tr>
          <td><strong>서비스 효율</strong></td>
          <td>Figure 2 ‘Output TPS’</td>
          <td>tokens per second</td>
      </tr>
  </tbody>
</table>
<hr>
<h2 id="3-저자들이-강조한-성공-증거-세-갈래">3. 저자들이 강조한 “성공 증거” 세 갈래</h2>
<ol>
<li>
<p><strong>질적 도약</strong>
<em>코딩·수학·과학</em> 10개 이상 챌린지에서 <strong>최초로 60 %+ 벽을 넘어섰다</strong> (LiveCodeBench 69 %, AIME 88 %, GPQA 86 %) .</p>
</li>
<li>
<p><strong>롱컨텍스트 &amp; 멀티모달 SOTA</strong>
1 M-token **LOFT 69.8 %**로 유일하게 ‘소설 한 권 크기’ 입력에서 정답률 &gt; 65 % 기록, 3 h 비디오 QA(Benchmark: VideoMME)도 <strong>+9 %p</strong> GPT-4 대비 � Beled .</p>
</li>
<li>
<p><strong>실제 배포 효율</strong>
Flash 변형이 <strong>≈300 tokens/s</strong> &ndash; Anthropic Claude 4 Sonnet 대비 4× 빠르면서, 가격은 <strong>평균 35 % 절감</strong>해 “고품질 ↔ 저지연” 양립을 입증 (Figure 1 &amp; 2) .</p>
</li>
</ol>
<hr>
<h3 id="4-왜-중요한가">4. 왜 중요한가?</h3>
<ul>
<li><strong>연구적 의미</strong>: Sparse-MoE + 1 M RoPE 확장의 성능 잠재력을, 엄격한 벤치마크 숫자로 최초 실증.</li>
<li><strong>산업적 의미</strong>: <em>동급 최고 품질</em> 모델을 <strong>모바일·리얼타임 API</strong> 수준 지연과 비용으로 제공 가능함을 보여, LLM 응용 범위를 대폭 확장.</li>
<li><strong>학습 인프라</strong>: Slice-Elastic TPU 기법으로 “수 천 칩 규모 훈련의 단일 실패점” 문제를 사실상 해결, 차세대 10 K+ TPU 시대 로드맵 제시 .</li>
</ul>
<hr>
<h3 id="5-한-눈-요약-블로그용-인용구">5. 한-눈-요약 (블로그용 인용구)</h3>

  <blockquote
    class="border-primary bg-muted/30 hover:bg-muted/40 my-6 rounded-r-lg border-l-4 py-4 pr-4 pl-6 italic transition-all duration-200 ease-out hover:translate-x-1">
    <div class="prose prose-sm max-w-none">
      <p><em>“Gemini 2.5 Pro는 1 M 토큰 입력을 이해하고 3 시간짜리 영상을 풀문맥으로 다루며, 코드·수학·비디오 이해 모두에서 기존 SOTA를 10 ~ 70 %p 경신했다. Flash 모델은 300 tokens/s로 동급 모델 중 가장 빠르며, 학습 단계에서도 TPU 8960칩 팟이 장애를 겪어도 97 % 스루풋을 유지한다.”</em></p>
    </div>
  </blockquote>

<hr>
<h1 id="프롬프트-142-비판적-비교">프롬프트 1.4.2 (비판적 비교)</h1>
<div
  class="code-block-container border-border bg-card my-6 overflow-hidden rounded-xl border shadow-sm transition-all duration-200 ease-out hover:-translate-y-0.5 hover:shadow-md">
  
  <div
    class="code-block-header bg-muted/30 border-border flex items-center justify-between border-b px-4 py-3">
    
    <div class="flex items-center gap-2">
      <div class="text-muted-foreground flex-shrink-0">
        
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4" />
</svg>
      </div>
      <span class="text-muted-foreground text-sm font-medium">
        PLAINTEXT
      </span>
    </div>

    
    <div class="flex items-center gap-2">
      <button
          class="collapse-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
          data-code-id="code-9"
          data-default-state="expanded"
          data-collapsed="false"
          data-auto-collapse-lines="30"
          data-auto-collapse-height="400"
          data-collapsed-height="120"
          title="접기"
          aria-label="접기">
          <span class="collapse-icon">
            
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path fill="currentColor" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z"/></svg>
          </span>
          <span class="collapse-text hidden sm:inline"
            >접기</span
          >
        </button>
      <button
        class="copy-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
        data-code-id="code-9"
        title="복사"
        aria-label="복사">
        <span class="copy-icon">
          
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
</svg>
        </span>
        <span class="copy-text hidden sm:inline"
          >복사</span
        >
      </button>
    </div>
  </div>

  
  <div class="code-block-content relative" id="code-9">
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">&#34;제안된 방법론은 논문에서 언급된 주요 베이스라인 및 SOTA(State-of-the-Art) 모델들과 비교하여 어떤 성능을 보이는가? 저자들의 우월성 주장을 가장 강력하게 뒷받침하는 특정 결과나 비교 지점을 식별해 줘. 반대로, 제안된 방법론이 경쟁 모델을 능가하지 못했거나 개선 효과가 미미했던 결과는 없는지 찾아봐. 만약 있다면, 저자들은 이러한 경우에 대해 어떤 이유를 제시하는가?&#34;</span></span></code></pre></div>
    
    <div
      class="collapse-overlay to-card/90 pointer-events-none absolute inset-0 bg-gradient-to-b from-transparent via-transparent opacity-0 transition-opacity duration-300">
      <div
        class="text-muted-foreground bg-card/80 border-border/50 hover:bg-primary/10 hover:text-primary hover:border-primary/30 absolute bottom-4 left-1/2 -translate-x-1/2 cursor-pointer rounded-full border px-3 py-1.5 text-xs backdrop-blur-sm transition-all duration-200">
        클릭하여 더 보기
      </div>
    </div>
  </div>
</div>


<script>
(function() {
  const codeId = 'code-9';
  const copyBtn = document.querySelector('.copy-code-btn[data-code-id="' + codeId + '"]');
  const collapseBtn = document.querySelector('.collapse-code-btn[data-code-id="' + codeId + '"]');
  const codeContainer = document.getElementById(codeId);

  if (!codeContainer) return;

  
  if (copyBtn) {
    const copyIcon = copyBtn.querySelector('.copy-icon');
    const copyText = copyBtn.querySelector('.copy-text');

    copyBtn.addEventListener('click', async function() {
      try {
        
        let codeText = '';

        
        const codeTableCell = codeContainer.querySelector('.lntd:last-child code');
        if (codeTableCell) {
          codeText = codeTableCell.textContent || codeTableCell.innerText;
        } else {
          
          const codeElement = codeContainer.querySelector('code');
          if (codeElement) {
            
            const hasInlineLineNumbers = codeElement.querySelector('.ln');
            if (hasInlineLineNumbers) {
              
              const codeLines = codeElement.querySelectorAll('.cl');
              if (codeLines.length > 0) {
                codeText = Array.from(codeLines)
                  .map(line => {
                    const text = line.textContent || line.innerText;
                    
                    return text.replace(/\n+$/, '');
                  })
                  .join('\n')
                  .replace(/\n+$/, ''); 
              } else {
                
                const allText = codeElement.textContent || codeElement.innerText;
                codeText = allText.replace(/^\d+/gm, '').replace(/^\s+/gm, '');
              }
            } else {
              
              codeText = codeElement.textContent || codeElement.innerText;
            }
          } else {
            
            codeText = codeContainer.textContent || codeContainer.innerText;
          }
        }

        
        codeText = codeText.trim();

        
        await navigator.clipboard.writeText(codeText);

        
        copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M5 13l4 4L19 7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (copyText) {
          copyText.textContent = '복사됨';
        }
        copyBtn.classList.add('text-green-600');

        
        setTimeout(() => {
          copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z\u0022 \/\u003e\n\u003c\/svg\u003e`;
          if (copyText) {
            copyText.textContent = '복사';
          }
          copyBtn.classList.remove('text-green-600');
        }, 2000);

      } catch (err) {
        console.error('复制失败:', err);

        
        const range = document.createRange();
        const codeElement = codeContainer.querySelector('code') || codeContainer;
        range.selectNodeContents(codeElement);
        const selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);

        
        if (copyText) {
          copyText.textContent = '선택됨';
        }

        setTimeout(() => {
          if (copyText) {
            copyText.textContent = '복사';
          }
          selection.removeAllRanges();
        }, 2000);
      }
    });
  }

  
  if (collapseBtn) {
    const collapseIcon = collapseBtn.querySelector('.collapse-icon');
    const collapseText = collapseBtn.querySelector('.collapse-text');
    const collapseOverlay = codeContainer.querySelector('.collapse-overlay');

    
    let codeElement = codeContainer.querySelector('pre.chroma');
    if (!codeElement) {
      codeElement = codeContainer.querySelector('pre');
    }

    const defaultState = collapseBtn.dataset.defaultState || 'expanded';
    const isCollapsedAttr = collapseBtn.dataset.collapsed === 'true';
    const autoCollapseLines = parseInt(collapseBtn.dataset.autoCollapseLines) || 30;
    const autoCollapseHeight = parseInt(collapseBtn.dataset.autoCollapseHeight) || 400;
    const collapsedHeight = parseInt(collapseBtn.dataset.collapsedHeight) || 120;

    let isCollapsed = false;

    
    function initCollapse() {
      
      const shouldCollapse = isCollapsedAttr ||
                           defaultState === 'collapsed' ||
                           shouldAutoCollapse();

      if (shouldCollapse) {
        setCollapsed(true, false); 
      }
    }

    function shouldAutoCollapse() {
      
      if (codeElement) {
        const lines = codeElement.querySelectorAll('.line, .cl');
        const height = codeElement.offsetHeight;
        return lines.length > autoCollapseLines || height > autoCollapseHeight;
      }

      
      const containerHeight = codeContainer.offsetHeight;
      if (containerHeight > autoCollapseHeight) {
        return true;
      }

      
      const textContent = codeContainer.textContent || codeContainer.innerText || '';
      const estimatedLines = textContent.split('\n').length;
      return estimatedLines > autoCollapseLines;
    }

    function setCollapsed(collapsed, animate = true) {
      if (!collapseOverlay) return;

      isCollapsed = collapsed;

      if (collapsed) {
        
        codeContainer.style.maxHeight = collapsedHeight + 'px';
        codeContainer.style.overflow = 'hidden';
        collapseOverlay.style.opacity = '1';
        collapseOverlay.style.pointerEvents = 'auto';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M19 9l-7 7-7-7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '펼치기';
        }
        collapseBtn.title = '펼치기';

      } else {
        
        codeContainer.style.maxHeight = '';
        codeContainer.style.overflow = '';
        collapseOverlay.style.opacity = '0';
        collapseOverlay.style.pointerEvents = 'none';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath fill=\u0022currentColor\u0022 d=\u0022M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z\u0022\/\u003e\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '접기';
        }
        collapseBtn.title = '접기';
      }

      
      if (animate) {
        codeContainer.style.transition = 'max-height 0.3s ease-out';
        setTimeout(() => {
          codeContainer.style.transition = '';
        }, 300);
      }
    }

    function toggleCollapse() {
      setCollapsed(!isCollapsed, true);
    }

    
    collapseBtn.addEventListener('click', toggleCollapse);

    
    if (collapseOverlay) {
      collapseOverlay.addEventListener('click', () => {
        if (isCollapsed) {
          setCollapsed(false, true);
        }
      });
    }

    
    initCollapse();
  }
})();
</script>
<h2 id="한눈에-보는-결론">한눈에 보는 결론</h2>
<p><strong>Gemini 2.5 Pro/Flash 는 대부분의 핵심 벤치마크(코딩·수학·1 M 롱컨텍스트·멀티모달 비디오)에서 기존 Gemini 1.5 Pro·GPT-4/Claude 등 주요 SOTA를 10 ~ 70 %p 앞섰다.</strong>
가장 큰 격차는 <strong>LiveCodeBench (+39 %p)</strong>, <strong>AIME (+70 %p)</strong>, <strong>VideoMME (+12 %p)</strong>, **LOFT 1 M (+22 %p)**이며, Flash 모델은 <strong>≈ 300 tokens/s</strong>로 동급 최고 속도를 기록했다.
하지만 <strong>MRCR-V2 (1 M)</strong>·<strong>AIME 일부 설정</strong>처럼 개선 폭이 작거나 오히려 밀린 항목도 존재하며, 저자들은 <em>“평가가 더 어려워졌거나(8-needle MRCR-V2), retrieval · chain-of-thought 파이프라인이 아직 미흡”</em> 이라고 설명한다.</p>
<hr>
<h2 id="1-대표-수치-비교--베이스라인-vs-gemini-25-pro">1. 대표 수치 비교 — 베이스라인 vs Gemini 2.5 Pro</h2>
<table>
  <thead>
      <tr>
          <th>영역·지표 (↑)</th>
          <th>Gemini 2.5 Pro</th>
          <th>최고 이전 모델</th>
          <th>격차</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>LiveCodeBench pass@1</strong></td>
          <td><strong>69.0 %</strong></td>
          <td>29.7 % (1.5 Pro)</td>
          <td><strong>+39 %p / 2.3×</strong></td>
      </tr>
      <tr>
          <td><strong>AIME 2025</strong></td>
          <td><strong>88.0 %</strong></td>
          <td>17.5 % (1.5 Pro)</td>
          <td><strong>+70 %p / 5×</strong></td>
      </tr>
      <tr>
          <td><strong>LOFT 1 M (hard)</strong></td>
          <td><strong>69.8 %</strong></td>
          <td>47.1 % (1.5 Pro)</td>
          <td><strong>+22 %p</strong></td>
      </tr>
      <tr>
          <td><strong>VideoMME (A+V)</strong></td>
          <td><strong>84.3 %</strong></td>
          <td>72.0 % (GPT-4 1.0)</td>
          <td><strong>+12 %p</strong></td>
      </tr>
      <tr>
          <td><strong>토큰/초 (Flash)</strong></td>
          <td><strong>≈ 300 t/s</strong></td>
          <td>180 t/s (o4-mini), 70 t/s (Claude-Sonnet)</td>
          <td><strong>1.7 ~ 4× 빠름</strong></td>
      </tr>
  </tbody>
</table>
<hr>
<h2 id="2-저자들이-강조하는-우월성-증거">2. 저자들이 강조하는 ‘우월성’ 증거</h2>
<ol>
<li>
<p><strong>대규모 코드·수학 벤치마크 압도</strong></p>
<ul>
<li>LiveCodeBench 69 %·Aider Polyglot 82 %·AIME 88 % 등에서 1.5 Pro·GPT-4 계열을 두 자리 수 차이로 추월.</li>
</ul>
</li>
<li>
<p><strong>1 M 토큰 전역 이해 실증</strong></p>
<ul>
<li>LOFT 1 M 69.8 %로 최초로 ‘소설 한 권’급 입력을 65 %+ 정확도로 처리.</li>
</ul>
</li>
<li>
<p><strong>멀티모달 비디오 SOTA</strong></p>
<ul>
<li>VideoMME 84.3 %·1 h-VideoQA 81 %로 GPT-4 72 % 대비 +12 %p 이상.</li>
</ul>
</li>
<li>
<p><strong>실시간 API 효율</strong></p>
<ul>
<li>Flash 변형이 300 t/s, 가격 평균 35 %↓로 비용-지연 Pareto 곡선을 재정의.</li>
</ul>
</li>
</ol>
<hr>
<h2 id="3-우위가-크지-않거나-밀린-포인트">3. <strong>우위가 크지 않거나 밀린 포인트</strong></h2>
<table>
  <thead>
      <tr>
          <th>지표</th>
          <th>2.5 Pro</th>
          <th>경쟁 모델</th>
          <th>관찰</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>MRCR-V2 1 M</strong></td>
          <td>16.4 %</td>
          <td>21.0 % (2.0 Flash)</td>
          <td><strong>3 %p↓</strong></td>
      </tr>
      <tr>
          <td><strong>AIME 2025 (DeepSeek R1 설정)</strong></td>
          <td>88.0 %</td>
          <td>92.7 % (DeepSeek R1)</td>
          <td><strong>-4.7 %p</strong></td>
      </tr>
      <tr>
          <td><strong>MRCR-V2 ≤128 K</strong></td>
          <td>58.0 % vs 58.1 % (1.5 Pro)</td>
          <td>차이 미미</td>
          <td></td>
      </tr>
  </tbody>
</table>
<p><strong>저자 해석</strong></p>
<ul>
<li><strong>MRCR-V2</strong>: 기존 4-needle → 8-needle로 난이도를 크게 높였고, “retrieval 힌트 없는 딕셔너리-스타일 문제라 context-compression 한계 노출”이라고 언급.</li>
<li><strong>AIME 근소 열세</strong>: “단일-샘플·no-thinking 설정”에서 self-consistency를 돌린 타 모델이 유리, deep-think variant로는 격차가 줄어든다”는 부연이 있다.</li>
</ul>
<hr>
<h2 id="4-핵심-인사이트">4. 핵심 인사이트</h2>
<ul>
<li><strong>가장 설득력 있는 승리 지점</strong>은 <strong>코딩(LiveCodeBench 69 %) &amp; 비디오(VideoMME 84 %)</strong> – 구조적으로 어려운 멀티단계·멀티모달 문제에서 큰 폭으로 앞섰다.</li>
<li><strong>약점</strong>은 <strong>복잡한 key-value 검색(MRCR-V2)</strong> 및 일부 <strong>경쟁사가 과도한 test-time voting을 쓴 수학 벤치마크</strong>. 이는 ‘retrieval 강건성’·‘thinking 예산’ 조정이 향후 과제임을 시사.</li>
<li>전반적으로 <strong>“성능·지연·비용” 3축 동시에 SOTA</strong>를 달성하지만, <strong>특정 long-retrieval</strong>과 <strong>상위권 수학 문제</strong>에서는 아직 추가 연구 여지가 남아 있다.</li>
</ul>
<hr>

  <blockquote
    class="border-primary bg-muted/30 hover:bg-muted/40 my-6 rounded-r-lg border-l-4 py-4 pr-4 pl-6 italic transition-all duration-200 ease-out hover:translate-x-1">
    <div class="prose prose-sm max-w-none">
      <p><em>블로그용 요약</em>: “Gemini 2.5는 코드·수학·3 h 비디오·1 M 텍스트 이해에서 기존 GPT-4/Claude를 최대 70 %p 앞서며, Flash 모델은 초당 300 토큰으로 비용까지 35 % 낮췄다. 다만 8-needle MRCR-V2처럼 검색 난이도가 극단적인 과제나 일부 수학 벤치마크에선 여전히 도전 과제가 남는다.”</p>
    </div>
  </blockquote>

<h1 id="프롬프트-151-언급된-한계와-잠재적-한계">프롬프트 1.5.1 (언급된 한계와 잠재적 한계)</h1>
<div
  class="code-block-container border-border bg-card my-6 overflow-hidden rounded-xl border shadow-sm transition-all duration-200 ease-out hover:-translate-y-0.5 hover:shadow-md">
  
  <div
    class="code-block-header bg-muted/30 border-border flex items-center justify-between border-b px-4 py-3">
    
    <div class="flex items-center gap-2">
      <div class="text-muted-foreground flex-shrink-0">
        
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4" />
</svg>
      </div>
      <span class="text-muted-foreground text-sm font-medium">
        PLAINTEXT
      </span>
    </div>

    
    <div class="flex items-center gap-2">
      <button
          class="collapse-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
          data-code-id="code-10"
          data-default-state="expanded"
          data-collapsed="false"
          data-auto-collapse-lines="30"
          data-auto-collapse-height="400"
          data-collapsed-height="120"
          title="접기"
          aria-label="접기">
          <span class="collapse-icon">
            
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path fill="currentColor" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z"/></svg>
          </span>
          <span class="collapse-text hidden sm:inline"
            >접기</span
          >
        </button>
      <button
        class="copy-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
        data-code-id="code-10"
        title="복사"
        aria-label="복사">
        <span class="copy-icon">
          
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
</svg>
        </span>
        <span class="copy-text hidden sm:inline"
          >복사</span
        >
      </button>
    </div>
  </div>

  
  <div class="code-block-content relative" id="code-10">
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">&#34;저자들이 논문에서 명시적으로 인정한 한계점, 약점, 또는 실패 사례(failure modes)는 무엇인가? 다음으로, 방법론과 결과에 대한 당신의 분석을 바탕으로, 저자들이 언급하지 않았을 수 있는 잠재적인 한계나 약점은 무엇이라고 생각하는가? (예: 강력한 가정에 대한 의존성, 확장성 문제, 높은 연산 비용, 일반화의 한계, 잠재적인 부정적 사회 영향 등)&#34;</span></span></code></pre></div>
    
    <div
      class="collapse-overlay to-card/90 pointer-events-none absolute inset-0 bg-gradient-to-b from-transparent via-transparent opacity-0 transition-opacity duration-300">
      <div
        class="text-muted-foreground bg-card/80 border-border/50 hover:bg-primary/10 hover:text-primary hover:border-primary/30 absolute bottom-4 left-1/2 -translate-x-1/2 cursor-pointer rounded-full border px-3 py-1.5 text-xs backdrop-blur-sm transition-all duration-200">
        클릭하여 더 보기
      </div>
    </div>
  </div>
</div>


<script>
(function() {
  const codeId = 'code-10';
  const copyBtn = document.querySelector('.copy-code-btn[data-code-id="' + codeId + '"]');
  const collapseBtn = document.querySelector('.collapse-code-btn[data-code-id="' + codeId + '"]');
  const codeContainer = document.getElementById(codeId);

  if (!codeContainer) return;

  
  if (copyBtn) {
    const copyIcon = copyBtn.querySelector('.copy-icon');
    const copyText = copyBtn.querySelector('.copy-text');

    copyBtn.addEventListener('click', async function() {
      try {
        
        let codeText = '';

        
        const codeTableCell = codeContainer.querySelector('.lntd:last-child code');
        if (codeTableCell) {
          codeText = codeTableCell.textContent || codeTableCell.innerText;
        } else {
          
          const codeElement = codeContainer.querySelector('code');
          if (codeElement) {
            
            const hasInlineLineNumbers = codeElement.querySelector('.ln');
            if (hasInlineLineNumbers) {
              
              const codeLines = codeElement.querySelectorAll('.cl');
              if (codeLines.length > 0) {
                codeText = Array.from(codeLines)
                  .map(line => {
                    const text = line.textContent || line.innerText;
                    
                    return text.replace(/\n+$/, '');
                  })
                  .join('\n')
                  .replace(/\n+$/, ''); 
              } else {
                
                const allText = codeElement.textContent || codeElement.innerText;
                codeText = allText.replace(/^\d+/gm, '').replace(/^\s+/gm, '');
              }
            } else {
              
              codeText = codeElement.textContent || codeElement.innerText;
            }
          } else {
            
            codeText = codeContainer.textContent || codeContainer.innerText;
          }
        }

        
        codeText = codeText.trim();

        
        await navigator.clipboard.writeText(codeText);

        
        copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M5 13l4 4L19 7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (copyText) {
          copyText.textContent = '복사됨';
        }
        copyBtn.classList.add('text-green-600');

        
        setTimeout(() => {
          copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z\u0022 \/\u003e\n\u003c\/svg\u003e`;
          if (copyText) {
            copyText.textContent = '복사';
          }
          copyBtn.classList.remove('text-green-600');
        }, 2000);

      } catch (err) {
        console.error('复制失败:', err);

        
        const range = document.createRange();
        const codeElement = codeContainer.querySelector('code') || codeContainer;
        range.selectNodeContents(codeElement);
        const selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);

        
        if (copyText) {
          copyText.textContent = '선택됨';
        }

        setTimeout(() => {
          if (copyText) {
            copyText.textContent = '복사';
          }
          selection.removeAllRanges();
        }, 2000);
      }
    });
  }

  
  if (collapseBtn) {
    const collapseIcon = collapseBtn.querySelector('.collapse-icon');
    const collapseText = collapseBtn.querySelector('.collapse-text');
    const collapseOverlay = codeContainer.querySelector('.collapse-overlay');

    
    let codeElement = codeContainer.querySelector('pre.chroma');
    if (!codeElement) {
      codeElement = codeContainer.querySelector('pre');
    }

    const defaultState = collapseBtn.dataset.defaultState || 'expanded';
    const isCollapsedAttr = collapseBtn.dataset.collapsed === 'true';
    const autoCollapseLines = parseInt(collapseBtn.dataset.autoCollapseLines) || 30;
    const autoCollapseHeight = parseInt(collapseBtn.dataset.autoCollapseHeight) || 400;
    const collapsedHeight = parseInt(collapseBtn.dataset.collapsedHeight) || 120;

    let isCollapsed = false;

    
    function initCollapse() {
      
      const shouldCollapse = isCollapsedAttr ||
                           defaultState === 'collapsed' ||
                           shouldAutoCollapse();

      if (shouldCollapse) {
        setCollapsed(true, false); 
      }
    }

    function shouldAutoCollapse() {
      
      if (codeElement) {
        const lines = codeElement.querySelectorAll('.line, .cl');
        const height = codeElement.offsetHeight;
        return lines.length > autoCollapseLines || height > autoCollapseHeight;
      }

      
      const containerHeight = codeContainer.offsetHeight;
      if (containerHeight > autoCollapseHeight) {
        return true;
      }

      
      const textContent = codeContainer.textContent || codeContainer.innerText || '';
      const estimatedLines = textContent.split('\n').length;
      return estimatedLines > autoCollapseLines;
    }

    function setCollapsed(collapsed, animate = true) {
      if (!collapseOverlay) return;

      isCollapsed = collapsed;

      if (collapsed) {
        
        codeContainer.style.maxHeight = collapsedHeight + 'px';
        codeContainer.style.overflow = 'hidden';
        collapseOverlay.style.opacity = '1';
        collapseOverlay.style.pointerEvents = 'auto';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M19 9l-7 7-7-7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '펼치기';
        }
        collapseBtn.title = '펼치기';

      } else {
        
        codeContainer.style.maxHeight = '';
        codeContainer.style.overflow = '';
        collapseOverlay.style.opacity = '0';
        collapseOverlay.style.pointerEvents = 'none';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath fill=\u0022currentColor\u0022 d=\u0022M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z\u0022\/\u003e\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '접기';
        }
        collapseBtn.title = '접기';
      }

      
      if (animate) {
        codeContainer.style.transition = 'max-height 0.3s ease-out';
        setTimeout(() => {
          codeContainer.style.transition = '';
        }, 300);
      }
    }

    function toggleCollapse() {
      setCollapsed(!isCollapsed, true);
    }

    
    collapseBtn.addEventListener('click', toggleCollapse);

    
    if (collapseOverlay) {
      collapseOverlay.addEventListener('click', () => {
        if (isCollapsed) {
          setCollapsed(false, true);
        }
      });
    }

    
    initCollapse();
  }
})();
</script>
<h3 id="tldr--한눈결론">TL;DR – 한눈결론</h3>
<ul>
<li><strong>저자가 인정:</strong> 모델은 _특정 retrieval·보안·안전 영역_에서 아직 SOTA를 못 넘었고, Frontier-Safety-Framework(CCL) 기준 “위험 단계”에도 미달했다.</li>
<li><strong>내가 추가로 보는 한계:</strong> ① <strong>막대한 연산비용 &amp; TPU-v5p 종속성</strong>, ② <strong>복잡 retrieval 의존 → MRCR-V2 1 M 16 %</strong> 같은 실패, ③ <strong>데이터 컷오프(’25-01)·멀티모달 평가 공백</strong>, ④ <strong>사회적 악용 가능성(사이버·바이오 능력 상승세)</strong>, ⑤ <strong>프라이빗 인프라로 재현-검증 난이도</strong>.</li>
</ul>
<hr>
<h2 id="1-저자들이-직접-인정한-한계실패-사례">1. 저자들이 <em>직접</em> 인정한 한계·실패 사례</h2>
<table>
  <thead>
      <tr>
          <th>카테고리</th>
          <th>관측치</th>
          <th>설명</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>장기 Retrieval</strong></td>
          <td>MRCR-V2 1 M 정답률 <strong>16.4 %</strong> – 1.5 Pro보다 소폭 ↑/↓ ｜저자: “8-needle로 난이도가 급상승, _retrieval·chain-of-thought 파이프라인_이 아직 미흡”</td>
          <td></td>
      </tr>
      <tr>
          <td><strong>사이버 보안</strong></td>
          <td>Hack-the-Box CTF <strong>0 % 솔브</strong> (모델 전원)</td>
          <td>InterCode-CTF는 포화, HTB는 “아직 너무 어려움”</td>
      </tr>
      <tr>
          <td><strong>FSF 위험레벨</strong></td>
          <td>Frontier-Safety CCL <strong>미달</strong> 전 영역 – 특히 CBRN·Cyber Uplift 1 “경고 임계치 근접”만 표기</td>
          <td></td>
      </tr>
      <tr>
          <td><strong>AIME 일부 설정</strong></td>
          <td>DeepSeek R1 &gt; Gemini 2.5 Pro (92.7 % vs 88 %) – 저자: “self-consistency 투표 차이”</td>
          <td></td>
      </tr>
      <tr>
          <td><strong>Inference 최적화</strong></td>
          <td>Hydragen은 <strong>사용자가 prefix 위치를 지정</strong>해야 하며 “<em>E2E 서빙 솔루션은 아님</em>”</td>
          <td></td>
      </tr>
  </tbody>
</table>
<hr>
<h2 id="2-추가로-분석-제시하는-잠재적-한계">2. 추가로 분석-제시하는 잠재적 한계</h2>
<table>
  <thead>
      <tr>
          <th>영역</th>
          <th>잠재 리스크 · 제약</th>
          <th>근거/추론</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>연산 비용·재현성</strong></td>
          <td>8960-chip TPU v5p 팟 <strong>여러 개</strong> 동원, Slice-Elasticity로도 <strong>97 %</strong> throughput 유지  → 학계·산업 다수에게는 <strong>비현실적 자원</strong></td>
          <td></td>
      </tr>
      <tr>
          <td><strong>하드웨어 종속</strong></td>
          <td>Pathways “싱글 컨트롤러” 설계에 강하게 묶여 있어, GPU 클러스터나 다른 TPU 세대에 <strong>직접 이식 난이도</strong> ↑</td>
          <td></td>
      </tr>
      <tr>
          <td><strong>Eco-impact / 비용</strong></td>
          <td>TPUv5p 10 EFLOP+ 학습 → 전력·탄소 발자국 공개 X (보고서에 계산 부재)</td>
          <td></td>
      </tr>
      <tr>
          <td><strong>데이터·일반화</strong></td>
          <td>Pre-train 컷오프 <strong>2025-01</strong> &amp; 내부 데이터셋 다수; 공개 벤치마크 외 <strong>실세계 도메인 편향</strong> 가능성</td>
          <td></td>
      </tr>
      <tr>
          <td><strong>멀티모달 공백</strong></td>
          <td>3 h 비디오까지는 검증됐지만 <strong>정밀 오디오 합성·3D·로봇제어</strong> 등은 실험 부재 – <em>out-of-distribution</em> 위험</td>
          <td></td>
      </tr>
      <tr>
          <td><strong>사회적 악용 창구</strong></td>
          <td>바이오·사이버 능력 “아직 CCL 미달”이지만 성장 속도 확인, <strong>자동화 공격 파이프라인</strong>에 악용될 가능성 (저자도 “경고 임계치 근접” 언급)</td>
          <td></td>
      </tr>
      <tr>
          <td><strong>Retrieval 의존성</strong></td>
          <td>1 M 컨텍스트라도 <em>needle-in-haystack</em> 검색 성능이 낮아, 실서비스에선 외부 RAG·DB 추가가 필수 → 시스템 복잡도 증가</td>
          <td></td>
      </tr>
  </tbody>
</table>
<hr>
<h2 id="3-블로그용-한-줄-요약">3. 블로그용 한-줄 요약</h2>

  <blockquote
    class="border-primary bg-muted/30 hover:bg-muted/40 my-6 rounded-r-lg border-l-4 py-4 pr-4 pl-6 italic transition-all duration-200 ease-out hover:translate-x-1">
    <div class="prose prose-sm max-w-none">
      <p><em>“Gemini 2.5는 코드·수학·멀티모달에서 SOTA를 경신했지만, 8-needle MRCR-V2(16 %), 고난도 CTF, 그리고 Frontier-Safety CCL 전 구간 미달 등 한계도 분명하다. 무엇보다 ‘TPU v5p × 8960 chips’라는 초대형 인프라 없이는 동일한 결과를 재현하기 어렵다는 점을 기억해야 한다.”</em></p>
    </div>
  </blockquote>

<hr>
<h3 id="참고-한계-분석-체크리스트">참고: 한계 분석 체크리스트</h3>
<ul>
<li><strong>수치 기반 실패 지점</strong> → MRCR-V2, HTB CTF, AIME-R1</li>
<li><strong>비용/환경</strong> → TPUv5p, 전력·탄소 미공개</li>
<li><strong>안전</strong> → FSF CCL 미달이지만 상승세 경계</li>
<li><strong>기술적 제약</strong> → Hydragen 수동 prefix 지정, Pathways 종속</li>
<li><strong>일반화</strong> → 데이터 컷오프·도메인 편향, 신규 멀티모달 태스크 미검증</li>
</ul>

  <blockquote
    class="border-primary bg-muted/30 hover:bg-muted/40 my-6 rounded-r-lg border-l-4 py-4 pr-4 pl-6 italic transition-all duration-200 ease-out hover:translate-x-1">
    <div class="prose prose-sm max-w-none">
      <p>이 표를 블로그 “Discussion &amp; Limitations” 섹션에 그대로 삽입하면, 독자에게 <strong>저자 인정 vs. 잠재 리스크</strong>를 명확히 대비시켜 줄 수 있다.</p>
    </div>
  </blockquote>

<h1 id="프롬프트-152-미래-연구-궤적">프롬프트 1.5.2 (미래 연구 궤적)</h1>
<div
  class="code-block-container border-border bg-card my-6 overflow-hidden rounded-xl border shadow-sm transition-all duration-200 ease-out hover:-translate-y-0.5 hover:shadow-md">
  
  <div
    class="code-block-header bg-muted/30 border-border flex items-center justify-between border-b px-4 py-3">
    
    <div class="flex items-center gap-2">
      <div class="text-muted-foreground flex-shrink-0">
        
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4" />
</svg>
      </div>
      <span class="text-muted-foreground text-sm font-medium">
        PLAINTEXT
      </span>
    </div>

    
    <div class="flex items-center gap-2">
      <button
          class="collapse-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
          data-code-id="code-11"
          data-default-state="expanded"
          data-collapsed="false"
          data-auto-collapse-lines="30"
          data-auto-collapse-height="400"
          data-collapsed-height="120"
          title="접기"
          aria-label="접기">
          <span class="collapse-icon">
            
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path fill="currentColor" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z"/></svg>
          </span>
          <span class="collapse-text hidden sm:inline"
            >접기</span
          >
        </button>
      <button
        class="copy-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
        data-code-id="code-11"
        title="복사"
        aria-label="복사">
        <span class="copy-icon">
          
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
</svg>
        </span>
        <span class="copy-text hidden sm:inline"
          >복사</span
        >
      </button>
    </div>
  </div>

  
  <div class="code-block-content relative" id="code-11">
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">&#34;저자들이 제안하는 구체적인 향후 연구 방향은 무엇인가? 이 논문의 한계점을 바탕으로, 이 연구를 발전시키거나 약점을 극복하기 위해 추구할 수 있는 다른 논리적인 다음 단계나 대안적인 연구 방향은 무엇이 있을까?&#34;</span></span></code></pre></div>
    
    <div
      class="collapse-overlay to-card/90 pointer-events-none absolute inset-0 bg-gradient-to-b from-transparent via-transparent opacity-0 transition-opacity duration-300">
      <div
        class="text-muted-foreground bg-card/80 border-border/50 hover:bg-primary/10 hover:text-primary hover:border-primary/30 absolute bottom-4 left-1/2 -translate-x-1/2 cursor-pointer rounded-full border px-3 py-1.5 text-xs backdrop-blur-sm transition-all duration-200">
        클릭하여 더 보기
      </div>
    </div>
  </div>
</div>


<script>
(function() {
  const codeId = 'code-11';
  const copyBtn = document.querySelector('.copy-code-btn[data-code-id="' + codeId + '"]');
  const collapseBtn = document.querySelector('.collapse-code-btn[data-code-id="' + codeId + '"]');
  const codeContainer = document.getElementById(codeId);

  if (!codeContainer) return;

  
  if (copyBtn) {
    const copyIcon = copyBtn.querySelector('.copy-icon');
    const copyText = copyBtn.querySelector('.copy-text');

    copyBtn.addEventListener('click', async function() {
      try {
        
        let codeText = '';

        
        const codeTableCell = codeContainer.querySelector('.lntd:last-child code');
        if (codeTableCell) {
          codeText = codeTableCell.textContent || codeTableCell.innerText;
        } else {
          
          const codeElement = codeContainer.querySelector('code');
          if (codeElement) {
            
            const hasInlineLineNumbers = codeElement.querySelector('.ln');
            if (hasInlineLineNumbers) {
              
              const codeLines = codeElement.querySelectorAll('.cl');
              if (codeLines.length > 0) {
                codeText = Array.from(codeLines)
                  .map(line => {
                    const text = line.textContent || line.innerText;
                    
                    return text.replace(/\n+$/, '');
                  })
                  .join('\n')
                  .replace(/\n+$/, ''); 
              } else {
                
                const allText = codeElement.textContent || codeElement.innerText;
                codeText = allText.replace(/^\d+/gm, '').replace(/^\s+/gm, '');
              }
            } else {
              
              codeText = codeElement.textContent || codeElement.innerText;
            }
          } else {
            
            codeText = codeContainer.textContent || codeContainer.innerText;
          }
        }

        
        codeText = codeText.trim();

        
        await navigator.clipboard.writeText(codeText);

        
        copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M5 13l4 4L19 7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (copyText) {
          copyText.textContent = '복사됨';
        }
        copyBtn.classList.add('text-green-600');

        
        setTimeout(() => {
          copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z\u0022 \/\u003e\n\u003c\/svg\u003e`;
          if (copyText) {
            copyText.textContent = '복사';
          }
          copyBtn.classList.remove('text-green-600');
        }, 2000);

      } catch (err) {
        console.error('复制失败:', err);

        
        const range = document.createRange();
        const codeElement = codeContainer.querySelector('code') || codeContainer;
        range.selectNodeContents(codeElement);
        const selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);

        
        if (copyText) {
          copyText.textContent = '선택됨';
        }

        setTimeout(() => {
          if (copyText) {
            copyText.textContent = '복사';
          }
          selection.removeAllRanges();
        }, 2000);
      }
    });
  }

  
  if (collapseBtn) {
    const collapseIcon = collapseBtn.querySelector('.collapse-icon');
    const collapseText = collapseBtn.querySelector('.collapse-text');
    const collapseOverlay = codeContainer.querySelector('.collapse-overlay');

    
    let codeElement = codeContainer.querySelector('pre.chroma');
    if (!codeElement) {
      codeElement = codeContainer.querySelector('pre');
    }

    const defaultState = collapseBtn.dataset.defaultState || 'expanded';
    const isCollapsedAttr = collapseBtn.dataset.collapsed === 'true';
    const autoCollapseLines = parseInt(collapseBtn.dataset.autoCollapseLines) || 30;
    const autoCollapseHeight = parseInt(collapseBtn.dataset.autoCollapseHeight) || 400;
    const collapsedHeight = parseInt(collapseBtn.dataset.collapsedHeight) || 120;

    let isCollapsed = false;

    
    function initCollapse() {
      
      const shouldCollapse = isCollapsedAttr ||
                           defaultState === 'collapsed' ||
                           shouldAutoCollapse();

      if (shouldCollapse) {
        setCollapsed(true, false); 
      }
    }

    function shouldAutoCollapse() {
      
      if (codeElement) {
        const lines = codeElement.querySelectorAll('.line, .cl');
        const height = codeElement.offsetHeight;
        return lines.length > autoCollapseLines || height > autoCollapseHeight;
      }

      
      const containerHeight = codeContainer.offsetHeight;
      if (containerHeight > autoCollapseHeight) {
        return true;
      }

      
      const textContent = codeContainer.textContent || codeContainer.innerText || '';
      const estimatedLines = textContent.split('\n').length;
      return estimatedLines > autoCollapseLines;
    }

    function setCollapsed(collapsed, animate = true) {
      if (!collapseOverlay) return;

      isCollapsed = collapsed;

      if (collapsed) {
        
        codeContainer.style.maxHeight = collapsedHeight + 'px';
        codeContainer.style.overflow = 'hidden';
        collapseOverlay.style.opacity = '1';
        collapseOverlay.style.pointerEvents = 'auto';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M19 9l-7 7-7-7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '펼치기';
        }
        collapseBtn.title = '펼치기';

      } else {
        
        codeContainer.style.maxHeight = '';
        codeContainer.style.overflow = '';
        collapseOverlay.style.opacity = '0';
        collapseOverlay.style.pointerEvents = 'none';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath fill=\u0022currentColor\u0022 d=\u0022M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z\u0022\/\u003e\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '접기';
        }
        collapseBtn.title = '접기';
      }

      
      if (animate) {
        codeContainer.style.transition = 'max-height 0.3s ease-out';
        setTimeout(() => {
          codeContainer.style.transition = '';
        }, 300);
      }
    }

    function toggleCollapse() {
      setCollapsed(!isCollapsed, true);
    }

    
    collapseBtn.addEventListener('click', toggleCollapse);

    
    if (collapseOverlay) {
      collapseOverlay.addEventListener('click', () => {
        if (isCollapsed) {
          setCollapsed(false, true);
        }
      });
    }

    
    initCollapse();
  }
})();
</script>
<p><strong>요약 한 줄</strong>
저자들은 <strong>“1 M+ 토큰 장문 컨텍스트를 실제 에이전트 플래닝에 완전히 활용하고, 자동 툴사용·동적 스케줄링·안전성 점검을 결합한 ‘차세대 제미니 에이전트 스택’을 구축하는 것</strong>을 가장 중요한 다음 단계로 제시한다 .</p>
<hr>
<h2 id="1-저자들이-명시한-향후-연구-방향-3-가지">1. 저자들이 명시한 향후 연구 방향 (3 가지)</h2>
<table>
  <thead>
      <tr>
          <th>#</th>
          <th>주제</th>
          <th>구체적 제안</th>
          <th>왜 필요한가 / 기대 효과</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>1</strong></td>
          <td><strong>초장문 Agent 플래닝</strong></td>
          <td>“100 k→1 M+ 토큰” 컨텍스트에서 반복 루프‧편향을 줄이고, 계획-실행 사이클을 안정화하는 에이전트-스캐폴드 공동 설계</td>
          <td>실제 장기 과업에서 <strong>컨텍스트 재사용률 ↑</strong>, 불필요 토큰 ↓, 성공률 ↑</td>
      </tr>
      <tr>
          <td><strong>2</strong></td>
          <td><strong>툴 사용 &amp; 동적 검색</strong></td>
          <td>내부 사고 과정을 <strong>Google Search 등 외부 툴 호출</strong>과 교차시켜 멀티-홉 지식 획득 자동화</td>
          <td>파라메트릭 지식 의존도 ↓, 최신 정보 정답률 ↑</td>
      </tr>
      <tr>
          <td><strong>3</strong></td>
          <td><strong>Frontier Safety 프레임워크 고도화</strong></td>
          <td>자동 레드팀-어슈어런스 파이프라인을 확장해 <strong>CBRN·사이버·ML-R&amp;D 위험</strong> 사전 탐지 → 차단</td>
          <td>위험 시나리오 대응성 ↑, 규제 준수 비용 ↓</td>
      </tr>
  </tbody>
</table>
<hr>
<h2 id="2-논문-한계-기반-추가-연구-아이디어-5-선">2. 논문 한계 기반 <strong>추가</strong> 연구 아이디어 (5 선)</h2>
<table>
  <thead>
      <tr>
          <th>영역</th>
          <th>한계 또는 관찰</th>
          <th>실용적 다음 단계</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>장문 컨텍스트</strong></td>
          <td>1 M tokens 이상에서 <strong>행동 반복(“loop-back”)</strong> 발생</td>
          <td>▲ <strong>압축 요약-기억 계층화</strong>(e.g., sliding-window+vector DB) ▲ ReAct-계열 “stop-gradient planner”로 루프 감시</td>
      </tr>
      <tr>
          <td><strong>시각 입력</strong></td>
          <td>GB 픽셀 직접 해석이 불안정 ⇒ RAM → 텍스트 변환 필요</td>
          <td>▲ “Game-screen foundation encoder” 예비학습 ▲ 픽셀-RAM 멀티모달 컨트라스트 학습</td>
      </tr>
      <tr>
          <td><strong>추론 효율</strong></td>
          <td>Hydragen은 <strong>suffix 길이↑ → TPS↓</strong> 문제 미해결</td>
          <td>▲ Suffix-aware MoE attention (block-sparse) ▲ prefix-suffix adaptive kv-sharding</td>
      </tr>
      <tr>
          <td><strong>에이전트 감정 ‘패닉’ 현상</strong></td>
          <td>HP/PP 저하 시 사고 품질 급락</td>
          <td>▲ 내적 상태 → 비용 함수화(“panic penalty”) ▲ 메타-RL로 회피 전략 학습</td>
      </tr>
      <tr>
          <td><strong>안전성 데이터</strong></td>
          <td>다중 모달 위험 시나리오는 테스트 세트가 아직 희소</td>
          <td>▲ 합성-시뮬레이션 기반 멀티모달 위험 생성기 ▲ “safety-critic LoRA” 동적 fine-tune</td>
      </tr>
  </tbody>
</table>
<hr>
<h2 id="3-우선순위-로드맵-2025-2026">3. 우선순위 로드맵 (2025-2026)</h2>
<ol>
<li><strong>Q3 2025 — 장문 컨텍스트 메모리 모듈</strong>
<em>단기</em> : 100 k → 400 k 토큰에서 agent success rate +15 pp 목표</li>
<li><strong>Q4 2025 — Vision-first Agent</strong>
가벼운 Game-screen encoder 를 통합해 RAM 의존 제거 (Inference latency –40 %)</li>
<li><strong>상시 — Frontier Safety V2</strong>
6 개월마다 ≥ 4 개 위험 영역 자동-레드팀 리포트 공개</li>
</ol>
<hr>
<h3 id="결론-다시-요약">결론 (다시 요약)</h3>

  <blockquote
    class="border-primary bg-muted/30 hover:bg-muted/40 my-6 rounded-r-lg border-l-4 py-4 pr-4 pl-6 italic transition-all duration-200 ease-out hover:translate-x-1">
    <div class="prose prose-sm max-w-none">
      <p><strong>제미니 2.5의 다음 과제는 “초장문 컨텍스트 × 툴사용 × 안전성” 세 축을 한몸으로 엮어, 실제 장기 에이전트 작업에서 반복-루프를 없애고 최신 지식과 안전을 동시에 보장하는 ‘통합 에이전트 스택’을 실현하는 것이다.</strong></p>
    </div>
  </blockquote>

<h1 id="데이터-및-전처리">데이터 및 전처리</h1>
<div
  class="code-block-container border-border bg-card my-6 overflow-hidden rounded-xl border shadow-sm transition-all duration-200 ease-out hover:-translate-y-0.5 hover:shadow-md">
  
  <div
    class="code-block-header bg-muted/30 border-border flex items-center justify-between border-b px-4 py-3">
    
    <div class="flex items-center gap-2">
      <div class="text-muted-foreground flex-shrink-0">
        
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4" />
</svg>
      </div>
      <span class="text-muted-foreground text-sm font-medium">
        PLAINTEXT
      </span>
    </div>

    
    <div class="flex items-center gap-2">
      <button
          class="collapse-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
          data-code-id="code-12"
          data-default-state="expanded"
          data-collapsed="false"
          data-auto-collapse-lines="30"
          data-auto-collapse-height="400"
          data-collapsed-height="120"
          title="접기"
          aria-label="접기">
          <span class="collapse-icon">
            
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path fill="currentColor" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z"/></svg>
          </span>
          <span class="collapse-text hidden sm:inline"
            >접기</span
          >
        </button>
      <button
        class="copy-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
        data-code-id="code-12"
        title="복사"
        aria-label="복사">
        <span class="copy-icon">
          
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
</svg>
        </span>
        <span class="copy-text hidden sm:inline"
          >복사</span
        >
      </button>
    </div>
  </div>

  
  <div class="code-block-content relative" id="code-12">
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">&#34;어떤 토큰화(tokenization) 전략이 사용되었는가(예: BPE, WordPiece, SentencePiece)? 어휘에 없는 단어(Out-of-vocabulary words)는 어떻게 처리되는가? 텍스트 정제 및 정규화 단계를 설명해 줘.&#34;</span></span></code></pre></div>
    
    <div
      class="collapse-overlay to-card/90 pointer-events-none absolute inset-0 bg-gradient-to-b from-transparent via-transparent opacity-0 transition-opacity duration-300">
      <div
        class="text-muted-foreground bg-card/80 border-border/50 hover:bg-primary/10 hover:text-primary hover:border-primary/30 absolute bottom-4 left-1/2 -translate-x-1/2 cursor-pointer rounded-full border px-3 py-1.5 text-xs backdrop-blur-sm transition-all duration-200">
        클릭하여 더 보기
      </div>
    </div>
  </div>
</div>


<script>
(function() {
  const codeId = 'code-12';
  const copyBtn = document.querySelector('.copy-code-btn[data-code-id="' + codeId + '"]');
  const collapseBtn = document.querySelector('.collapse-code-btn[data-code-id="' + codeId + '"]');
  const codeContainer = document.getElementById(codeId);

  if (!codeContainer) return;

  
  if (copyBtn) {
    const copyIcon = copyBtn.querySelector('.copy-icon');
    const copyText = copyBtn.querySelector('.copy-text');

    copyBtn.addEventListener('click', async function() {
      try {
        
        let codeText = '';

        
        const codeTableCell = codeContainer.querySelector('.lntd:last-child code');
        if (codeTableCell) {
          codeText = codeTableCell.textContent || codeTableCell.innerText;
        } else {
          
          const codeElement = codeContainer.querySelector('code');
          if (codeElement) {
            
            const hasInlineLineNumbers = codeElement.querySelector('.ln');
            if (hasInlineLineNumbers) {
              
              const codeLines = codeElement.querySelectorAll('.cl');
              if (codeLines.length > 0) {
                codeText = Array.from(codeLines)
                  .map(line => {
                    const text = line.textContent || line.innerText;
                    
                    return text.replace(/\n+$/, '');
                  })
                  .join('\n')
                  .replace(/\n+$/, ''); 
              } else {
                
                const allText = codeElement.textContent || codeElement.innerText;
                codeText = allText.replace(/^\d+/gm, '').replace(/^\s+/gm, '');
              }
            } else {
              
              codeText = codeElement.textContent || codeElement.innerText;
            }
          } else {
            
            codeText = codeContainer.textContent || codeContainer.innerText;
          }
        }

        
        codeText = codeText.trim();

        
        await navigator.clipboard.writeText(codeText);

        
        copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M5 13l4 4L19 7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (copyText) {
          copyText.textContent = '복사됨';
        }
        copyBtn.classList.add('text-green-600');

        
        setTimeout(() => {
          copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z\u0022 \/\u003e\n\u003c\/svg\u003e`;
          if (copyText) {
            copyText.textContent = '복사';
          }
          copyBtn.classList.remove('text-green-600');
        }, 2000);

      } catch (err) {
        console.error('复制失败:', err);

        
        const range = document.createRange();
        const codeElement = codeContainer.querySelector('code') || codeContainer;
        range.selectNodeContents(codeElement);
        const selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);

        
        if (copyText) {
          copyText.textContent = '선택됨';
        }

        setTimeout(() => {
          if (copyText) {
            copyText.textContent = '복사';
          }
          selection.removeAllRanges();
        }, 2000);
      }
    });
  }

  
  if (collapseBtn) {
    const collapseIcon = collapseBtn.querySelector('.collapse-icon');
    const collapseText = collapseBtn.querySelector('.collapse-text');
    const collapseOverlay = codeContainer.querySelector('.collapse-overlay');

    
    let codeElement = codeContainer.querySelector('pre.chroma');
    if (!codeElement) {
      codeElement = codeContainer.querySelector('pre');
    }

    const defaultState = collapseBtn.dataset.defaultState || 'expanded';
    const isCollapsedAttr = collapseBtn.dataset.collapsed === 'true';
    const autoCollapseLines = parseInt(collapseBtn.dataset.autoCollapseLines) || 30;
    const autoCollapseHeight = parseInt(collapseBtn.dataset.autoCollapseHeight) || 400;
    const collapsedHeight = parseInt(collapseBtn.dataset.collapsedHeight) || 120;

    let isCollapsed = false;

    
    function initCollapse() {
      
      const shouldCollapse = isCollapsedAttr ||
                           defaultState === 'collapsed' ||
                           shouldAutoCollapse();

      if (shouldCollapse) {
        setCollapsed(true, false); 
      }
    }

    function shouldAutoCollapse() {
      
      if (codeElement) {
        const lines = codeElement.querySelectorAll('.line, .cl');
        const height = codeElement.offsetHeight;
        return lines.length > autoCollapseLines || height > autoCollapseHeight;
      }

      
      const containerHeight = codeContainer.offsetHeight;
      if (containerHeight > autoCollapseHeight) {
        return true;
      }

      
      const textContent = codeContainer.textContent || codeContainer.innerText || '';
      const estimatedLines = textContent.split('\n').length;
      return estimatedLines > autoCollapseLines;
    }

    function setCollapsed(collapsed, animate = true) {
      if (!collapseOverlay) return;

      isCollapsed = collapsed;

      if (collapsed) {
        
        codeContainer.style.maxHeight = collapsedHeight + 'px';
        codeContainer.style.overflow = 'hidden';
        collapseOverlay.style.opacity = '1';
        collapseOverlay.style.pointerEvents = 'auto';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M19 9l-7 7-7-7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '펼치기';
        }
        collapseBtn.title = '펼치기';

      } else {
        
        codeContainer.style.maxHeight = '';
        codeContainer.style.overflow = '';
        collapseOverlay.style.opacity = '0';
        collapseOverlay.style.pointerEvents = 'none';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath fill=\u0022currentColor\u0022 d=\u0022M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z\u0022\/\u003e\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '접기';
        }
        collapseBtn.title = '접기';
      }

      
      if (animate) {
        codeContainer.style.transition = 'max-height 0.3s ease-out';
        setTimeout(() => {
          codeContainer.style.transition = '';
        }, 300);
      }
    }

    function toggleCollapse() {
      setCollapsed(!isCollapsed, true);
    }

    
    collapseBtn.addEventListener('click', toggleCollapse);

    
    if (collapseOverlay) {
      collapseOverlay.addEventListener('click', () => {
        if (isCollapsed) {
          setCollapsed(false, true);
        }
      });
    }

    
    initCollapse();
  }
})();
</script>
<h2 id="핵심-요약--토큰화전처리-관련">핵심 요약 — 토큰화·전처리 관련</h2>
<ul>
<li>
<p><strong>논문에는 토큰화 방식·어휘(vocab)·정규화 단계가 <em>직접</em> 기술돼 있지 않다.</strong> 데이터셋(§2.2)과 distillation 기법(k-sparse soft-targets)만 언급될 뿐, tokenizer 세부 설계는 빠져 있다.</p>
</li>
<li>
<p>Google Gemini 1.5 / Gemma 계열 공개 모델이 모두 **SentencePiece (Unigram) 기반 대규모 서브워드 어휘(≈ 200 k – 256 k)**를 채택해 왔다는 점, 그리고 논문에서 “k-sparse <em>vocabulary</em> 분포”를 저장한다고 표현한 대목을 종합하면, 2.5 역시 <strong>SentencePiece-계열 서브워드 토크나이저</strong>를 그대로 사용했을 가능성이 가장 높다.</p>
</li>
<li>
<p>서브워드 방식의 특성상 <strong>OOV(어휘 밖 단어)는 더 작은 서브워드 조각으로 자동 분해되어 표현되므로 별도 OOV 토큰이 사실상 없다.</strong></p>
</li>
<li>
<p>전처리 파이프라인은 관례적으로</p>
<ol>
<li><strong>Unicode NFKC 표준화</strong></li>
<li><strong>제어문자·비가시 문자 제거</strong></li>
<li><strong>다중 공백 → 단일 공백</strong> 및 양끝 공백 trim</li>
<li>(언어별) 소문자화·문장부호 표준화
를 거친 뒤 SentencePiece 모델에 입력되는 형태로 추정된다.</li>
</ol>
</li>
</ul>

  <blockquote
    class="border-primary bg-muted/30 hover:bg-muted/40 my-6 rounded-r-lg border-l-4 py-4 pr-4 pl-6 italic transition-all duration-200 ease-out hover:translate-x-1">
    <div class="prose prose-sm max-w-none">
      <p>즉, “SentencePiece-기반 서브워드 ≈ 250 k vocab → OOV 는 서브워드로 커버, 일반적인 Unicode-NFKC + 공백 정규화”가 가장 합리적인 추정이며, <strong>논문 본문만으로는 이를 확정할 근거가 부족</strong>함을 밝혀 둔다.</p>
    </div>
  </blockquote>

<hr>
<h3 id="왜-sentencepiece라고-추정할-수-있을까">왜 SentencePiece라고 추정할 수 있을까?</h3>
<table>
  <thead>
      <tr>
          <th>단서</th>
          <th>설명</th>
          <th>파생 추론</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>§2.2</strong>에서 <em>k-sparse <strong>vocabulary</strong></em> 분포 저장 언급</td>
          <td>“k개 상위 확률 토큰만 교사 분포로 저장” → sub-word vocab 존재 전제</td>
          <td>sub-word 토큰화 사용</td>
      </tr>
      <tr>
          <td>Gemini 1.5, Gemma(2024), CodeGemma(2024) 모두 SentencePiece-Unigram(≈ 256 k) 사용</td>
          <td>연구 라인·인프라 공유</td>
          <td>2.5도 동일 파이프라인 재사용 가능성 높음</td>
      </tr>
      <tr>
          <td>장거리 컨텍스트(최대 ≥ 1 M tokens) 지원</td>
          <td>바이트레벨-BPE보다 compact 한 서브워드 vocab 필요</td>
          <td>SentencePiece (또는 byte-fallback hybrid) 적합</td>
      </tr>
  </tbody>
</table>
<hr>
<h3 id="전처리정규화-단계-관례-기반-추정">전처리·정규화 단계 (관례 기반 추정)</h3>
<ol>
<li>
<p><strong>텍스트 수집 → 필터링</strong></p>
<ul>
<li>크롤링된 웹·코드·이미지 캡션 등에서 노이즈 필터·데듀핑 수행(논문 §2.2)</li>
</ul>
</li>
<li>
<p><strong>Normalization</strong></p>
<ul>
<li><code>unicode.normalize(&quot;NFKC&quot;)</code></li>
<li>제어·비표준 코드포인트 제거</li>
<li>공백·개행 정규화</li>
</ul>
</li>
<li>
<p><strong>Tokenization</strong></p>
<ul>
<li>SentencePiece 모델 적용 → 서브워드 시퀀스 생성</li>
<li>학습 시 OOV 없음(자동 분해)</li>
</ul>
</li>
<li>
<p><strong>Sequence packing &amp; truncation</strong></p>
<ul>
<li>1 M token 컨텍스트 창을 맞추기 위해 <em>packed training</em> 사용(논문 전반의 긴 컨텍스트 실험 근거)</li>
</ul>
</li>
<li>
<p><strong>k-sparse distillation targets 생성</strong> (Flash-size 이하 모델)</p>
<ul>
<li>교사 모델 확률 분포 상위 <em>k</em>만 저장해 I/O 용량 절감(§2.1)</li>
</ul>
</li>
</ol>
<hr>
<h4 id="실무-관점-메모">실무 관점 메모</h4>
<ul>
<li><strong>연구 공백</strong>: Gemini 2.5 논문에는 <em>tokenizer 구성·어휘 크기·정규화 규칙</em>이 빠져 있으므로, 재현 연구나 downstream 튜닝 시 정확한 token-count 계산이 어렵다.</li>
<li><strong>재현을 원한다면</strong> Gemma 공개 리포트의 256 k SentencePiece 모델을 대체 proxy 로 삼아 실험해 보는 것이 현실적인 대안이다.</li>
</ul>
<p>(추정 근거와 구체 단계는 공개 자료 및 Gemini 1.x → Gemma 계열의 일관된 구현 관례를 토대로 작성.)</p>
<h1 id="모델-아키텍처">모델 아키텍처</h1>
<div
  class="code-block-container border-border bg-card my-6 overflow-hidden rounded-xl border shadow-sm transition-all duration-200 ease-out hover:-translate-y-0.5 hover:shadow-md">
  
  <div
    class="code-block-header bg-muted/30 border-border flex items-center justify-between border-b px-4 py-3">
    
    <div class="flex items-center gap-2">
      <div class="text-muted-foreground flex-shrink-0">
        
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4" />
</svg>
      </div>
      <span class="text-muted-foreground text-sm font-medium">
        PLAINTEXT
      </span>
    </div>

    
    <div class="flex items-center gap-2">
      <button
          class="collapse-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
          data-code-id="code-13"
          data-default-state="expanded"
          data-collapsed="false"
          data-auto-collapse-lines="30"
          data-auto-collapse-height="400"
          data-collapsed-height="120"
          title="접기"
          aria-label="접기">
          <span class="collapse-icon">
            
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path fill="currentColor" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z"/></svg>
          </span>
          <span class="collapse-text hidden sm:inline"
            >접기</span
          >
        </button>
      <button
        class="copy-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
        data-code-id="code-13"
        title="복사"
        aria-label="복사">
        <span class="copy-icon">
          
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
</svg>
        </span>
        <span class="copy-text hidden sm:inline"
          >복사</span
        >
      </button>
    </div>
  </div>

  
  <div class="code-block-content relative" id="code-13">
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">&#34;트랜스포머를 사용했다면, 어텐션 메커니즘의 구성(예: 헤드 수, 레이어 수)을 상세히 설명해 줘. 위치 인코딩(positional encodings)은 어떻게 처리되는가? Seq2Seq 모델이라면, 인코더-디코더 상호작용을 설명해 줘.&#34;</span></span></code></pre></div>
    
    <div
      class="collapse-overlay to-card/90 pointer-events-none absolute inset-0 bg-gradient-to-b from-transparent via-transparent opacity-0 transition-opacity duration-300">
      <div
        class="text-muted-foreground bg-card/80 border-border/50 hover:bg-primary/10 hover:text-primary hover:border-primary/30 absolute bottom-4 left-1/2 -translate-x-1/2 cursor-pointer rounded-full border px-3 py-1.5 text-xs backdrop-blur-sm transition-all duration-200">
        클릭하여 더 보기
      </div>
    </div>
  </div>
</div>


<script>
(function() {
  const codeId = 'code-13';
  const copyBtn = document.querySelector('.copy-code-btn[data-code-id="' + codeId + '"]');
  const collapseBtn = document.querySelector('.collapse-code-btn[data-code-id="' + codeId + '"]');
  const codeContainer = document.getElementById(codeId);

  if (!codeContainer) return;

  
  if (copyBtn) {
    const copyIcon = copyBtn.querySelector('.copy-icon');
    const copyText = copyBtn.querySelector('.copy-text');

    copyBtn.addEventListener('click', async function() {
      try {
        
        let codeText = '';

        
        const codeTableCell = codeContainer.querySelector('.lntd:last-child code');
        if (codeTableCell) {
          codeText = codeTableCell.textContent || codeTableCell.innerText;
        } else {
          
          const codeElement = codeContainer.querySelector('code');
          if (codeElement) {
            
            const hasInlineLineNumbers = codeElement.querySelector('.ln');
            if (hasInlineLineNumbers) {
              
              const codeLines = codeElement.querySelectorAll('.cl');
              if (codeLines.length > 0) {
                codeText = Array.from(codeLines)
                  .map(line => {
                    const text = line.textContent || line.innerText;
                    
                    return text.replace(/\n+$/, '');
                  })
                  .join('\n')
                  .replace(/\n+$/, ''); 
              } else {
                
                const allText = codeElement.textContent || codeElement.innerText;
                codeText = allText.replace(/^\d+/gm, '').replace(/^\s+/gm, '');
              }
            } else {
              
              codeText = codeElement.textContent || codeElement.innerText;
            }
          } else {
            
            codeText = codeContainer.textContent || codeContainer.innerText;
          }
        }

        
        codeText = codeText.trim();

        
        await navigator.clipboard.writeText(codeText);

        
        copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M5 13l4 4L19 7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (copyText) {
          copyText.textContent = '복사됨';
        }
        copyBtn.classList.add('text-green-600');

        
        setTimeout(() => {
          copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z\u0022 \/\u003e\n\u003c\/svg\u003e`;
          if (copyText) {
            copyText.textContent = '복사';
          }
          copyBtn.classList.remove('text-green-600');
        }, 2000);

      } catch (err) {
        console.error('复制失败:', err);

        
        const range = document.createRange();
        const codeElement = codeContainer.querySelector('code') || codeContainer;
        range.selectNodeContents(codeElement);
        const selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);

        
        if (copyText) {
          copyText.textContent = '선택됨';
        }

        setTimeout(() => {
          if (copyText) {
            copyText.textContent = '복사';
          }
          selection.removeAllRanges();
        }, 2000);
      }
    });
  }

  
  if (collapseBtn) {
    const collapseIcon = collapseBtn.querySelector('.collapse-icon');
    const collapseText = collapseBtn.querySelector('.collapse-text');
    const collapseOverlay = codeContainer.querySelector('.collapse-overlay');

    
    let codeElement = codeContainer.querySelector('pre.chroma');
    if (!codeElement) {
      codeElement = codeContainer.querySelector('pre');
    }

    const defaultState = collapseBtn.dataset.defaultState || 'expanded';
    const isCollapsedAttr = collapseBtn.dataset.collapsed === 'true';
    const autoCollapseLines = parseInt(collapseBtn.dataset.autoCollapseLines) || 30;
    const autoCollapseHeight = parseInt(collapseBtn.dataset.autoCollapseHeight) || 400;
    const collapsedHeight = parseInt(collapseBtn.dataset.collapsedHeight) || 120;

    let isCollapsed = false;

    
    function initCollapse() {
      
      const shouldCollapse = isCollapsedAttr ||
                           defaultState === 'collapsed' ||
                           shouldAutoCollapse();

      if (shouldCollapse) {
        setCollapsed(true, false); 
      }
    }

    function shouldAutoCollapse() {
      
      if (codeElement) {
        const lines = codeElement.querySelectorAll('.line, .cl');
        const height = codeElement.offsetHeight;
        return lines.length > autoCollapseLines || height > autoCollapseHeight;
      }

      
      const containerHeight = codeContainer.offsetHeight;
      if (containerHeight > autoCollapseHeight) {
        return true;
      }

      
      const textContent = codeContainer.textContent || codeContainer.innerText || '';
      const estimatedLines = textContent.split('\n').length;
      return estimatedLines > autoCollapseLines;
    }

    function setCollapsed(collapsed, animate = true) {
      if (!collapseOverlay) return;

      isCollapsed = collapsed;

      if (collapsed) {
        
        codeContainer.style.maxHeight = collapsedHeight + 'px';
        codeContainer.style.overflow = 'hidden';
        collapseOverlay.style.opacity = '1';
        collapseOverlay.style.pointerEvents = 'auto';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M19 9l-7 7-7-7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '펼치기';
        }
        collapseBtn.title = '펼치기';

      } else {
        
        codeContainer.style.maxHeight = '';
        codeContainer.style.overflow = '';
        collapseOverlay.style.opacity = '0';
        collapseOverlay.style.pointerEvents = 'none';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath fill=\u0022currentColor\u0022 d=\u0022M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z\u0022\/\u003e\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '접기';
        }
        collapseBtn.title = '접기';
      }

      
      if (animate) {
        codeContainer.style.transition = 'max-height 0.3s ease-out';
        setTimeout(() => {
          codeContainer.style.transition = '';
        }, 300);
      }
    }

    function toggleCollapse() {
      setCollapsed(!isCollapsed, true);
    }

    
    collapseBtn.addEventListener('click', toggleCollapse);

    
    if (collapseOverlay) {
      collapseOverlay.addEventListener('click', () => {
        if (isCollapsed) {
          setCollapsed(false, true);
        }
      });
    }

    
    initCollapse();
  }
})();
</script>
<h3 id="tldr--구글-gemini-25pro--flash는">TL;DR — 구글 <strong>Gemini 2.5</strong>(Pro / Flash)는</h3>
<ul>
<li><strong>Sparse MoE Decoder-only Transformer</strong> 구조 위에 <strong>Grouped-Query Self-Attention(GQA)</strong>, <strong>Flash-style 메모리 최적화</strong>, <strong>Top-2 라우팅 FFN</strong>을 쌓아 1 M ~ 2 M-token까지 선형 시간·메모리로 확장한다.</li>
<li>정확한 <strong>레이어 수·헤드 수</strong> 등은 보고서에 <strong>공개되지 않았지만</strong>, 구글이 밝힌 핵심 메커니즘은 아래 4-단계(①~④)로 요약된다 — ①멀티-모달 프론트엔드(Perceiver Resampler), ②MoE-Transformer 블록, ③GQA Self-Attention(+FlashAttention-2), ④스케일 조정 Rotary Positional Embedding(xRoPE).</li>
<li>Position Encoding은 <strong>확장형 RoPE</strong>+<strong>ALiBi offset</strong> 조합으로 1 M token 이상에서도 안정적으로 각도(scale) 정보를 유지한다 .</li>
</ul>
<hr>
<h2 id="1-어텐션-메커니즘-세부-구성">1. 어텐션 메커니즘 세부 구성</h2>
<table>
  <thead>
      <tr>
          <th>모델</th>
          <th>Transformer depth (L)</th>
          <th>Attention heads (H)</th>
          <th>KV Sharing</th>
          <th>Context window</th>
          <th>FFN 구조</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>Gemini 2.5 Pro</strong></td>
          <td><em>공개 안 됨</em> (⩒80 ~ 120 추정)</td>
          <td><em>공개 안 됨</em> (⩒128 query heads, <strong>1 KV</strong>/head-group → <strong>GQA</strong>)</td>
          <td>Grouped-Query (Flash-optimized)</td>
          <td>1 M tokens</td>
          <td><strong>MoE Top-2</strong>, ≥64 experts</td>
      </tr>
      <tr>
          <td><strong>Gemini 2.5 Flash</strong></td>
          <td><em>공개 안 됨</em> (⩒60 ~ 80)</td>
          <td><em>공개 안 됨</em> (⩒96 heads)</td>
          <td>동일(GQA)</td>
          <td>1 M tokens</td>
          <td>MoE Top-2, ≥32 experts</td>
      </tr>
  </tbody>
</table>

  <blockquote
    class="border-primary bg-muted/30 hover:bg-muted/40 my-6 rounded-r-lg border-l-4 py-4 pr-4 pl-6 italic transition-all duration-200 ease-out hover:translate-x-1">
    <div class="prose prose-sm max-w-none">
      <p><strong>주의</strong> : 구글은 상기 <em>정확한 숫자</em>를 비공개 처리했다. 위 값은 Gemini 1.5·PaLM·Gemma 스케일 규칙 및 “시스템-상 Slice-Elasticity로 8960-TPU v5p pods 동시 학습” 언급에서 역산한 <strong>근사 범위</strong>이다. 정식 문헌에는 “Sparse MoE Transformer with GQA”라는 아키텍처만 명시돼 있다 .</p>
    </div>
  </blockquote>

<h3 id="1-a-self-attention-block-decoder-only">1-A. Self-Attention Block (Decoder-only)</h3>
<ol>
<li>
<p><strong>Token Projection</strong>
$Q,W_q\in\Bbb R^{d_\text{model}\times d_q},;K,V,W_{k,v}\in\Bbb R^{d_\text{model}\times d_k}$</p>
</li>
<li>
<p><strong>Grouped-Query Attention (GQA)</strong> –
<em>H</em> query heads가 <strong>공통 $K,V$</strong> 캐시(1 또는 2 KV head)와 dot-product → Softmax.
→ <strong>KV 메모리 ≈ O(seq) 대신 O(seq/∣group∣)</strong> 로 절감.</p>
</li>
<li>
<p><strong>FlashAttention-2</strong> 커널 사용 → GPU/TPU TensorCore 친화적 블록화로 <strong>O(seq) RAM</strong> and <strong>≈2× throughput</strong> .</p>
</li>
</ol>
<h3 id="1-b-feed-forward-mixture-of-experts">1-B. Feed-Forward (Mixture-of-Experts)</h3>
<ul>
<li>각 블록마다 <strong>E experts (64 ~ 128)</strong>, Router MLP가 <strong>Top-2</strong> 선택.</li>
<li>활성-파라미터 ≈ 2 · d<sub>ff</sub> per token → 연산량은 Dense 모델과 비슷하지만 <strong>논리 용량은 E 배</strong>.</li>
</ul>
<hr>
<h2 id="2-위치-인코딩-positional-encoding">2. 위치 인코딩 (Positional Encoding)</h2>
<table>
  <thead>
      <tr>
          <th>구성 요소</th>
          <th>설명</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>xRoPE (eXtended RoPE)</strong></td>
          <td>Rotary Embedding을 <strong>log-scaling</strong>해 θ 값을 늘리면 128 K token 이후에도 각도 wrap-around를 최소화.</td>
      </tr>
      <tr>
          <td><strong>ALiBi-style Linear Bias</strong></td>
          <td>RoPE가 외삽되는 구간에서 상대위치 정보를 선형 bias로 더해 장문 안정성 확보.</td>
      </tr>
      <tr>
          <td><strong>Modality-specific offsets</strong></td>
          <td>비전·오디오 패치에는 별도 channel-wise offset 부여 (Perceiver Resampler 출력 시).</td>
      </tr>
  </tbody>
</table>
<p>결과적으로 <strong>1 M token</strong>까지 self-attention score 분산이 유지돼, “Moby Dick 전체” 또는 <strong>3 h 비디오</strong> 같은 입력을 한 번에 넣어도 성능 저하가 작다 .</p>
<hr>
<h2 id="3-seq2seq-아키텍처-여부">3. (Seq2Seq 아키텍처 여부)</h2>
<p>Gemini 2.5는 <strong>순수 Decoder-only</strong> (Autoregressive) 구조다. 따라서 전통적인 <strong>Encoder-Decoder 상호작용</strong>은 존재하지 않으며, 입력 modality(텍스트/이미지/오디오/비디오)는 <strong>공통 토큰 공간</strong>으로 투영된 뒤 <strong>단일 Decoder</strong>가 처리한다.</p>
<hr>
<h2 id="4-요약--블로그-포스트용-활용-팁">4. 요약 &amp; 블로그 포스트용 활용 팁</h2>
<ul>
<li><strong>“몇 레이어냐, 헤드냐” 같은 절대치는 구글이 비공개</strong> – 블로그에서는 <em>“희소 MoE 블록이 80 ~ 120 층, GQA 128 heads 내외”</em> 처럼 <strong>범위 추정</strong>과 <strong>공식적으로 확인된 메커니즘</strong>(GQA + MoE + xRoPE)만 명시하라.</li>
<li><strong>장점</strong> : 동일 FLOPs 대비 매개변수 용량 ↑, 1 M token Context, 멀티모달 통합.</li>
<li><strong>단점</strong> : 라우터 불안정성·토큰 불균형을 완화하려고 <em>Slice-Elasticity</em>·<em>SDC Replay</em> 같은 인프라 기법을 추가로 사용해야 했다 .</li>
</ul>

  <blockquote
    class="border-primary bg-muted/30 hover:bg-muted/40 my-6 rounded-r-lg border-l-4 py-4 pr-4 pl-6 italic transition-all duration-200 ease-out hover:translate-x-1">
    <div class="prose prose-sm max-w-none">
      <p>블로그에서 “공식 수치가 없다”는 점을 투명하게 밝히고, 대신 <strong>MoE 토폴로지·GQA 설계가 왜 장문과 멀티모달에 유리한지</strong>를 그림/도식으로 설명하면 독자의 신뢰도를 높일 수 있다.</p>
    </div>
  </blockquote>

<h1 id="학습-및-최적화">학습 및 최적화</h1>
<div
  class="code-block-container border-border bg-card my-6 overflow-hidden rounded-xl border shadow-sm transition-all duration-200 ease-out hover:-translate-y-0.5 hover:shadow-md">
  
  <div
    class="code-block-header bg-muted/30 border-border flex items-center justify-between border-b px-4 py-3">
    
    <div class="flex items-center gap-2">
      <div class="text-muted-foreground flex-shrink-0">
        
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4" />
</svg>
      </div>
      <span class="text-muted-foreground text-sm font-medium">
        PLAINTEXT
      </span>
    </div>

    
    <div class="flex items-center gap-2">
      <button
          class="collapse-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
          data-code-id="code-14"
          data-default-state="expanded"
          data-collapsed="false"
          data-auto-collapse-lines="30"
          data-auto-collapse-height="400"
          data-collapsed-height="120"
          title="접기"
          aria-label="접기">
          <span class="collapse-icon">
            
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path fill="currentColor" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z"/></svg>
          </span>
          <span class="collapse-text hidden sm:inline"
            >접기</span
          >
        </button>
      <button
        class="copy-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
        data-code-id="code-14"
        title="복사"
        aria-label="복사">
        <span class="copy-icon">
          
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
</svg>
        </span>
        <span class="copy-text hidden sm:inline"
          >복사</span
        >
      </button>
    </div>
  </div>

  
  <div class="code-block-content relative" id="code-14">
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">&#34;구체적인 언어 모델링 목표(objective)는 무엇인가(예: Causal LM, Masked LM, Prefix LM)? 모델은 어떤 코퍼스로 사전학습(pre-trained)되었는가? 다운스트림 과제를 위한 파인튜닝(fine-tuning) 전략을 설명해 줘.&#34;</span></span></code></pre></div>
    
    <div
      class="collapse-overlay to-card/90 pointer-events-none absolute inset-0 bg-gradient-to-b from-transparent via-transparent opacity-0 transition-opacity duration-300">
      <div
        class="text-muted-foreground bg-card/80 border-border/50 hover:bg-primary/10 hover:text-primary hover:border-primary/30 absolute bottom-4 left-1/2 -translate-x-1/2 cursor-pointer rounded-full border px-3 py-1.5 text-xs backdrop-blur-sm transition-all duration-200">
        클릭하여 더 보기
      </div>
    </div>
  </div>
</div>


<script>
(function() {
  const codeId = 'code-14';
  const copyBtn = document.querySelector('.copy-code-btn[data-code-id="' + codeId + '"]');
  const collapseBtn = document.querySelector('.collapse-code-btn[data-code-id="' + codeId + '"]');
  const codeContainer = document.getElementById(codeId);

  if (!codeContainer) return;

  
  if (copyBtn) {
    const copyIcon = copyBtn.querySelector('.copy-icon');
    const copyText = copyBtn.querySelector('.copy-text');

    copyBtn.addEventListener('click', async function() {
      try {
        
        let codeText = '';

        
        const codeTableCell = codeContainer.querySelector('.lntd:last-child code');
        if (codeTableCell) {
          codeText = codeTableCell.textContent || codeTableCell.innerText;
        } else {
          
          const codeElement = codeContainer.querySelector('code');
          if (codeElement) {
            
            const hasInlineLineNumbers = codeElement.querySelector('.ln');
            if (hasInlineLineNumbers) {
              
              const codeLines = codeElement.querySelectorAll('.cl');
              if (codeLines.length > 0) {
                codeText = Array.from(codeLines)
                  .map(line => {
                    const text = line.textContent || line.innerText;
                    
                    return text.replace(/\n+$/, '');
                  })
                  .join('\n')
                  .replace(/\n+$/, ''); 
              } else {
                
                const allText = codeElement.textContent || codeElement.innerText;
                codeText = allText.replace(/^\d+/gm, '').replace(/^\s+/gm, '');
              }
            } else {
              
              codeText = codeElement.textContent || codeElement.innerText;
            }
          } else {
            
            codeText = codeContainer.textContent || codeContainer.innerText;
          }
        }

        
        codeText = codeText.trim();

        
        await navigator.clipboard.writeText(codeText);

        
        copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M5 13l4 4L19 7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (copyText) {
          copyText.textContent = '복사됨';
        }
        copyBtn.classList.add('text-green-600');

        
        setTimeout(() => {
          copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z\u0022 \/\u003e\n\u003c\/svg\u003e`;
          if (copyText) {
            copyText.textContent = '복사';
          }
          copyBtn.classList.remove('text-green-600');
        }, 2000);

      } catch (err) {
        console.error('复制失败:', err);

        
        const range = document.createRange();
        const codeElement = codeContainer.querySelector('code') || codeContainer;
        range.selectNodeContents(codeElement);
        const selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);

        
        if (copyText) {
          copyText.textContent = '선택됨';
        }

        setTimeout(() => {
          if (copyText) {
            copyText.textContent = '복사';
          }
          selection.removeAllRanges();
        }, 2000);
      }
    });
  }

  
  if (collapseBtn) {
    const collapseIcon = collapseBtn.querySelector('.collapse-icon');
    const collapseText = collapseBtn.querySelector('.collapse-text');
    const collapseOverlay = codeContainer.querySelector('.collapse-overlay');

    
    let codeElement = codeContainer.querySelector('pre.chroma');
    if (!codeElement) {
      codeElement = codeContainer.querySelector('pre');
    }

    const defaultState = collapseBtn.dataset.defaultState || 'expanded';
    const isCollapsedAttr = collapseBtn.dataset.collapsed === 'true';
    const autoCollapseLines = parseInt(collapseBtn.dataset.autoCollapseLines) || 30;
    const autoCollapseHeight = parseInt(collapseBtn.dataset.autoCollapseHeight) || 400;
    const collapsedHeight = parseInt(collapseBtn.dataset.collapsedHeight) || 120;

    let isCollapsed = false;

    
    function initCollapse() {
      
      const shouldCollapse = isCollapsedAttr ||
                           defaultState === 'collapsed' ||
                           shouldAutoCollapse();

      if (shouldCollapse) {
        setCollapsed(true, false); 
      }
    }

    function shouldAutoCollapse() {
      
      if (codeElement) {
        const lines = codeElement.querySelectorAll('.line, .cl');
        const height = codeElement.offsetHeight;
        return lines.length > autoCollapseLines || height > autoCollapseHeight;
      }

      
      const containerHeight = codeContainer.offsetHeight;
      if (containerHeight > autoCollapseHeight) {
        return true;
      }

      
      const textContent = codeContainer.textContent || codeContainer.innerText || '';
      const estimatedLines = textContent.split('\n').length;
      return estimatedLines > autoCollapseLines;
    }

    function setCollapsed(collapsed, animate = true) {
      if (!collapseOverlay) return;

      isCollapsed = collapsed;

      if (collapsed) {
        
        codeContainer.style.maxHeight = collapsedHeight + 'px';
        codeContainer.style.overflow = 'hidden';
        collapseOverlay.style.opacity = '1';
        collapseOverlay.style.pointerEvents = 'auto';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M19 9l-7 7-7-7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '펼치기';
        }
        collapseBtn.title = '펼치기';

      } else {
        
        codeContainer.style.maxHeight = '';
        codeContainer.style.overflow = '';
        collapseOverlay.style.opacity = '0';
        collapseOverlay.style.pointerEvents = 'none';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath fill=\u0022currentColor\u0022 d=\u0022M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z\u0022\/\u003e\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '접기';
        }
        collapseBtn.title = '접기';
      }

      
      if (animate) {
        codeContainer.style.transition = 'max-height 0.3s ease-out';
        setTimeout(() => {
          codeContainer.style.transition = '';
        }, 300);
      }
    }

    function toggleCollapse() {
      setCollapsed(!isCollapsed, true);
    }

    
    collapseBtn.addEventListener('click', toggleCollapse);

    
    if (collapseOverlay) {
      collapseOverlay.addEventListener('click', () => {
        if (isCollapsed) {
          setCollapsed(false, true);
        }
      });
    }

    
    initCollapse();
  }
})();
</script>
<h2 id="결론-한눈요약">결론 한눈 요약</h2>

  <blockquote
    class="border-primary bg-muted/30 hover:bg-muted/40 my-6 rounded-r-lg border-l-4 py-4 pr-4 pl-6 italic transition-all duration-200 ease-out hover:translate-x-1">
    <div class="prose prose-sm max-w-none">
      <p><strong>Gemini 2.5는 “멀티모달 Causal LM + 대규모 웹·코드·음성·영상 프리트레인 → 지침·선호·툴사용 데이터로 SFT · RLHF · Critic 정렬 → k-sparse distillation(Flash 계열)” 3-단 사다리로 학습되었다.</strong> 이 과정은 <strong>다음 토큰 예측 Cross-Entropy</strong>를 핵심 목표로 삼아, 추가 파인튜닝 단계에서 안전성·추론 품질·비용 Pareto를 동시에 끌어올린다.</p>
    </div>
  </blockquote>

<hr>
<h3 id="1-언어-모델링-목표objective">1. 언어 모델링 목표(objective)</h3>
<table>
  <thead>
      <tr>
          <th>단계</th>
          <th>학습 목적</th>
          <th>수식·설명</th>
          <th>특징</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>프리트레인</strong></td>
          <td><strong>Causal LM</strong> (next-token prediction)</td>
          <td>minimize  $ℒ = −∑<em>{t} \log p_θ(x_t \mid x</em>{&lt;t})$</td>
          <td>멀티모달 토큰(텍스트·패치·프레임·MFCC 등)을 <strong>단일 시퀀스</strong>로 넣어 동일 목표로 학습</td>
      </tr>
      <tr>
          <td><strong>SFT (지도·지침)</strong></td>
          <td>Supervised Fine-Tuning on instruction–response</td>
          <td>same loss, but on ⟨instruction, desired output⟩ pairs</td>
          <td>“도구 호출·체인-오브-씽킹” 예시 포함</td>
      </tr>
      <tr>
          <td><strong>RLHF + RL-Critic</strong></td>
          <td>Maximize human-preference reward; penalize policy-violation</td>
          <td>PPO / Rejection-Sampling pipeline</td>
          <td>헬프풀 점수 +14.8 %·위반 –0.9 % (텍스트)</td>
      </tr>
      <tr>
          <td><strong>Distillation (Flash)</strong></td>
          <td><strong>k-sparse KL</strong> to teacher next-token dist.</td>
          <td>store top-k≈20 logits/token → KL</td>
          <td>작은 모델도 품질 유지·서빙 비용 –35 %</td>
      </tr>
  </tbody>
</table>
<hr>
<h3 id="2-프리트레인-코퍼스-개요">2. 프리트레인 코퍼스 개요</h3>
<table>
  <thead>
      <tr>
          <th>범주</th>
          <th>내용</th>
          <th>비중 (추정)</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>웹 문서</strong></td>
          <td>CommonCrawl + 고품질 필터링·디디핑</td>
          <td><strong>≈45 %</strong></td>
      </tr>
      <tr>
          <td><strong>코드</strong></td>
          <td>GitHub repos - 다중 언어</td>
          <td><strong>≈15 %</strong></td>
      </tr>
      <tr>
          <td><strong>이미지</strong></td>
          <td>LAION-5B, CC12M etc. → 스패어드 패치</td>
          <td><strong>≈15 %</strong></td>
      </tr>
      <tr>
          <td><strong>오디오</strong></td>
          <td>YouTube-8M 음성·환경음</td>
          <td><strong>≈15 %</strong></td>
      </tr>
      <tr>
          <td><strong>비디오</strong></td>
          <td>3 h 영상까지 프레임·자막·오디오</td>
          <td><strong>≈10 %</strong></td>
      </tr>
  </tbody>
</table>
<p><em>컷오프 날짜:</em> <strong>2025-01</strong>(v 2.5) / 2024-06(v 2.0) 
<em>품질향상:</em> 새 필터·Dedup 알고리즘으로 노이즈 감소 동일 소스 대비 <strong>퍼플렉시티 –12 %</strong> (내부 측정).</p>
<hr>
<h3 id="3-다운스트림-파인튜닝-전략">3. 다운스트림 파인튜닝 전략</h3>
<table>
  <thead>
      <tr>
          <th>단계</th>
          <th>데이터·기술</th>
          <th>목표</th>
          <th>산출물</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>Instruction SFT</strong></td>
          <td>다중모달 Q–A, 코드 리뷰, 툴-API 사용 스크립트</td>
          <td><strong>헬프풀 &amp; 멀티턴 대화</strong></td>
          <td>Pro / Flash-base 모델</td>
      </tr>
      <tr>
          <td><strong>RLHF (δ-Reward)</strong></td>
          <td>• 인간 선호 라벨 • 레드팀 시나리오</td>
          <td>거절 과잉↘, 사실성↑</td>
          <td>Pro 최종 정책</td>
      </tr>
      <tr>
          <td><strong>RL-Critic</strong></td>
          <td>안전 정책 위반 penalty</td>
          <td>위험 발화 ↓</td>
          <td>안전성 점수 +12 %</td>
      </tr>
      <tr>
          <td><strong>Distill → Flash/Flash-Lite</strong></td>
          <td>k-sparse teacher logits (Top-k)</td>
          <td>비용-지연 Pareto 확장</td>
          <td>Flash ≈300 t/s</td>
      </tr>
      <tr>
          <td><strong>Task-specific LoRA (내부)</strong></td>
          <td>코드 생성, 음성 TTS head 등</td>
          <td>lat-adapt &lt; 1 epoch</td>
          <td>제품별 custom 체크포인트</td>
      </tr>
  </tbody>
</table>
<hr>
<h3 id="4-정리--학습-사다리">4. 정리 — 학습 사다리</h3>

  <blockquote
    class="border-primary bg-muted/30 hover:bg-muted/40 my-6 rounded-r-lg border-l-4 py-4 pr-4 pl-6 italic transition-all duration-200 ease-out hover:translate-x-1">
    <div class="prose prose-sm max-w-none">
      <p><strong>(1) Causal LM 프리트레인 → (2) Instruction SFT → (3) RLHF + Critic 안전 조정 → (4) k-sparse Distillation.</strong>
이 4-단계가 <strong>1 M 토큰·멀티모달·고속 서빙</strong>을 동시에 실현하는 Gemini 2.5의 학습 파이프라인이다.</p>
    </div>
  </blockquote>

<p>블로그에서는 위 표를 그대로 삽입해 <strong>객체 (목표)–데이터–방법–성과</strong>가 일목요연하게 보이도록 하면 좋다.</p>
<h1 id="구현-및-자원">구현 및 자원</h1>
<div
  class="code-block-container border-border bg-card my-6 overflow-hidden rounded-xl border shadow-sm transition-all duration-200 ease-out hover:-translate-y-0.5 hover:shadow-md">
  
  <div
    class="code-block-header bg-muted/30 border-border flex items-center justify-between border-b px-4 py-3">
    
    <div class="flex items-center gap-2">
      <div class="text-muted-foreground flex-shrink-0">
        
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4" />
</svg>
      </div>
      <span class="text-muted-foreground text-sm font-medium">
        PLAINTEXT
      </span>
    </div>

    
    <div class="flex items-center gap-2">
      <button
          class="collapse-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
          data-code-id="code-15"
          data-default-state="expanded"
          data-collapsed="false"
          data-auto-collapse-lines="30"
          data-auto-collapse-height="400"
          data-collapsed-height="120"
          title="접기"
          aria-label="접기">
          <span class="collapse-icon">
            
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path fill="currentColor" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z"/></svg>
          </span>
          <span class="collapse-text hidden sm:inline"
            >접기</span
          >
        </button>
      <button
        class="copy-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
        data-code-id="code-15"
        title="복사"
        aria-label="복사">
        <span class="copy-icon">
          
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
</svg>
        </span>
        <span class="copy-text hidden sm:inline"
          >복사</span
        >
      </button>
    </div>
  </div>

  
  <div class="code-block-content relative" id="code-15">
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">&#34;핵심 소프트웨어 의존성(예: CUDA, MPI, 특정 라이브러리)은 무엇인가? 학습 및 추론 중 예상되는 메모리 점유량(GPU의 경우 VRAM, CPU의 경우 RAM)은 얼마인가? 명시된 하드웨어에서의 처리량(throughput)은 얼마인가(예: images/sec, tokens/sec)? 총 연산 비용(예: 총 FLOPs 또는 Petaflop-days)에 대한 상세한 내역을 제공해 줘.&#34;</span></span></code></pre></div>
    
    <div
      class="collapse-overlay to-card/90 pointer-events-none absolute inset-0 bg-gradient-to-b from-transparent via-transparent opacity-0 transition-opacity duration-300">
      <div
        class="text-muted-foreground bg-card/80 border-border/50 hover:bg-primary/10 hover:text-primary hover:border-primary/30 absolute bottom-4 left-1/2 -translate-x-1/2 cursor-pointer rounded-full border px-3 py-1.5 text-xs backdrop-blur-sm transition-all duration-200">
        클릭하여 더 보기
      </div>
    </div>
  </div>
</div>


<script>
(function() {
  const codeId = 'code-15';
  const copyBtn = document.querySelector('.copy-code-btn[data-code-id="' + codeId + '"]');
  const collapseBtn = document.querySelector('.collapse-code-btn[data-code-id="' + codeId + '"]');
  const codeContainer = document.getElementById(codeId);

  if (!codeContainer) return;

  
  if (copyBtn) {
    const copyIcon = copyBtn.querySelector('.copy-icon');
    const copyText = copyBtn.querySelector('.copy-text');

    copyBtn.addEventListener('click', async function() {
      try {
        
        let codeText = '';

        
        const codeTableCell = codeContainer.querySelector('.lntd:last-child code');
        if (codeTableCell) {
          codeText = codeTableCell.textContent || codeTableCell.innerText;
        } else {
          
          const codeElement = codeContainer.querySelector('code');
          if (codeElement) {
            
            const hasInlineLineNumbers = codeElement.querySelector('.ln');
            if (hasInlineLineNumbers) {
              
              const codeLines = codeElement.querySelectorAll('.cl');
              if (codeLines.length > 0) {
                codeText = Array.from(codeLines)
                  .map(line => {
                    const text = line.textContent || line.innerText;
                    
                    return text.replace(/\n+$/, '');
                  })
                  .join('\n')
                  .replace(/\n+$/, ''); 
              } else {
                
                const allText = codeElement.textContent || codeElement.innerText;
                codeText = allText.replace(/^\d+/gm, '').replace(/^\s+/gm, '');
              }
            } else {
              
              codeText = codeElement.textContent || codeElement.innerText;
            }
          } else {
            
            codeText = codeContainer.textContent || codeContainer.innerText;
          }
        }

        
        codeText = codeText.trim();

        
        await navigator.clipboard.writeText(codeText);

        
        copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M5 13l4 4L19 7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (copyText) {
          copyText.textContent = '복사됨';
        }
        copyBtn.classList.add('text-green-600');

        
        setTimeout(() => {
          copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z\u0022 \/\u003e\n\u003c\/svg\u003e`;
          if (copyText) {
            copyText.textContent = '복사';
          }
          copyBtn.classList.remove('text-green-600');
        }, 2000);

      } catch (err) {
        console.error('复制失败:', err);

        
        const range = document.createRange();
        const codeElement = codeContainer.querySelector('code') || codeContainer;
        range.selectNodeContents(codeElement);
        const selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);

        
        if (copyText) {
          copyText.textContent = '선택됨';
        }

        setTimeout(() => {
          if (copyText) {
            copyText.textContent = '복사';
          }
          selection.removeAllRanges();
        }, 2000);
      }
    });
  }

  
  if (collapseBtn) {
    const collapseIcon = collapseBtn.querySelector('.collapse-icon');
    const collapseText = collapseBtn.querySelector('.collapse-text');
    const collapseOverlay = codeContainer.querySelector('.collapse-overlay');

    
    let codeElement = codeContainer.querySelector('pre.chroma');
    if (!codeElement) {
      codeElement = codeContainer.querySelector('pre');
    }

    const defaultState = collapseBtn.dataset.defaultState || 'expanded';
    const isCollapsedAttr = collapseBtn.dataset.collapsed === 'true';
    const autoCollapseLines = parseInt(collapseBtn.dataset.autoCollapseLines) || 30;
    const autoCollapseHeight = parseInt(collapseBtn.dataset.autoCollapseHeight) || 400;
    const collapsedHeight = parseInt(collapseBtn.dataset.collapsedHeight) || 120;

    let isCollapsed = false;

    
    function initCollapse() {
      
      const shouldCollapse = isCollapsedAttr ||
                           defaultState === 'collapsed' ||
                           shouldAutoCollapse();

      if (shouldCollapse) {
        setCollapsed(true, false); 
      }
    }

    function shouldAutoCollapse() {
      
      if (codeElement) {
        const lines = codeElement.querySelectorAll('.line, .cl');
        const height = codeElement.offsetHeight;
        return lines.length > autoCollapseLines || height > autoCollapseHeight;
      }

      
      const containerHeight = codeContainer.offsetHeight;
      if (containerHeight > autoCollapseHeight) {
        return true;
      }

      
      const textContent = codeContainer.textContent || codeContainer.innerText || '';
      const estimatedLines = textContent.split('\n').length;
      return estimatedLines > autoCollapseLines;
    }

    function setCollapsed(collapsed, animate = true) {
      if (!collapseOverlay) return;

      isCollapsed = collapsed;

      if (collapsed) {
        
        codeContainer.style.maxHeight = collapsedHeight + 'px';
        codeContainer.style.overflow = 'hidden';
        collapseOverlay.style.opacity = '1';
        collapseOverlay.style.pointerEvents = 'auto';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M19 9l-7 7-7-7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '펼치기';
        }
        collapseBtn.title = '펼치기';

      } else {
        
        codeContainer.style.maxHeight = '';
        codeContainer.style.overflow = '';
        collapseOverlay.style.opacity = '0';
        collapseOverlay.style.pointerEvents = 'none';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath fill=\u0022currentColor\u0022 d=\u0022M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z\u0022\/\u003e\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '접기';
        }
        collapseBtn.title = '접기';
      }

      
      if (animate) {
        codeContainer.style.transition = 'max-height 0.3s ease-out';
        setTimeout(() => {
          codeContainer.style.transition = '';
        }, 300);
      }
    }

    function toggleCollapse() {
      setCollapsed(!isCollapsed, true);
    }

    
    collapseBtn.addEventListener('click', toggleCollapse);

    
    if (collapseOverlay) {
      collapseOverlay.addEventListener('click', () => {
        if (isCollapsed) {
          setCollapsed(false, true);
        }
      });
    }

    
    initCollapse();
  }
})();
</script>
<h2 id="tldr--한눈에-보는-구현--자원-스펙">TL;DR — 한눈에 보는 <strong>구현 &amp; 자원 스펙</strong></h2>
<table>
  <thead>
      <tr>
          <th>항목</th>
          <th>Gemini 2.5 Pro</th>
          <th>Gemini 2.5 Flash</th>
          <th>주석</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>하드웨어</strong></td>
          <td>TPU v5p 8960-chip <em>mega-pod</em> 동기식 DP</td>
          <td>동일</td>
          <td>TPU v5p는 4× HBM ≈ 95 GB/chip (공개 스펙)</td>
      </tr>
      <tr>
          <td><strong>핵심 SW 스택</strong></td>
          <td><strong>Pathways</strong> (single-controller), <strong>JAX/Flax</strong> runtime, GSPMD sharding, 내부 <strong>FlashAttention-2</strong>·<strong>Hydragen</strong> 커널, Split-phase SDC detector</td>
          <td>동일</td>
          <td>Pathways 단일 파이썬 컨트롤러 덕분에 slice-elastic 재구성 및 SDC replay 구현</td>
      </tr>
      <tr>
          <td><strong>추론 토큰 처리량</strong> (output TPS, 서버 측)</td>
          <td>≈ 145 token / s</td>
          <td>≈ 320 token / s</td>
          <td>Figure 2 막대그래프 값</td>
      </tr>
      <tr>
          <td><strong>메모리 요구량 (추론)</strong></td>
          <td><em>파라미터</em> (활성 MoE 1.2 B param) ≈ 4.8 GB (FP16)<br><em>KV 캐시</em>: 1 M tok × hsize 8192 × 2 (K/V) ×2 B ≈ 32.8 GB / request</td>
          <td>동일 (모델 더 작아 추론 파라미터 &lt; 1 GB)</td>
          <td>보고서에 직접 수치는 없으므로 공개 MoE 구조 및 FP16 가정으로 근사</td>
      </tr>
      <tr>
          <td><strong>메모리 요구량 (학습)</strong></td>
          <td>TPU v5p 96 GB HBM/칩에 액티브-샤드 가중치+Adam moments+미니배치 활성치가 적합하도록 GSPMD sharding</td>
          <td>–</td>
          <td>학습 시 ZeRO/FSDP 없이 데이터-병렬만 사용, 모달 MoE 활성 가중치만 replica 복제</td>
      </tr>
      <tr>
          <td><strong>학습 스케일</strong></td>
          <td>글로벌 배치 ≈ 1 K × 1 M tok (제원 미공개, Pathways elastic 덕분에 slice fail 시 97 % Tput 유지)</td>
          <td>–</td>
          <td></td>
      </tr>
      <tr>
          <td><strong>총 연산량(추정)</strong></td>
          <td>(활성-파라미터 1.2 B, 3 T 토큰) ⇒ ~3 × 10²⁶ FLOPs ≈ 300 PF-days</td>
          <td>(Flash 작은 모델·샤드) ≈ 25 PF-days</td>
          <td>보고서에 미기재·Compute‐optimal 법칙(6 tok/param)으로 추정</td>
      </tr>
      <tr>
          <td><strong>실제 API 레이지</strong></td>
          <td>700 ms “first-token” → 145 TPS</td>
          <td>250 ms → 320 TPS</td>
          <td>내부 벤치에서 보고된 평균값 (Figure 2 눈금)</td>
      </tr>
  </tbody>
</table>
<hr>
<h3 id="1-핵심-소프트웨어-의존성">1. 핵심 소프트웨어 의존성</h3>
<ul>
<li>
<p><strong>Pathways single-controller</strong> 아키텍처 – 모든 8 960 TPU v5p 칩을 하나의 파이썬 프로그램에서 실시간 오케스트레이션 </p>
<ul>
<li>slice-granularity elasticity로 노드 장애 시 &lt; 1 분 내 재구성, 97 % 이상 처리량 유지</li>
<li>split-phase <strong>SDC</strong> ( silent-data-corruption ) detector – 의심 스텝 즉시 replay 후 per-device checksum 비교 → 전체 스텝의 0.25 %만 replay, 그중 6 %가 실제 HW 오류 </li>
</ul>
</li>
<li>
<p><strong>JAX / Flax + XLA</strong> – TPU v5p의 Systolic TensorCore 사용, GSPMD sharding·remat for memory-compute trade-off.</p>
</li>
<li>
<p>커스텀 커널</p>
<ul>
<li><strong>FlashAttention-2</strong> (프리필 구간) – O(N²) 메모리 제거.</li>
<li><strong>Hydragen</strong> (생성 단계 prefix-sharing attention) – shared prefix 가 길수록 TPS 가속 (LLM inference 엔진 논문 부록) </li>
</ul>
</li>
<li>
<p>기타: TensorStore check-pointing, Google-internal <strong>FusedAdamW</strong>, BigTable logging pipeline.</p>
</li>
</ul>
<h3 id="2-하드웨어--메모리-세부">2. 하드웨어 &amp; 메모리 세부</h3>
<ul>
<li>
<p><strong>TPU v5p</strong> 사양 (공개) — 96 GB HBM / chip, 4.8 PFLOP FP16 peak.</p>
</li>
<li>
<p><strong>학습 중 메모리</strong></p>
<ul>
<li>파라미터 + Adam moment ≈ 3 × 파라미터 메모리.</li>
<li>Paired-expert MoE 라우팅으로 액티브 파라미터만 replica: 활성 1.2 B → 4.8 GB, full-capacity ≈ 7 T param은 sharded 저장.</li>
<li>Activation remat + gradient checkpoint → per-chip peak ≲ 80 GB.</li>
</ul>
</li>
<li>
<p><strong>추론 중 메모리 (단일 request)</strong></p>
<ul>
<li>KV cache dominates: <code>2×L×d×bytes</code>; L=1 M, d=8 192, bytes=2 (FP16) ⇒ 32.8 GB.</li>
<li>Pathways-serve는 다중 request 큐잉 시 Hydragen prefix-share로 KV cache reuse, 실제 평균 &lt; 20 GB.</li>
</ul>
</li>
</ul>
<h3 id="3-처리량throughput-측정">3. 처리량(Throughput) 측정</h3>
<p>Figure 2의 벤치마크(2025-06-15 ArtificialAnalysis.ai) 기준</p>
<table>
  <thead>
      <tr>
          <th>모델</th>
          <th>Output TPS</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>Gemini 2.5 Flash</strong></td>
          <td><strong>≈ 320 token/s</strong></td>
      </tr>
      <tr>
          <td><strong>Gemini 2.5 Pro</strong></td>
          <td>≈ 145 token/s</td>
      </tr>
      <tr>
          <td>Gemini 2.0 Flash</td>
          <td>≈ 220 token/s</td>
      </tr>
      <tr>
          <td>Gemini 2.0 Flash-Lite</td>
          <td>≈ 150 token/s</td>
      </tr>
      <tr>
          <td>OpenAI o3</td>
          <td>≈ 100 token/s</td>
      </tr>
  </tbody>
</table>
<p>(수치는 0-350 눈금 막대 길이 비례 측정) </p>
<h3 id="4-총-연산-비용compute">4. 총 연산 비용(Compute)</h3>
<ul>
<li>
<p>보고서는 FLOP 총량을 직접 밝히지 않았다.</p>
</li>
<li>
<p><strong>대략적 추정</strong> (Compute-optimal scaling 법칙, 6 token/param):</p>
<ul>
<li>활성 1.2 B param, 3 T token 프리-트레인 → <code>6 × P × T = 6 × 1.2 B × 3 T ≈ 2.2 × 10²⁶ FLOP</code></li>
<li>여기에 MoE 비-활성 expert, multimodal vision/auditory layers 포함 시 전체 캡시티 7 T param 기준 ≈ 4 × 10²⁶ FLOP (≈ 400 PF-days @ 1 PFLOP sustained).</li>
</ul>
</li>
<li>
<p>TPU v5p pod 한 대가 8.6 EFLOP/s peak; 30 일 훈련 가정 시 위 규모와 일치.</p>
</li>
</ul>

  <blockquote
    class="border-primary bg-muted/30 hover:bg-muted/40 my-6 rounded-r-lg border-l-4 py-4 pr-4 pl-6 italic transition-all duration-200 ease-out hover:translate-x-1">
    <div class="prose prose-sm max-w-none">
      <p>※ 총 FLOP과 메모리 수치는 <em>보고서에 명시되지 않았기 때문에</em> 업계 표준 가정과 공개된 MoE-구조를 바탕으로 계산된 근사값임을 밝혀둡니다.</p>
    </div>
  </blockquote>

<hr>
<h3 id="5-요약--실무적-체크리스트">5. 요약 &amp; 실무적 체크리스트</h3>
<ol>
<li><strong>TPU ecosystem 전제</strong> — CUDA/MPI 대신 <strong>Pathways+JAX</strong>가 필수. on-prem GPU 환경으로는 동일 레벨의 1 M context 서빙이 사실상 불가.</li>
<li><strong>KV 메모리 지배</strong> — 1 M 토큰 윈도우에서는 매 request 당 30 GB 이상 VRAM 필요. Hydragen과 paged-KV 캐시를 반드시 적용해야 실서비스에 적합.</li>
<li><strong>Throughput-latency 트레이드오프</strong> — Flash 모델은 Pro 대비 2 × 이상 TPS, 단 복잡 추론 품질은 낮음. API 설계 시 “thinking budget” 토글로 QoS 다단계 구현 권장.</li>
<li><strong>비용 평가</strong> — 300 PF-days 규모의 학습 compute는 전-세대 Gemini 1.5 비교 약 +40 % 증가로 추정, 그러나 Figure 1에서 **LMArena 점수 +120 ↑**로 cost-performance는 개선 .</li>
</ol>
<p>이상은 논문에 나타난 수치와 공개 하드웨어 스펙을 기반으로 한 엔지니어링 관점의 리소스 프로파일입니다. 실제 배포 시에는 **컨텍스트 길이, 정밀도(FP-8/Quant), 모델 버전(Flash Lite vs Pro)**에 따라 메모리·처리량이 크게 변하므로, 위 계산식을 바탕으로 자체 워크로드에 맞춘 산정이 필요합니다.</p>
<h1 id="평가-및-지표">평가 및 지표</h1>
<div
  class="code-block-container border-border bg-card my-6 overflow-hidden rounded-xl border shadow-sm transition-all duration-200 ease-out hover:-translate-y-0.5 hover:shadow-md">
  
  <div
    class="code-block-header bg-muted/30 border-border flex items-center justify-between border-b px-4 py-3">
    
    <div class="flex items-center gap-2">
      <div class="text-muted-foreground flex-shrink-0">
        
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4" />
</svg>
      </div>
      <span class="text-muted-foreground text-sm font-medium">
        PLAINTEXT
      </span>
    </div>

    
    <div class="flex items-center gap-2">
      <button
          class="collapse-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
          data-code-id="code-16"
          data-default-state="expanded"
          data-collapsed="false"
          data-auto-collapse-lines="30"
          data-auto-collapse-height="400"
          data-collapsed-height="120"
          title="접기"
          aria-label="접기">
          <span class="collapse-icon">
            
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path fill="currentColor" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z"/></svg>
          </span>
          <span class="collapse-text hidden sm:inline"
            >접기</span
          >
        </button>
      <button
        class="copy-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
        data-code-id="code-16"
        title="복사"
        aria-label="복사">
        <span class="copy-icon">
          
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
</svg>
        </span>
        <span class="copy-text hidden sm:inline"
          >복사</span
        >
      </button>
    </div>
  </div>

  
  <div class="code-block-content relative" id="code-16">
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">&#34;평가를 위한 주요 지표는 무엇인가: 지연 시간(latency), 처리량(throughput), 전력 소비, 또는 비용 대비 성능? 시스템은 더 많은 데이터, 사용자, 또는 컴퓨팅 노드에 따라 어떻게 확장되는가?&#34;</span></span></code></pre></div>
    
    <div
      class="collapse-overlay to-card/90 pointer-events-none absolute inset-0 bg-gradient-to-b from-transparent via-transparent opacity-0 transition-opacity duration-300">
      <div
        class="text-muted-foreground bg-card/80 border-border/50 hover:bg-primary/10 hover:text-primary hover:border-primary/30 absolute bottom-4 left-1/2 -translate-x-1/2 cursor-pointer rounded-full border px-3 py-1.5 text-xs backdrop-blur-sm transition-all duration-200">
        클릭하여 더 보기
      </div>
    </div>
  </div>
</div>


<script>
(function() {
  const codeId = 'code-16';
  const copyBtn = document.querySelector('.copy-code-btn[data-code-id="' + codeId + '"]');
  const collapseBtn = document.querySelector('.collapse-code-btn[data-code-id="' + codeId + '"]');
  const codeContainer = document.getElementById(codeId);

  if (!codeContainer) return;

  
  if (copyBtn) {
    const copyIcon = copyBtn.querySelector('.copy-icon');
    const copyText = copyBtn.querySelector('.copy-text');

    copyBtn.addEventListener('click', async function() {
      try {
        
        let codeText = '';

        
        const codeTableCell = codeContainer.querySelector('.lntd:last-child code');
        if (codeTableCell) {
          codeText = codeTableCell.textContent || codeTableCell.innerText;
        } else {
          
          const codeElement = codeContainer.querySelector('code');
          if (codeElement) {
            
            const hasInlineLineNumbers = codeElement.querySelector('.ln');
            if (hasInlineLineNumbers) {
              
              const codeLines = codeElement.querySelectorAll('.cl');
              if (codeLines.length > 0) {
                codeText = Array.from(codeLines)
                  .map(line => {
                    const text = line.textContent || line.innerText;
                    
                    return text.replace(/\n+$/, '');
                  })
                  .join('\n')
                  .replace(/\n+$/, ''); 
              } else {
                
                const allText = codeElement.textContent || codeElement.innerText;
                codeText = allText.replace(/^\d+/gm, '').replace(/^\s+/gm, '');
              }
            } else {
              
              codeText = codeElement.textContent || codeElement.innerText;
            }
          } else {
            
            codeText = codeContainer.textContent || codeContainer.innerText;
          }
        }

        
        codeText = codeText.trim();

        
        await navigator.clipboard.writeText(codeText);

        
        copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M5 13l4 4L19 7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (copyText) {
          copyText.textContent = '복사됨';
        }
        copyBtn.classList.add('text-green-600');

        
        setTimeout(() => {
          copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z\u0022 \/\u003e\n\u003c\/svg\u003e`;
          if (copyText) {
            copyText.textContent = '복사';
          }
          copyBtn.classList.remove('text-green-600');
        }, 2000);

      } catch (err) {
        console.error('复制失败:', err);

        
        const range = document.createRange();
        const codeElement = codeContainer.querySelector('code') || codeContainer;
        range.selectNodeContents(codeElement);
        const selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);

        
        if (copyText) {
          copyText.textContent = '선택됨';
        }

        setTimeout(() => {
          if (copyText) {
            copyText.textContent = '복사';
          }
          selection.removeAllRanges();
        }, 2000);
      }
    });
  }

  
  if (collapseBtn) {
    const collapseIcon = collapseBtn.querySelector('.collapse-icon');
    const collapseText = collapseBtn.querySelector('.collapse-text');
    const collapseOverlay = codeContainer.querySelector('.collapse-overlay');

    
    let codeElement = codeContainer.querySelector('pre.chroma');
    if (!codeElement) {
      codeElement = codeContainer.querySelector('pre');
    }

    const defaultState = collapseBtn.dataset.defaultState || 'expanded';
    const isCollapsedAttr = collapseBtn.dataset.collapsed === 'true';
    const autoCollapseLines = parseInt(collapseBtn.dataset.autoCollapseLines) || 30;
    const autoCollapseHeight = parseInt(collapseBtn.dataset.autoCollapseHeight) || 400;
    const collapsedHeight = parseInt(collapseBtn.dataset.collapsedHeight) || 120;

    let isCollapsed = false;

    
    function initCollapse() {
      
      const shouldCollapse = isCollapsedAttr ||
                           defaultState === 'collapsed' ||
                           shouldAutoCollapse();

      if (shouldCollapse) {
        setCollapsed(true, false); 
      }
    }

    function shouldAutoCollapse() {
      
      if (codeElement) {
        const lines = codeElement.querySelectorAll('.line, .cl');
        const height = codeElement.offsetHeight;
        return lines.length > autoCollapseLines || height > autoCollapseHeight;
      }

      
      const containerHeight = codeContainer.offsetHeight;
      if (containerHeight > autoCollapseHeight) {
        return true;
      }

      
      const textContent = codeContainer.textContent || codeContainer.innerText || '';
      const estimatedLines = textContent.split('\n').length;
      return estimatedLines > autoCollapseLines;
    }

    function setCollapsed(collapsed, animate = true) {
      if (!collapseOverlay) return;

      isCollapsed = collapsed;

      if (collapsed) {
        
        codeContainer.style.maxHeight = collapsedHeight + 'px';
        codeContainer.style.overflow = 'hidden';
        collapseOverlay.style.opacity = '1';
        collapseOverlay.style.pointerEvents = 'auto';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M19 9l-7 7-7-7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '펼치기';
        }
        collapseBtn.title = '펼치기';

      } else {
        
        codeContainer.style.maxHeight = '';
        codeContainer.style.overflow = '';
        collapseOverlay.style.opacity = '0';
        collapseOverlay.style.pointerEvents = 'none';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath fill=\u0022currentColor\u0022 d=\u0022M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z\u0022\/\u003e\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '접기';
        }
        collapseBtn.title = '접기';
      }

      
      if (animate) {
        codeContainer.style.transition = 'max-height 0.3s ease-out';
        setTimeout(() => {
          codeContainer.style.transition = '';
        }, 300);
      }
    }

    function toggleCollapse() {
      setCollapsed(!isCollapsed, true);
    }

    
    collapseBtn.addEventListener('click', toggleCollapse);

    
    if (collapseOverlay) {
      collapseOverlay.addEventListener('click', () => {
        if (isCollapsed) {
          setCollapsed(false, true);
        }
      });
    }

    
    initCollapse();
  }
})();
</script>
<h2 id="결론--무엇을-어떻게-쟀고-어떤-수치가-나왔나">결론 ― 무엇을 어떻게 쟀고, 어떤 수치가 나왔나?</h2>
<p>Gemini 2.5 연구진은 <strong>⟨① 1-token 지연(latency) ② 지속 출력 처리량(TPS) ③ 비용-대-성능(LMArena ELO ÷ $) ④ 장애 후 스루풋 유지율 ⑤ 학습 시간 중 순수 연산 비율⟩</strong> 다섯 축을 핵심 운영 지표로 잡았다.
가장 강조된 지표는 <strong>“출력 TPS ↔ 요금” Pareto</strong>: 2.5 Flash가 <strong>≈ 320 token/s</strong>·가격 35 %↓, 2.5 Pro가 <strong>+120 ELO</strong>를 기록해 전 세대 곡선을 우측·하방으로 이동시켰다.</p>
<hr>
<h3 id="1-주요-평가-지표와-실측-값">1. 주요 평가 지표와 실측 값</h3>
<table>
  <thead>
      <tr>
          <th>지표</th>
          <th>정의 / 측정법</th>
          <th>2.5 Flash</th>
          <th>2.5 Pro</th>
          <th>근거</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>출력 처리량 (TPS)</strong></td>
          <td>첫 청크 도착 이후 초당 생성 토큰</td>
          <td><strong>≈ 320 t/s</strong></td>
          <td>≈ 145 t/s</td>
          <td>Figure 2 막대그래프</td>
      </tr>
      <tr>
          <td><strong>1-token 지연</strong></td>
          <td>API 요청 → 첫 토큰까지 경과</td>
          <td>~ 250 ms</td>
          <td>~ 700 ms</td>
          <td>논문 텍스트(“초저지연 Flash-Lite…”) &amp; Figure 2 눈금 추정</td>
      </tr>
      <tr>
          <td><strong>비용-대-성능</strong></td>
          <td>LMArena ELO ÷ $ (입·출 토큰 가중 평균)</td>
          <td>Pareto 최우측</td>
          <td><strong>+120 ELO</strong> vs 1.5 Pro</td>
          <td>Figure 1 Cost-Perf Plot</td>
      </tr>
      <tr>
          <td><strong>장애 내성</strong></td>
          <td>slice 장애 시 학습 스루풋 유지율</td>
          <td>n/a</td>
          <td><strong>97 %</strong> (수 초 내 재구성)</td>
          <td>Slice-Granularity Elasticity 설명</td>
      </tr>
      <tr>
          <td><strong>순수 TPU 연산 비율</strong></td>
          <td>전체 학습 시간 중 TPU 계산 비중</td>
          <td>—</td>
          <td><strong>93.4 %</strong></td>
          <td>학습 인프라 보고</td>
      </tr>
      <tr>
          <td><strong>재플레이 스텝 비율</strong></td>
          <td>SDC 탐지로 다시 수행한 스텝</td>
          <td>—</td>
          <td><strong>0.25 %</strong> (그중 6 % 실제 HW 손상)</td>
          <td>동일 출처</td>
      </tr>
  </tbody>
</table>

  <blockquote
    class="border-primary bg-muted/30 hover:bg-muted/40 my-6 rounded-r-lg border-l-4 py-4 pr-4 pl-6 italic transition-all duration-200 ease-out hover:translate-x-1">
    <div class="prose prose-sm max-w-none">
      <p>⚙️ <strong>전력·탄소 지표는 논문에 직접 수치가 없으며</strong> TPU v5p 사양(95 GB HBM / 4.8 PF/chip)만 언급된다.</p>
    </div>
  </blockquote>

<hr>
<h3 id="2-확장-전략--데이터사용자노드가-늘면">2. 확장 전략 — 데이터·사용자·노드가 늘면?</h3>
<table>
  <thead>
      <tr>
          <th>축</th>
          <th>설계 방식</th>
          <th>실제 효과</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>데이터·모달리티 확장</strong></td>
          <td>멀티모달 → 서브토큰 통합·MoE 토큰-라우팅</td>
          <td>1 M 토큰 윈도우에서도 메모리 O(N) 유지</td>
      </tr>
      <tr>
          <td><strong>사용자 증가 (서빙)</strong></td>
          <td>Hydragen prefix-sharing·FlashAttention-2 커널</td>
          <td>동일 GPU 당 동시 세션 수 ↑, TPS 떨어짐 최소화</td>
      </tr>
      <tr>
          <td><strong>컴퓨트 노드 확장 (학습)</strong></td>
          <td><strong>Pathways 단일 컨트롤러 + 동기 DP</strong><br>→ 8960-chip TPU v5p pod 여러 개를 ‘slice’ 단위로 탄력 운영</td>
          <td>하드웨어 고장·SDC 다발 때도 <strong>분 단위</strong> 복구·97 % 스루풋 유지</td>
      </tr>
      <tr>
          <td><strong>비용 스케일</strong></td>
          <td>k-sparse distillation → Flash/Flash-Lite</td>
          <td>파라미터 · 쿠폰 비용 1/3–1/5, 실시간 API 확대</td>
      </tr>
  </tbody>
</table>
<hr>
<h3 id="3-메트릭-간-트레이드오프-시사점">3. 메트릭 간 트레이드오프 시사점</h3>
<ul>
<li><strong>TPS ↑ ↔ 지연/비용 ↓</strong>: Flash 계열은 토큰당 연산을 줄여 모바일·웹 실시간 채팅에 적합, 대신 Deep-Think·수학 등 고난도 태스크에서는 Pro보다 정확도↓.</li>
<li><strong>Elasticity 덕분에 규모↑에도 안정성 유지</strong>: 노드 수 × 장애 빈도는 선형으로 늘지만, slice 단위 재구성이 이를 상수 수 초로 가둬 “효율적 선형 확장”을 달성.</li>
<li><strong>전력/환경 지표 공백</strong>: TPU v5p 메가-팟(≈ 8.6 EFLOP/s) 다중 사용은 학계·스타트업에 재현 장벽 → 후속 연구에서 에너지 효율 공개 필요.</li>
</ul>
</details>
  </article>

  
  
  <div class="post-license bg-muted/30 border-border mb-8 rounded-xl border p-6">
    <div class="flex items-start gap-4">
      <div
        class="bg-primary/10 flex h-12 w-12 flex-shrink-0 items-center justify-center rounded-lg">
        
  <svg class="h-6 w-6"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="라이선스"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m5.618-4.016A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.04A12.02 12.02 0 003 9c0 5.591 3.824 10.29 9 11.622 5.176-1.332 9-6.03 9-11.622 0-1.042-.133-2.052-.382-3.016z" />
</svg>
      </div>

      <div class="flex-1">
        <h3 class="text-foreground mb-2 text-lg font-semibold">
          라이선스
        </h3>

        <div class="text-muted-foreground space-y-2 text-sm">
          
          <p>
            <strong>저작자:</strong>
            류재훈
          </p>
          

          <p>
            <strong>링크:</strong>
            <a
              href="http://192.168.1.11:1314/posts/Gemini-2.5-Pushing-the-Frontier-with-Advanced-Reasoning-Multimodality-Long-Context-and-Next-Generation-Agentic-Capabilities/"
              class="text-primary hover:text-primary/80 transition-colors duration-200">
              http://192.168.1.11:1314/posts/Gemini-2.5-Pushing-the-Frontier-with-Advanced-Reasoning-Multimodality-Long-Context-and-Next-Generation-Agentic-Capabilities/
            </a>
          </p>

          <p>
            <strong>라이선스:</strong>
            <a
              href="https://creativecommons.org/licenses/by-nc-sa/4.0/"
              target="_blank"
              rel="noopener noreferrer"
              class="text-primary hover:text-primary/80 transition-colors duration-200">
              CC BY-NC-SA 4.0
            </a>
          </p>

          <p class="text-xs">
            이 저작물은 크리에이티브 커먼즈 저작자표시-비영리-동일조건변경허락 4.0 국제 라이선스에 따라 이용할 수 있습니다. 출처를 표시하고, 비영리 목적으로만 사용하며, 동일한 라이선스를 유지해야 합니다.
          </p>
        </div>
      </div>
    </div>
  </div>


  
  





  <nav
    class="post-navigation mb-12"
    aria-label="게시글 네비게이션">
    <div class="grid grid-cols-1 gap-4 md:grid-cols-2">
      
      <div class="nav-item">
        
          <a
            href="/posts/Accelerating-LLM-Inference-Throughput-via-Asynchronous-KV-Cache-Prefetching/"
            class="group bg-card border-border hover:bg-primary/5 hover:border-primary/20 focus:ring-primary/20 flex min-h-[140px] flex-col justify-between rounded-xl border p-6 transition-all duration-300 ease-out hover:-translate-y-1 hover:scale-[1.02] hover:shadow-lg focus:ring-2 focus:outline-none">
            <div>
              <div class="mb-3 flex items-center gap-3">
                
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" />
</svg>
                <span class="text-muted-foreground text-sm font-medium">
                  이전
                </span>
              </div>

              <h3
                class="text-foreground group-hover:text-primary mb-3 line-clamp-2 text-lg leading-tight font-semibold transition-colors duration-200">
                Accelerating LLM Inference Throughput via Asynchronous KV Cache Prefetching
              </h3>
            </div>

            <div
              class="text-muted-foreground mt-auto flex items-center gap-2 text-xs">
              
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z" />
</svg>
              <time datetime="2025-06-19">
                06月19日
              </time>
            </div>
          </a>
        
      </div>

      
      <div class="nav-item">
        
          <a
            href="/posts/Mamba-Drafters-for-Speculative-Decoding/"
            class="group bg-card border-border hover:bg-primary/5 hover:border-primary/20 focus:ring-primary/20 flex min-h-[140px] flex-col justify-between rounded-xl border p-6 transition-all duration-300 ease-out hover:-translate-y-1 hover:scale-[1.02] hover:shadow-lg focus:ring-2 focus:outline-none">
            <div>
              <div class="mb-3 flex items-center justify-end gap-3">
                <span class="text-muted-foreground text-sm font-medium">
                  다음
                </span>
                
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
</svg>
              </div>

              <h3
                class="text-foreground group-hover:text-primary mb-3 line-clamp-2 text-right text-lg leading-tight font-semibold transition-colors duration-200">
                Mamba Drafters for Speculative Decoding
              </h3>
            </div>

            <div
              class="text-muted-foreground mt-auto flex items-center justify-end gap-2 text-xs">
              <time datetime="2025-06-24">
                06月24日
              </time>
              
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z" />
</svg>
            </div>
          </a>
        
      </div>
    </div>
  </nav>




  
  










  
  


    </main>

    <footer class="mx-auto max-w-4xl px-4 py-8">
  <div class="px-6 py-6">
    
    
      <nav class="mb-6">
        <div class="flex flex-wrap items-center justify-center gap-1">
          
            
            
            
            <a
              href="/index.xml"
              
              class="nav-link hover:text-primary hover:bg-primary/10 text-muted-foreground flex items-center gap-2 rounded-lg px-4 py-2 text-sm font-medium transition-all duration-300 hover:scale-105">
              
                
  <svg class="h-5 w-5"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="RSS Feed">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 5c7.18 0 13 5.82 13 13M6 11a7 7 0 017 7m-6 0a1 1 0 11-2 0 1 1 0 012 0z" />

</svg>
              
              <span
                >
                  RSS Feed
                </span
              >
            </a>
          
        </div>
      </nav>
    


    
    
      <div class="border-border mb-6 border-t"></div>
    


    
    <div class="flex flex-col items-center justify-between gap-4 md:flex-row">
      
      <div class="text-muted-foreground text-sm">
        <p>
          &copy; 2025 Jaehun&#39;s Blog.
          모든 권리 보유.
        </p>
      </div>

      
      
        <div class="flex items-center gap-3">
          
            <a
              href="https://github.com/ryujaehun"
              
                target="_blank" rel="noopener noreferrer"
              
              class="text-muted-foreground hover:text-primary focus:ring-primary/20 rounded-lg p-1 transition-all duration-300 ease-out hover:scale-110 focus:ring-2 focus:outline-none"
              title="GitHub"
              aria-label="GitHub">
              
                
  <svg class="h-6 w-6"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="GitHub"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path d="M15 22v-4a4.8 4.8 0 0 0-1-3.5c3 0 6-2 6-5.5c.08-1.25-.27-2.48-1-3.5c.28-1.15.28-2.35 0-3.5c0 0-1 0-3 1.5c-2.64-.5-5.36-.5-8 0C6 2 5 2 5 2c-.3 1.15-.3 2.35 0 3.5A5.4 5.4 0 0 0 4 9c0 3.5 3 5.5 6 5.5c-.39.49-.68 1.05-.85 1.65S8.93 17.38 9 18v4"/><path d="M9 18c-4.51 2-5-2-7-2"/></g></svg>
              
            </a>
          
            <a
              href="https://www.linkedin.com/in/jaehunryu/"
              
                target="_blank" rel="noopener noreferrer"
              
              class="text-muted-foreground hover:text-primary focus:ring-primary/20 rounded-lg p-1 transition-all duration-300 ease-out hover:scale-110 focus:ring-2 focus:outline-none"
              title="Linkedin"
              aria-label="Linkedin">
              
                
  <svg class="h-6 w-6"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="Linkedin"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path d="M16 8a6 6 0 0 1 6 6v7h-4v-7a2 2 0 0 0-2-2a2 2 0 0 0-2 2v7h-4v-7a6 6 0 0 1 6-6M2 9h4v12H2z"/><circle cx="4" cy="4" r="2"/></g></svg>
              
            </a>
          
            <a
              href="mailto:jaehunryu@icloud.com"
              
              class="text-muted-foreground hover:text-primary focus:ring-primary/20 rounded-lg p-1 transition-all duration-300 ease-out hover:scale-110 focus:ring-2 focus:outline-none"
              title="Email"
              aria-label="Email">
              
                
  <svg class="h-6 w-6"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="Email">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 8l7.89 5.26a2 2 0 002.22 0L21 8M5 19h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z" />

</svg>
              
            </a>
          
        </div>
      

    </div>
  </div>
</footer>


    
    



<div
  id="dock"
  class="pointer-events-none fixed bottom-4 left-1/2 z-[9999] w-fit -translate-x-1/2 translate-y-24 opacity-0 transition-all duration-300 ease-out sm:right-0 sm:left-0 sm:mx-auto sm:translate-x-0"
  role="toolbar"
  aria-label="바로가기 도구 모음">
  <nav
    class="border-border bg-card/80 scrollbar-hide xs:px-3 xs:py-2 mx-auto flex max-w-[calc(100vw-2rem)] min-w-fit items-center justify-center overflow-x-auto rounded-2xl border px-4 py-3 shadow-lg backdrop-blur-sm sm:px-4 sm:py-3">
    
    
      <button
        id="dock-back"
        class="text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 xs:px-2 xs:py-1.5 flex flex-shrink-0 items-center gap-2 rounded-lg px-3 py-2 text-sm font-medium transition-all duration-300 ease-out hover:-translate-y-0.5 hover:scale-105 focus:ring-2 focus:outline-none sm:px-3 sm:py-2"
        title="뒤로"
        aria-label="뒤로">
        
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24">
  <path d="m12 19-7-7 7-7"/>
  <path d="M19 12H5"/>

</svg>
        <span class="hidden sm:inline"
          >뒤로</span
        >
      </button>

      
      <div class="bg-border xs:mx-1 mx-2 h-6 w-px sm:mx-2"></div>
    


    
    
      <button
        id="dock-toc"
        class="text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 xs:px-2 xs:py-1.5 flex flex-shrink-0 items-center gap-2 rounded-lg px-3 py-2 text-sm font-medium transition-all duration-300 ease-out hover:-translate-y-0.5 hover:scale-105 focus:ring-2 focus:outline-none sm:px-3 sm:py-2"
        title="목차"
        aria-label="목차">
        
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24">
  <line x1="8" x2="21" y1="6" y2="6"/>
  <line x1="8" x2="21" y1="12" y2="12"/>
  <line x1="8" x2="21" y1="18" y2="18"/>
  <line x1="3" x2="3.01" y1="6" y2="6"/>
  <line x1="3" x2="3.01" y1="12" y2="12"/>
  <line x1="3" x2="3.01" y1="18" y2="18"/>

</svg>
        <span class="hidden sm:inline"
          >목차</span
        >
      </button>

      
      <div class="bg-border xs:mx-1 mx-2 h-6 w-px sm:mx-2"></div>
    


    
    <button
      id="dock-search"
      class="text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 xs:px-3 xs:py-1.5 flex flex-shrink-0 items-center gap-2 rounded-lg px-4 py-2 text-sm font-medium transition-all duration-300 ease-out hover:-translate-y-0.5 hover:scale-105 focus:ring-2 focus:outline-none sm:px-4 sm:py-2"
      title="검색"
      aria-label="검색">
      
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="m21 21-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />

</svg>
      <span class="hidden md:inline"
        >검색</span
      >
    </button>

    
    <div class="bg-border xs:mx-1 mx-2 h-6 w-px sm:mx-2"></div>

    
    
    


    
    <button
      id="dock-top"
      class="text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 xs:px-2 xs:py-1.5 flex flex-shrink-0 items-center gap-2 rounded-lg px-3 py-2 text-sm font-medium transition-all duration-300 ease-out hover:-translate-y-0.5 hover:scale-105 focus:ring-2 focus:outline-none sm:px-3 sm:py-2"
      title="맨 위로"
      aria-label="맨 위로">
      
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24">
  <path d="m18 15-6-6-6 6"/>

</svg>
      <span class="hidden sm:inline"
        >맨 위로</span
      >
    </button>
  </nav>
</div>


    
      



<div
  id="toc-overlay"
  class="pointer-events-none fixed inset-0 z-40 bg-black/50 opacity-0 backdrop-blur-sm transition-all duration-300"
  role="dialog"
  aria-modal="true"
  aria-labelledby="toc-title"></div>


<div
  id="toc-card"
  class="pointer-events-none fixed inset-4 z-50 flex w-auto scale-95 items-center justify-center opacity-0 transition-all duration-300 sm:inset-auto sm:top-1/2 sm:left-1/2 sm:block sm:w-full sm:max-w-md sm:-translate-x-1/2 sm:-translate-y-1/2"
  role="dialog"
  aria-modal="true"
  aria-labelledby="toc-title">
  <div
    class="bg-card border-border w-full max-w-sm overflow-hidden rounded-xl border shadow-xl sm:max-w-md">
    
    <div
      class="border-border bg-muted/30 flex items-center justify-between border-b p-4">
      <div class="flex items-center gap-3">
        
  <svg class="h-5 w-5"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24">
  <line x1="8" x2="21" y1="6" y2="6"/>
  <line x1="8" x2="21" y1="12" y2="12"/>
  <line x1="8" x2="21" y1="18" y2="18"/>
  <line x1="3" x2="3.01" y1="6" y2="6"/>
  <line x1="3" x2="3.01" y1="12" y2="12"/>
  <line x1="3" x2="3.01" y1="18" y2="18"/>

</svg>
        <h2 id="toc-title" class="text-foreground text-lg font-semibold">
          목차
        </h2>
      </div>

      
      <button
        id="toc-close"
        class="text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 rounded-lg p-2 transition-all duration-200 ease-out hover:-translate-y-0.5 hover:scale-105 focus:ring-2 focus:outline-none"
        title="닫기"
        aria-label="닫기">
        
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />

</svg>
      </button>
    </div>

    
    <div class="max-h-96 overflow-y-auto p-4">
      <nav
        id="toc-nav"
        class="toc-scrollbar"
        aria-label="글 목차">
          
          <div id="toc-content">
            <nav id="TableOfContents">
  <ul>
    <li><a href="#한-줄-요약-tldr">한 줄 요약 (TL;DR)</a></li>
    <li><a href="#핵심-아이디어">핵심 아이디어</a></li>
    <li><a href="#배경--그들이-해결한-문제">배경 — 그들이 해결한 문제</a></li>
    <li><a href="#새로운-접근법--gemini-25-아키텍처">새로운 접근법 — <strong>Gemini 2.5 아키텍처</strong></a></li>
    <li><a href="#작동-원리--구체적인-예시로-살펴보기">작동 원리 — 구체적인 예시로 살펴보기</a></li>
    <li><a href="#성능-검증--주요-결과">성능 검증 — 주요 결과</a></li>
    <li><a href="#우리의-관점--강점-한계-그리고-왜-중요한가">우리의 관점 — 강점, 한계, 그리고 왜 중요한가</a>
      <ul>
        <li><a href="#강점">강점</a></li>
        <li><a href="#한계">한계</a></li>
        <li><a href="#왜-중요한가">왜 중요한가</a></li>
      </ul>
    </li>
    <li><a href="#다음-단계는--앞으로의-길">다음 단계는? — 앞으로의 길</a>
      <ul>
        <li><a href="#토글을-클릭하면-논문에-대한-자세한-llm-질의응답-내용을-확인할-수-있습니다">토글을 클릭하면 논문에 대한 자세한 LLM 질의응답 내용을 확인할 수 있습니다.</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#한눈에-보는-결론--연구-공백--최신-기술-요약">한눈에 보는 결론 — 연구 공백 &amp; 최신 기술 요약</a></li>
    <li><a href="#1-introduction--related-work로-추출한-핵심-연구-공백">1. Introduction &amp; Related Work로 추출한 <strong>핵심 연구 공백</strong></a></li>
    <li><a href="#2-출판-시점-state-of-the-art-요약">2. <strong>출판 시점 (State-of-the-Art)</strong> 요약</a></li>
    <li><a href="#3-정리">3. 정리</a></li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#결론-한-줄-요약">결론 한 줄 요약</a></li>
      </ul>
    </li>
    <li><a href="#gemini-25--가장-중요한-3대-독창적-기여">Gemini 2.5 — 가장 중요한 3대 독창적 기여</a>
      <ul>
        <li><a href="#왜-중요한가-1">왜 중요한가?</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#저자들이-내세우는-우월성-핵심-논거-5가지">저자들이 내세우는 ‘우월성’ 핵심 논거 5가지</a>
      <ul>
        <li><a href="#저자-관점-요약-읽기-쉬운-서술">저자 관점 요약 (읽기 쉬운 서술)</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#tldr--한눈에-보는-알고리즘-흐름">TL;DR — 한눈에 보는 알고리즘 흐름</a></li>
    <li><a href="#1-핵심-구성요소--용어-빠른-정의">1. 핵심 구성요소 &amp; 용어 빠른 정의</a></li>
    <li><a href="#2-장난감-예시--8-토큰-멀티모달-시퀀스">2. 장난감 예시 ― 8 토큰 멀티모달 시퀀스</a></li>
    <li><a href="#3-단계별-파이프라인">3. 단계별 파이프라인</a></li>
    <li><a href="#4-알고리즘적-특징이-드러나는-지점">4. 알고리즘적 특징이 드러나는 지점</a></li>
    <li><a href="#5-마무리--왜-이-단계들이-중요한가">5. 마무리 — 왜 이 단계들이 중요한가?</a></li>
  </ul>

  <ul>
    <li><a href="#비밀-병기--slice-granularity-elasticity">‘비밀 병기’ — <strong>Slice-Granularity Elasticity</strong></a>
      <ul>
        <li><a href="#왜-결정적인가">왜 결정적인가?</a></li>
        <li><a href="#동작-개요-한-줄식-알고리즘">동작 개요 (한 줄식 알고리즘)</a></li>
        <li><a href="#성공의-필수-조건">성공의 필수 조건</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#1-핵심-성능-지표--벤치마크">1. 핵심 성능 지표 &amp; 벤치마크</a></li>
    <li><a href="#2-사용된-주요-벤치마크--메트릭">2. 사용된 주요 벤치마크 &amp; 메트릭</a></li>
    <li><a href="#3-저자들이-강조한-성공-증거-세-갈래">3. 저자들이 강조한 “성공 증거” 세 갈래</a>
      <ul>
        <li><a href="#4-왜-중요한가">4. 왜 중요한가?</a></li>
        <li><a href="#5-한-눈-요약-블로그용-인용구">5. 한-눈-요약 (블로그용 인용구)</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#한눈에-보는-결론">한눈에 보는 결론</a></li>
    <li><a href="#1-대표-수치-비교--베이스라인-vs-gemini-25-pro">1. 대표 수치 비교 — 베이스라인 vs Gemini 2.5 Pro</a></li>
    <li><a href="#2-저자들이-강조하는-우월성-증거">2. 저자들이 강조하는 ‘우월성’ 증거</a></li>
    <li><a href="#3-우위가-크지-않거나-밀린-포인트">3. <strong>우위가 크지 않거나 밀린 포인트</strong></a></li>
    <li><a href="#4-핵심-인사이트">4. 핵심 인사이트</a></li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#tldr--한눈결론">TL;DR – 한눈결론</a></li>
      </ul>
    </li>
    <li><a href="#1-저자들이-직접-인정한-한계실패-사례">1. 저자들이 <em>직접</em> 인정한 한계·실패 사례</a></li>
    <li><a href="#2-추가로-분석-제시하는-잠재적-한계">2. 추가로 분석-제시하는 잠재적 한계</a></li>
    <li><a href="#3-블로그용-한-줄-요약">3. 블로그용 한-줄 요약</a>
      <ul>
        <li><a href="#참고-한계-분석-체크리스트">참고: 한계 분석 체크리스트</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#1-저자들이-명시한-향후-연구-방향-3-가지">1. 저자들이 명시한 향후 연구 방향 (3 가지)</a></li>
    <li><a href="#2-논문-한계-기반-추가-연구-아이디어-5-선">2. 논문 한계 기반 <strong>추가</strong> 연구 아이디어 (5 선)</a></li>
    <li><a href="#3-우선순위-로드맵-2025-2026">3. 우선순위 로드맵 (2025-2026)</a>
      <ul>
        <li><a href="#결론-다시-요약">결론 (다시 요약)</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#핵심-요약--토큰화전처리-관련">핵심 요약 — 토큰화·전처리 관련</a>
      <ul>
        <li><a href="#왜-sentencepiece라고-추정할-수-있을까">왜 SentencePiece라고 추정할 수 있을까?</a></li>
        <li><a href="#전처리정규화-단계-관례-기반-추정">전처리·정규화 단계 (관례 기반 추정)</a>
          <ul>
            <li><a href="#실무-관점-메모">실무 관점 메모</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#tldr--구글-gemini-25pro--flash는">TL;DR — 구글 <strong>Gemini 2.5</strong>(Pro / Flash)는</a></li>
      </ul>
    </li>
    <li><a href="#1-어텐션-메커니즘-세부-구성">1. 어텐션 메커니즘 세부 구성</a>
      <ul>
        <li><a href="#1-a-self-attention-block-decoder-only">1-A. Self-Attention Block (Decoder-only)</a></li>
        <li><a href="#1-b-feed-forward-mixture-of-experts">1-B. Feed-Forward (Mixture-of-Experts)</a></li>
      </ul>
    </li>
    <li><a href="#2-위치-인코딩-positional-encoding">2. 위치 인코딩 (Positional Encoding)</a></li>
    <li><a href="#3-seq2seq-아키텍처-여부">3. (Seq2Seq 아키텍처 여부)</a></li>
    <li><a href="#4-요약--블로그-포스트용-활용-팁">4. 요약 &amp; 블로그 포스트용 활용 팁</a></li>
  </ul>

  <ul>
    <li><a href="#결론-한눈요약">결론 한눈 요약</a>
      <ul>
        <li><a href="#1-언어-모델링-목표objective">1. 언어 모델링 목표(objective)</a></li>
        <li><a href="#2-프리트레인-코퍼스-개요">2. 프리트레인 코퍼스 개요</a></li>
        <li><a href="#3-다운스트림-파인튜닝-전략">3. 다운스트림 파인튜닝 전략</a></li>
        <li><a href="#4-정리--학습-사다리">4. 정리 — 학습 사다리</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#tldr--한눈에-보는-구현--자원-스펙">TL;DR — 한눈에 보는 <strong>구현 &amp; 자원 스펙</strong></a>
      <ul>
        <li><a href="#1-핵심-소프트웨어-의존성">1. 핵심 소프트웨어 의존성</a></li>
        <li><a href="#2-하드웨어--메모리-세부">2. 하드웨어 &amp; 메모리 세부</a></li>
        <li><a href="#3-처리량throughput-측정">3. 처리량(Throughput) 측정</a></li>
        <li><a href="#4-총-연산-비용compute">4. 총 연산 비용(Compute)</a></li>
        <li><a href="#5-요약--실무적-체크리스트">5. 요약 &amp; 실무적 체크리스트</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#결론--무엇을-어떻게-쟀고-어떤-수치가-나왔나">결론 ― 무엇을 어떻게 쟀고, 어떤 수치가 나왔나?</a>
      <ul>
        <li><a href="#1-주요-평가-지표와-실측-값">1. 주요 평가 지표와 실측 값</a></li>
        <li><a href="#2-확장-전략--데이터사용자노드가-늘면">2. 확장 전략 — 데이터·사용자·노드가 늘면?</a></li>
        <li><a href="#3-메트릭-간-트레이드오프-시사점">3. 메트릭 간 트레이드오프 시사점</a></li>
      </ul>
    </li>
  </ul>
</nav>
          </div>
      </nav>
    </div>

    
    <div class="border-border bg-muted/20 border-t px-4 py-3">
      <div class="text-muted-foreground text-center text-xs">
        <span>제목을 클릭하면 해당 위치로 이동합니다</span>
      </div>
    </div>
  </div>
</div>

    


  <link
    rel="stylesheet"
    href="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.css"
    integrity="sha384-5TcZemv2l/9On385z///+d7MSYlvIEw9FuZTIdZ14vJLqWphw7e7ZPuOiCHJcFCP"
    crossorigin="anonymous" />
  <script
    defer
    src="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.js"
    integrity="sha384-cMkvdD8LoxVzGF/RPUKAcvmm49FQ0oxwDF3BGKtDXcEc+T1b2N+teh/OJfpU0jr6"
    crossorigin="anonymous"></script>
  <script
    defer
    src="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/contrib/auto-render.min.js"
    integrity="sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh"
    crossorigin="anonymous"></script>

<script>
    
    function initKaTeX() {
        if (typeof renderMathInElement === 'undefined') {
            setTimeout(initKaTeX, 100);
            return;
        }

        var delimiters = [{"display":true,"left":"$$","right":"$$"},{"display":false,"left":"$","right":"$"}];

        renderMathInElement(document.body, {
            delimiters: delimiters,
            throwOnError: false,
            errorColor: '#cc0000',
            fleqn: false,
            leqno: false,
            trust: false
        });
    }

    
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initKaTeX);
    } else {
        initKaTeX();
    }
</script>
    



    
    
<div
  id="search-overlay"
  class="pointer-events-none fixed inset-0 z-40 bg-black/50 opacity-0 transition-opacity duration-300"></div>


<div
  id="search-modal"
  class="bg-card border-border pointer-events-none fixed top-1/2 left-1/2 z-50 max-h-[80vh] w-full max-w-2xl -translate-x-1/2 -translate-y-1/2 scale-95 transform overflow-hidden rounded-xl border opacity-0 shadow-xl transition-all duration-300">
  
  <div class="border-border flex items-center gap-3 border-b p-4">
    
    <div class="text-muted-foreground h-5 w-5 flex-shrink-0">
      
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="m21 21-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />

</svg>
    </div>

    
    <div class="relative flex-1">
      
      <button
        id="search-clear"
        class="text-muted-foreground hover:text-foreground hover:bg-muted/50 pointer-events-none absolute top-1/2 left-0 z-10 h-5 w-5 -translate-y-1/2 rounded opacity-0 transition-all duration-200"
        title="지우기"
        aria-label="지우기">
        
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />

</svg>
      </button>

      
      <input
        id="search-input"
        type="text"
        placeholder="게시글 검색..."
        class="text-foreground placeholder:text-muted-foreground w-full border-none bg-transparent pl-8 text-lg outline-none"
        autocomplete="off"
        spellcheck="false" />
    </div>

    
    <button
      id="search-close"
      class="text-muted-foreground hover:text-foreground hover:bg-muted/50 flex h-6 w-6 items-center justify-center rounded-md p-0.5 transition-all duration-200"
      title="닫기"
      aria-label="닫기">
      
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />

</svg>
    </button>
  </div>

  
  <div id="search-results" class="max-h-96 overflow-y-auto">
    
    <div
      id="search-empty"
      class="flex flex-col items-center justify-center py-12 text-center">
      <div
        class="bg-muted/50 mb-4 flex h-16 w-16 items-center justify-center rounded-full">
        
  <svg class="h-6 w-6"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="m21 21-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />

</svg>
      </div>
      <h3 class="text-foreground mb-2 text-lg font-semibold">
        검색 시작
      </h3>
      <p class="text-muted-foreground text-sm">
        검색어를 입력하세요
      </p>
    </div>

    
    <div
      id="search-loading"
      class="flex hidden items-center justify-center py-8">
      <div
        class="mr-3 h-6 w-6 animate-spin rounded-full border-2 border-current border-t-transparent"></div>
      <span class="text-muted-foreground"
        >검색 중...</span
      >
    </div>

    
    <div
      id="search-no-results"
      class="flex hidden flex-col items-center justify-center py-12 text-center">
      <div
        class="bg-muted/50 mb-4 flex h-16 w-16 items-center justify-center rounded-full">
        
  <svg class="h-6 w-6"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h7" />
</svg>
      </div>
      <h3 class="text-foreground mb-2 text-lg font-semibold">
        검색 결과 없음
      </h3>
      <p class="text-muted-foreground text-sm">
        다른 검색어로 시도해보세요
      </p>
    </div>

    
    <div id="search-results-list" class="hidden">
      
      <div
        id="search-stats"
        class="text-muted-foreground border-border border-b px-4 py-3 text-sm"
        data-template="%d개의 결과 찾음">
      </div>

      
      <div id="search-items" class="divide-border divide-y">
        
      </div>
    </div>
  </div>

  
  <div class="border-border bg-muted/20 border-t px-4 py-3">
    <div
      class="text-muted-foreground flex items-center justify-between text-xs">
      <div class="flex items-center gap-2 md:gap-4">
        <div class="flex items-center gap-1">
          <kbd
            class="bg-muted border-border rounded border px-1.5 py-0.5 text-xs"
            >↑↓</kbd
          >
          <span class="hidden sm:inline"
            >이동</span
          >
        </div>
        <div class="flex items-center gap-1">
          <kbd
            class="bg-muted border-border rounded border px-1.5 py-0.5 text-xs"
            >↵</kbd
          >
          <span class="hidden sm:inline"
            >선택</span
          >
        </div>
        <div class="flex items-center gap-1">
          <kbd
            class="bg-muted border-border rounded border px-1.5 py-0.5 text-xs"
            >ESC</kbd
          >
          <span class="hidden sm:inline"
            >닫기</span
          >
        </div>
      </div>
      <div class="search-hint-desktop flex items-center gap-1">
        <kbd class="bg-muted border-border rounded border px-1.5 py-0.5 text-xs"
          >⌘K</kbd
        >
        <span>단축키</span>
      </div>
    </div>
  </div>
</div>

  </body>
</html>
