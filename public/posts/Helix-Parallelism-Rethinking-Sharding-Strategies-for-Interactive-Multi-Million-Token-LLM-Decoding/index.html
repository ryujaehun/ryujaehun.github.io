<!doctype html>
<html
  lang="ko-kr"
  data-theme="claude">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1314&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8" />
<meta
  name="viewport"
  content="width=device-width, initial-scale=1, shrink-to-fit=no" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />

<title>Helix Parallelism: Rethinking Sharding Strategies for Interactive Multi-Million-Token LLM Decoding | Jaehun&#39;s Blog</title>

<meta name="description" content="논문 링크
Helix Parallelism: 초장기 LLM 디코딩의 지연-처리량 벽을 깨다 한 줄 요약 (TL;DR) Helix Parallelism은 Attention과 FFN을 서로 다른 병렬화 전략으로 스케줄링해 KV 캐시 중복과 FFN..." />
<meta name="keywords" content="2505.09343v1, Helix Parallelism, Tensor Parallelism, KV Parallelism, Mixture of Experts, Grouped Query Attention (GQA), FlashAttention, Parallelism for LLMs, System-Aware ML, Efficient Transformer Inference, Serving LLMs at Scale, Long Context Inference" />
<meta name="author" content="" />
<meta name="language" content="ko-kr" />

<meta name="robots" content="index, follow" />
<link rel="canonical" href="http://192.168.1.11:1314/posts/Helix-Parallelism-Rethinking-Sharding-Strategies-for-Interactive-Multi-Million-Token-LLM-Decoding/" />



  <link rel="icon" type="image/svg+xml" href="/favicon.svg" />



<link rel="manifest" href="/site.webmanifest" />
<meta property="og:url" content="http://192.168.1.11:1314/posts/Helix-Parallelism-Rethinking-Sharding-Strategies-for-Interactive-Multi-Million-Token-LLM-Decoding/">
  <meta property="og:site_name" content="Jaehun&#39;s Blog">
  <meta property="og:title" content="Helix Parallelism: Rethinking Sharding Strategies for Interactive Multi-Million-Token LLM Decoding">
  <meta property="og:description" content="논문 링크
Helix Parallelism: 초장기 LLM 디코딩의 지연-처리량 벽을 깨다 한 줄 요약 (TL;DR) Helix Parallelism은 Attention과 FFN을 서로 다른 병렬화 전략으로 스케줄링해 KV 캐시 중복과 FFN 가중치 로드 병목을 동시에 해소—1 M 토큰 컨텍스트에서 토큰 지연을 최대 1.5 × 줄이고, 동일 지연 예산으로 동시 사용자 수를 32 × 까지 늘린다.">
  <meta property="og:locale" content="ko_kr">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-07-08T00:00:00+00:00">
    <meta property="article:modified_time" content="2025-07-08T00:00:00+00:00">
    <meta property="article:tag" content="2505.09343v1">
    <meta property="article:tag" content="Helix Parallelism">
    <meta property="article:tag" content="Tensor Parallelism">
    <meta property="article:tag" content="KV Parallelism">
    <meta property="article:tag" content="Mixture of Experts">
    <meta property="article:tag" content="Grouped Query Attention (GQA)">
    <meta property="og:image" content="http://192.168.1.11:1314/images/og-default.avif">


  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:image" content="http://192.168.1.11:1314/images/og-default.avif">
  <meta name="twitter:title" content="Helix Parallelism: Rethinking Sharding Strategies for Interactive Multi-Million-Token LLM Decoding">
  <meta name="twitter:description" content="논문 링크
Helix Parallelism: 초장기 LLM 디코딩의 지연-처리량 벽을 깨다 한 줄 요약 (TL;DR) Helix Parallelism은 Attention과 FFN을 서로 다른 병렬화 전략으로 스케줄링해 KV 캐시 중복과 FFN 가중치 로드 병목을 동시에 해소—1 M 토큰 컨텍스트에서 토큰 지연을 최대 1.5 × 줄이고, 동일 지연 예산으로 동시 사용자 수를 32 × 까지 늘린다.">


  <meta itemprop="name" content="Helix Parallelism: Rethinking Sharding Strategies for Interactive Multi-Million-Token LLM Decoding">
  <meta itemprop="description" content="논문 링크
Helix Parallelism: 초장기 LLM 디코딩의 지연-처리량 벽을 깨다 한 줄 요약 (TL;DR) Helix Parallelism은 Attention과 FFN을 서로 다른 병렬화 전략으로 스케줄링해 KV 캐시 중복과 FFN 가중치 로드 병목을 동시에 해소—1 M 토큰 컨텍스트에서 토큰 지연을 최대 1.5 × 줄이고, 동일 지연 예산으로 동시 사용자 수를 32 × 까지 늘린다.">
  <meta itemprop="datePublished" content="2025-07-08T00:00:00+00:00">
  <meta itemprop="dateModified" content="2025-07-08T00:00:00+00:00">
  <meta itemprop="wordCount" content="15483">
  <meta itemprop="image" content="http://192.168.1.11:1314/images/og-default.avif">
  <meta itemprop="keywords" content="2505.09343v1,Helix Parallelism,Tensor Parallelism,KV Parallelism,Mixture of Experts,Grouped Query Attention (GQA),FlashAttention,Parallelism for LLMs,System-Aware ML,Efficient Transformer Inference,Serving LLMs at Scale,Long Context Inference">







<script>
  window.HUGO_SEARCH_CONFIG = {
    searchIndexURL: "\"/index.json\""
  };
</script>


































<script>

  window.HUGO_GALLERY_CONFIG = {
    justified_gallery:  false ,
    lightbox:  false ,
    justified: "{}",
    lightbox_options: "{}"
  };
</script>




  
    <link rel="stylesheet" href="/css/compiled.css" />
  





  
    <link rel="stylesheet" href="/css/chroma.css" />
  












      <script src="/js/main.js"></script>



  <script src="/js/gumshoe.polyfills.min.js"></script>



        <script src="/js/toc.js" defer></script>



      <script src="/js/search.js" defer></script>



      <script src="/js/dock.js" defer></script>











  











    <script>
      
      (function() {
        const theme = localStorage.getItem('theme') || 'system';
        const colorScheme = localStorage.getItem('colorScheme') || 'claude';

        
        document.documentElement.setAttribute('data-theme', colorScheme);

        
        function applyTheme() {
          if (theme === 'dark' || (theme === 'system' && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
            document.documentElement.classList.add('dark');
          } else {
            document.documentElement.classList.remove('dark');
          }
        }

        applyTheme();

        
        if (theme === 'system') {
          window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', applyTheme);
        }
      })();
    </script>
  </head>

  <body class="bg-background text-foreground min-h-screen antialiased">
    
    
  <div
    id="reading-progress-container"
    class="reading-progress-container pointer-events-none fixed top-0 right-0 left-0 z-50 transition-opacity duration-300 ease-out"
    data-height="3"
    data-smooth-scroll="true"
    data-hide-on-complete="false">
    
    <div class="reading-progress-bg w-full"></div>

    
    <div
      id="reading-progress-bar"
      class="from-primary to-primary/80 reading-progress-bar 
        transition-all duration-150 ease-out
       absolute top-0 left-0 w-0 bg-gradient-to-r"></div>
  </div>

  <script>
    (function () {
      "use strict";

      const progressContainer = document.getElementById(
        "reading-progress-container",
      );
      const progressBar = document.getElementById("reading-progress-bar");

      if (!progressContainer || !progressBar) return;

      
      const config = {
        smoothScroll: progressContainer.dataset.smoothScroll === "true",
        hideOnComplete: progressContainer.dataset.hideOnComplete === "true",
      };

      let isVisible = true;
      let gumshoeInstance = null;

      
      function calculateProgress() {
        const scrollTop =
          window.pageYOffset || document.documentElement.scrollTop;
        const documentHeight = document.documentElement.scrollHeight;
        const windowHeight = window.innerHeight;
        const scrollableHeight = documentHeight - windowHeight;

        if (scrollableHeight <= 0) return 0;

        return Math.min(Math.max((scrollTop / scrollableHeight) * 100, 0), 100);
      }

      
      function updateProgress() {
        const progress = calculateProgress();
        progressBar.style.width = progress + "%";

        
        if (config.hideOnComplete && progress >= 99.5) {
          if (isVisible) {
            progressContainer.style.opacity = "0";
            isVisible = false;
          }
        } else if (!isVisible) {
          progressContainer.style.opacity = "1";
          isVisible = true;
        }
      }

      
      let ticking = false;
      function requestTick() {
        if (!ticking) {
          requestAnimationFrame(() => {
            updateProgress();
            ticking = false;
          });
          ticking = true;
        }
      }

      
      function init() {
        
        window.addEventListener("scroll", requestTick, { passive: true });
        window.addEventListener("resize", requestTick, { passive: true });
        document.addEventListener("visibilitychange", () => {
          if (!document.hidden) requestTick();
        });

        
        requestTick();

        
        window.addEventListener("beforeunload", () => {
          window.removeEventListener("scroll", requestTick);
          window.removeEventListener("resize", requestTick);
        });
      }

      
      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", init);
      } else {
        init();
      }
    })();
  </script>

    <header class="sticky top-0 z-50 mx-auto max-w-4xl px-4 py-6">
  <div
    class="border-border bg-card/80 flex items-center rounded-xl border px-6 py-4 shadow-sm backdrop-blur-sm">
    
    <div class="hidden w-full items-center md:flex">
      
      <div class="flex items-center">
        
          
          <a
            href="/"
            class="bg-primary text-primary-foreground hover:bg-primary/90 flex h-10 w-10 items-center justify-center rounded-full text-lg font-bold transition-transform duration-200 hover:scale-105"
            aria-label="Jaehun&#39;s Blog">
            J
          </a>
        
      </div>

      
      <nav class="mx-8 flex flex-1 items-center justify-center">
        <div class="flex items-center space-x-1">
          
          
            
            
            
              
                
              
            
            
            <a
              href="/posts/"
              class="nav-link 
                text-muted-foreground hover:text-primary hover:bg-primary/10
               focus:ring-primary/20 relative flex items-center gap-2 rounded-lg px-4 py-2 text-sm font-medium transition-all duration-300 ease-out hover:-translate-y-0.5 hover:scale-105 focus:ring-2 focus:outline-none">
              
                
  <svg class="h-5 w-5"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="nav.posts">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 20H5a2 2 0 01-2-2V6a2 2 0 012-2h10a2 2 0 012 2v1m2 13a2 2 0 01-2-2V7m2 13a2 2 0 002-2V9a2 2 0 00-2-2h-2m-4-3H9M7 16h6M7 8h6v4H7V8z" />

</svg>
              
              <span
                >
                  게시글
                </span
              >
            </a>
          
            
            
            
              
                
              
            
            
            <a
              href="/categories/"
              class="nav-link 
                text-muted-foreground hover:text-primary hover:bg-primary/10
               focus:ring-primary/20 relative flex items-center gap-2 rounded-lg px-4 py-2 text-sm font-medium transition-all duration-300 ease-out hover:-translate-y-0.5 hover:scale-105 focus:ring-2 focus:outline-none">
              
                
  <svg class="h-5 w-5"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="nav.categories">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10" />

</svg>
              
              <span
                >
                  카테고리
                </span
              >
            </a>
          
            
            
            
              
                
              
            
            
            <a
              href="/tags/"
              class="nav-link 
                text-muted-foreground hover:text-primary hover:bg-primary/10
               focus:ring-primary/20 relative flex items-center gap-2 rounded-lg px-4 py-2 text-sm font-medium transition-all duration-300 ease-out hover:-translate-y-0.5 hover:scale-105 focus:ring-2 focus:outline-none">
              
                
  <svg class="h-5 w-5"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="nav.tags">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 7h.01M7 3h5c.512 0 1.024.195 1.414.586l7 7a2 2 0 010 2.828l-7 7a2 2 0 01-2.828 0l-7-7A1.994 1.994 0 013 12V7a4 4 0 014-4z" />

</svg>
              
              <span
                >
                  태그
                </span
              >
            </a>
          
            
            
            
              
                
              
            
            
            <a
              href="/archives/"
              class="nav-link 
                text-muted-foreground hover:text-primary hover:bg-primary/10
               focus:ring-primary/20 relative flex items-center gap-2 rounded-lg px-4 py-2 text-sm font-medium transition-all duration-300 ease-out hover:-translate-y-0.5 hover:scale-105 focus:ring-2 focus:outline-none">
              
                
  <svg class="h-5 w-5"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="nav.archives">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 8h14M5 8a2 2 0 110-4h14a2 2 0 110 4M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8m-9 4h4" />

</svg>
              
              <span
                >
                  아카이브
                </span
              >
            </a>
          
        </div>
      </nav>

      
      <div class="flex items-center space-x-2">
        
        
<div class="relative">
  <button id="language-toggle"
    class="dropdown-toggle border-border bg-background text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex h-10 w-10 items-center justify-center rounded-lg border transition-all duration-300 ease-out hover:scale-105 focus:ring-2 focus:outline-none active:scale-95"
    data-dropdown-type="language"
    aria-label="언어 변경"
    aria-expanded="false"
    aria-haspopup="true">
      
  <svg class="h-5 w-5 relative z-10"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="언어 변경">
	<path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="m5 8l6 6m-7 0l6-6l2-3M2 5h12M7 2h1m14 20l-5-10l-5 10m2-4h6" />
</svg></button>

  
  <div id="language-dropdown"
    class="dropdown-menu border-border bg-popover/95 absolute top-12 right-0 z-[60] hidden w-40 rounded-lg border p-1 shadow-lg backdrop-blur-sm transition-all duration-200 ease-out"
    data-dropdown-type="language"
    role="menu"
    aria-labelledby="language-toggle"><a href="/ko/" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none" role="menuitem" aria-current="true"><span class="font-medium">한국어</span></a><a href="/en/" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none" role="menuitem"><span class="font-medium">English</span></a></div>
</div>

        
        
<div class="relative">
  <button id="color-scheme-toggle"
    class="dropdown-toggle border-border bg-background text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex h-10 w-10 items-center justify-center rounded-lg border transition-all duration-300 ease-out hover:scale-105 focus:ring-2 focus:outline-none active:scale-95"
    data-dropdown-type="color-scheme"
    aria-label="테마 변경"
    aria-expanded="false"
    aria-haspopup="true">
      
  <svg class="h-5 w-5 relative z-10"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="테마 변경">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 21a4 4 0 01-4-4V5a2 2 0 012-2h4a2 2 0 012 2v12a4 4 0 01-4 4zM21 5a2 2 0 00-2-2h-4a2 2 0 00-2 2v6a2 2 0 002 2h4a2 2 0 002-2V5z" />

</svg></button>

  
  <div id="color-scheme-dropdown"
    class="dropdown-menu border-border bg-popover/95 absolute top-12 right-0 z-[60] hidden w-44 rounded-lg border p-1 shadow-lg backdrop-blur-sm transition-all duration-200 ease-out"
    data-dropdown-type="color-scheme"><button data-color-scheme="claude" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none"><span>Default</span></button><button data-color-scheme="default" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none"><span>White</span></button><button data-color-scheme="bumblebee" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none"><span>Bumblebee</span></button><button data-color-scheme="emerald" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none"><span>Emerald</span></button><button data-color-scheme="nord" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none"><span>Nord</span></button><button data-color-scheme="sunset" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none"><span>Sunset</span></button><button data-color-scheme="abyss" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none"><span>Abyss</span></button><button data-color-scheme="dracula" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none"><span>Dracula</span></button><button data-color-scheme="amethyst" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none"><span>Amethyst</span></button><button data-color-scheme="slate" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none"><span>Slate</span></button><button data-color-scheme="twitter" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none"><span>Twitter</span></button></div>
</div>

        
        
<div class="relative">
  <button id="theme-toggle"
    class="dropdown-toggle border-border bg-background text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex h-10 w-10 items-center justify-center rounded-lg border transition-all duration-300 ease-out hover:scale-105 focus:ring-2 focus:outline-none active:scale-95"
    data-dropdown-type="theme"
    aria-label="테마 변경"
    aria-expanded="false"
    aria-haspopup="true">
      
      
  <svg class="h-5 w-5 sun-icon hidden relative z-10"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="라이트">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" />

</svg>
      
      
  <svg class="h-5 w-5 moon-icon hidden relative z-10"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="다크">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" />

</svg>
      
      
  <svg class="h-5 w-5 system-icon hidden relative z-10"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="시스템">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.75 17L9 20l-1 1h8l-1-1-.75-3M3 13h18M5 17h14a2 2 0 002-2V5a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z" />

</svg></button>

  
  <div id="theme-dropdown"
    class="dropdown-menu border-border bg-popover/95 absolute top-12 right-0 z-[60] hidden w-40 rounded-lg border p-1 shadow-lg backdrop-blur-sm transition-all duration-200 ease-out"
    data-dropdown-type="theme"><button data-theme="light" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none">
  <svg class="h-5 w-5 mr-3 h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="라이트">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" />

</svg><span>라이트</span></button><button data-theme="dark" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none">
  <svg class="h-5 w-5 mr-3 h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="다크">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" />

</svg><span>다크</span></button><button data-theme="system" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none">
  <svg class="h-5 w-5 mr-3 h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="시스템">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.75 17L9 20l-1 1h8l-1-1-.75-3M3 13h18M5 17h14a2 2 0 002-2V5a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z" />

</svg><span>시스템</span></button></div>
</div>
      </div>
    </div>

    
    <div class="flex w-full items-center justify-between md:hidden">
      
      
<div class="relative">
  <button
    id="mobile-menu-toggle"
    class="dropdown-toggle border-border bg-background text-muted-foreground hover:bg-accent hover:text-foreground flex h-10 w-10 items-center justify-center rounded-lg border transition-colors duration-200"
    data-dropdown-type="mobile-menu"
    aria-label="메뉴"
    aria-expanded="false"
    aria-haspopup="true">
    
  <svg class="h-5 w-5"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="메뉴">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16" />

</svg>
  </button>

  
  <div
    id="mobile-menu"
    class="mobile-menu dropdown-menu border-border bg-popover/95 absolute top-12 left-0 z-[60] hidden w-80 max-w-[calc(100vw-2rem)] rounded-lg border p-1 shadow-lg backdrop-blur-sm transition-all duration-200 ease-out md:hidden"
    data-dropdown-type="mobile-menu"
    role="menu"
    aria-labelledby="mobile-menu-toggle">
    <nav class="flex flex-col">
      
      
        
        
        
          
            
          
        
        
        <a
          href="/posts/"
          class="nav-link 
            text-muted-foreground hover:text-primary hover:bg-primary/10
           focus:ring-primary/20 relative flex items-center gap-3 rounded-md px-4 py-3 text-sm font-medium transition-all duration-200 ease-out hover:translate-x-1 focus:ring-2 focus:outline-none"
          role="menuitem"
          >
          
            
  <svg class="h-5 w-5"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="nav.posts">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 20H5a2 2 0 01-2-2V6a2 2 0 012-2h10a2 2 0 012 2v1m2 13a2 2 0 01-2-2V7m2 13a2 2 0 002-2V9a2 2 0 00-2-2h-2m-4-3H9M7 16h6M7 8h6v4H7V8z" />

</svg>
          
          <span
            >
              게시글
            </span
          >
        </a>
      
        
        
        
          
            
          
        
        
        <a
          href="/categories/"
          class="nav-link 
            text-muted-foreground hover:text-primary hover:bg-primary/10
           focus:ring-primary/20 relative flex items-center gap-3 rounded-md px-4 py-3 text-sm font-medium transition-all duration-200 ease-out hover:translate-x-1 focus:ring-2 focus:outline-none"
          role="menuitem"
          >
          
            
  <svg class="h-5 w-5"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="nav.categories">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10" />

</svg>
          
          <span
            >
              카테고리
            </span
          >
        </a>
      
        
        
        
          
            
          
        
        
        <a
          href="/tags/"
          class="nav-link 
            text-muted-foreground hover:text-primary hover:bg-primary/10
           focus:ring-primary/20 relative flex items-center gap-3 rounded-md px-4 py-3 text-sm font-medium transition-all duration-200 ease-out hover:translate-x-1 focus:ring-2 focus:outline-none"
          role="menuitem"
          >
          
            
  <svg class="h-5 w-5"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="nav.tags">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 7h.01M7 3h5c.512 0 1.024.195 1.414.586l7 7a2 2 0 010 2.828l-7 7a2 2 0 01-2.828 0l-7-7A1.994 1.994 0 013 12V7a4 4 0 014-4z" />

</svg>
          
          <span
            >
              태그
            </span
          >
        </a>
      
        
        
        
          
            
          
        
        
        <a
          href="/archives/"
          class="nav-link 
            text-muted-foreground hover:text-primary hover:bg-primary/10
           focus:ring-primary/20 relative flex items-center gap-3 rounded-md px-4 py-3 text-sm font-medium transition-all duration-200 ease-out hover:translate-x-1 focus:ring-2 focus:outline-none"
          role="menuitem"
          >
          
            
  <svg class="h-5 w-5"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="nav.archives">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 8h14M5 8a2 2 0 110-4h14a2 2 0 110 4M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8m-9 4h4" />

</svg>
          
          <span
            >
              아카이브
            </span
          >
        </a>
      
    </nav>
  </div>
</div>


      
      <div class="flex items-center space-x-2">
        
        
<div class="relative">
  <button id="language-toggle"
    class="dropdown-toggle border-border bg-background text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex h-10 w-10 items-center justify-center rounded-lg border transition-all duration-300 ease-out hover:scale-105 focus:ring-2 focus:outline-none active:scale-95"
    data-dropdown-type="language"
    aria-label="언어 변경"
    aria-expanded="false"
    aria-haspopup="true">
      
  <svg class="h-5 w-5 relative z-10"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="언어 변경">
	<path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="m5 8l6 6m-7 0l6-6l2-3M2 5h12M7 2h1m14 20l-5-10l-5 10m2-4h6" />
</svg></button>

  
  <div id="language-dropdown"
    class="dropdown-menu border-border bg-popover/95 absolute top-12 right-0 z-[60] hidden w-40 rounded-lg border p-1 shadow-lg backdrop-blur-sm transition-all duration-200 ease-out"
    data-dropdown-type="language"
    role="menu"
    aria-labelledby="language-toggle"><a href="/ko/" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none" role="menuitem" aria-current="true"><span class="font-medium">한국어</span></a><a href="/en/" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none" role="menuitem"><span class="font-medium">English</span></a></div>
</div>

        
        
<div class="relative">
  <button id="color-scheme-toggle"
    class="dropdown-toggle border-border bg-background text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex h-10 w-10 items-center justify-center rounded-lg border transition-all duration-300 ease-out hover:scale-105 focus:ring-2 focus:outline-none active:scale-95"
    data-dropdown-type="color-scheme"
    aria-label="테마 변경"
    aria-expanded="false"
    aria-haspopup="true">
      
  <svg class="h-5 w-5 relative z-10"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="테마 변경">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 21a4 4 0 01-4-4V5a2 2 0 012-2h4a2 2 0 012 2v12a4 4 0 01-4 4zM21 5a2 2 0 00-2-2h-4a2 2 0 00-2 2v6a2 2 0 002 2h4a2 2 0 002-2V5z" />

</svg></button>

  
  <div id="color-scheme-dropdown"
    class="dropdown-menu border-border bg-popover/95 absolute top-12 right-0 z-[60] hidden w-44 rounded-lg border p-1 shadow-lg backdrop-blur-sm transition-all duration-200 ease-out"
    data-dropdown-type="color-scheme"><button data-color-scheme="claude" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none"><span>Default</span></button><button data-color-scheme="default" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none"><span>White</span></button><button data-color-scheme="bumblebee" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none"><span>Bumblebee</span></button><button data-color-scheme="emerald" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none"><span>Emerald</span></button><button data-color-scheme="nord" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none"><span>Nord</span></button><button data-color-scheme="sunset" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none"><span>Sunset</span></button><button data-color-scheme="abyss" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none"><span>Abyss</span></button><button data-color-scheme="dracula" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none"><span>Dracula</span></button><button data-color-scheme="amethyst" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none"><span>Amethyst</span></button><button data-color-scheme="slate" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none"><span>Slate</span></button><button data-color-scheme="twitter" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none"><span>Twitter</span></button></div>
</div>

        
        
<div class="relative">
  <button id="theme-toggle"
    class="dropdown-toggle border-border bg-background text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex h-10 w-10 items-center justify-center rounded-lg border transition-all duration-300 ease-out hover:scale-105 focus:ring-2 focus:outline-none active:scale-95"
    data-dropdown-type="theme"
    aria-label="테마 변경"
    aria-expanded="false"
    aria-haspopup="true">
      
      
  <svg class="h-5 w-5 sun-icon hidden relative z-10"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="라이트">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" />

</svg>
      
      
  <svg class="h-5 w-5 moon-icon hidden relative z-10"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="다크">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" />

</svg>
      
      
  <svg class="h-5 w-5 system-icon hidden relative z-10"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="시스템">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.75 17L9 20l-1 1h8l-1-1-.75-3M3 13h18M5 17h14a2 2 0 002-2V5a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z" />

</svg></button>

  
  <div id="theme-dropdown"
    class="dropdown-menu border-border bg-popover/95 absolute top-12 right-0 z-[60] hidden w-40 rounded-lg border p-1 shadow-lg backdrop-blur-sm transition-all duration-200 ease-out"
    data-dropdown-type="theme"><button data-theme="light" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none">
  <svg class="h-5 w-5 mr-3 h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="라이트">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" />

</svg><span>라이트</span></button><button data-theme="dark" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none">
  <svg class="h-5 w-5 mr-3 h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="다크">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" />

</svg><span>다크</span></button><button data-theme="system" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none">
  <svg class="h-5 w-5 mr-3 h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="시스템">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.75 17L9 20l-1 1h8l-1-1-.75-3M3 13h18M5 17h14a2 2 0 002-2V5a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z" />

</svg><span>시스템</span></button></div>
</div>
      </div>
    </div>
  </div>
</header>


    <main class="mx-auto max-w-4xl px-4 py-6">
      
  
  <nav
  class="breadcrumb mb-4 md:mb-6 py-1"
  aria-label="경로">
  <ol class="text-muted-foreground flex items-center space-x-1 md:space-x-2 text-sm overflow-x-auto whitespace-nowrap scrollbar-hide py-1">
    
    <li class="flex-shrink-0">
      <a
        href="/"
        class="text-muted-foreground hover:text-primary hover:bg-primary/10 flex items-center gap-0.5 md:gap-1 rounded-lg px-1 md:px-3 py-0.5 md:py-1.5 transition-all duration-200 ease-out hover:-translate-y-0.5 hover:scale-[1.02]">
        
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="홈">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="m3 12 2-2m0 0 7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6" />

</svg>
        <span class="max-w-[4rem] md:max-w-none truncate">홈</span>
      </a>
    </li>

    
    
      <li class="flex items-center gap-1 md:gap-2 min-w-0">
        <span class="text-muted-foreground/50 flex-shrink-0"
          >
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
</svg>
        </span>

        
          
          <div class="flex items-center gap-1 md:gap-2 min-w-0">
            
              
              <a
                href="/posts"
                class="text-muted-foreground hover:text-primary hover:bg-primary/10 flex items-center gap-0.5 md:gap-1 rounded-lg px-1 md:px-3 py-0.5 md:py-1.5 transition-all duration-200 ease-out hover:-translate-y-0.5 hover:scale-[1.02] flex-shrink-0">
                
                  
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 20H5a2 2 0 01-2-2V6a2 2 0 012-2h10a2 2 0 012 2v1m2 13a2 2 0 01-2-2V7m2 13a2 2 0 002-2V9a2 2 0 00-2-2h-2m-4-3H9M7 16h6M7 8h6v4H7V8z" />

</svg>
                  <span class="max-w-[3rem] md:max-w-none truncate">게시글</span>
                
              </a>
              <span class="text-muted-foreground/50 flex-shrink-0"
                >
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
</svg></span
              >
            
            
            <span class="text-foreground flex items-center gap-0.5 md:gap-1 font-medium min-w-0">
              
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
</svg>
              <span class="max-w-[8rem] md:max-w-[16rem] lg:max-w-none truncate">Helix Parallelism: Rethinking Sharding Strategies for Interactive Multi-Million-Token LLM Decoding</span>
            </span>
          </div>
        
      </li>
    

  </ol>
</nav>



  


  
  <header class="mb-8">
    


<div class="post-meta">
  
  <h1 class="text-foreground mb-6 text-3xl leading-tight font-bold md:text-4xl">
    Helix Parallelism: Rethinking Sharding Strategies for Interactive Multi-Million-Token LLM Decoding
  </h1>

  
  


  
  <div class="bg-card border-border flex flex-col gap-4 rounded-xl border p-6">
    
    <div
      class="text-muted-foreground flex flex-wrap items-center gap-4 text-sm">
      
      <div class="flex items-center gap-2">
        
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="작성일"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z" />
</svg>
        <time datetime="2025-07-08">
          2025년 07월 08일
        </time>
      </div>

      
      


      
      
        <div class="flex items-center gap-2">
          
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="읽는 시간"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
</svg>
          <span
            >31 분</span
          >
        </div>
      


      
      
        <div class="flex items-center gap-2">
          
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="단어 수"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h7" />
</svg>
          <span>15483 단어</span>
        </div>
      

    </div>

    
    
      <div class="flex flex-wrap items-center gap-4">
        
        
          <div class="flex items-center gap-2">
            
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="카테고리"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 7v10a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-6l-2-2H5a2 2 0 00-2 2z" />
</svg>
            <span class="text-muted-foreground mr-2 text-sm"
              >카테고리:</span
            >
            <div class="flex flex-wrap gap-2">
              
                <a
                  href="/categories/paper-review/"
                  class="bg-primary/10 text-primary hover:bg-primary/20 focus:ring-primary/20 inline-flex items-center rounded-full px-3 py-1 text-sm font-medium transition-all duration-200 ease-out hover:-translate-y-0.5 hover:scale-105 hover:shadow-md focus:ring-2 focus:outline-none">
                  paper-review
                </a>
              
                <a
                  href="/categories/with-gpt/"
                  class="bg-primary/10 text-primary hover:bg-primary/20 focus:ring-primary/20 inline-flex items-center rounded-full px-3 py-1 text-sm font-medium transition-all duration-200 ease-out hover:-translate-y-0.5 hover:scale-105 hover:shadow-md focus:ring-2 focus:outline-none">
                  with-gpt
                </a>
              
            </div>
          </div>
        


        
        
          <div class="flex items-center gap-2">
            
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="태그">
	<g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2">
		<path d="M12.586 2.586A2 2 0 0 0 11.172 2H4a2 2 0 0 0-2 2v7.172a2 2 0 0 0 .586 1.414l8.704 8.704a2.426 2.426 0 0 0 3.42 0l6.58-6.58a2.426 2.426 0 0 0 0-3.42z" />
		<circle cx="7.5" cy="7.5" r=".5" fill="currentColor" />
	</g>
</svg>
            <span class="text-muted-foreground mr-2 text-sm"
              >태그:</span
            >
            <div class="flex flex-wrap gap-2">
              
                <a
                  href="/tags/2505.09343v1/"
                  class="bg-muted/50 text-muted-foreground hover:bg-primary/10 hover:text-primary focus:ring-primary/20 inline-flex items-center rounded px-2 py-1 text-sm transition-all duration-200 ease-out hover:-translate-y-0.5 hover:scale-105 focus:ring-2 focus:outline-none">
                  #2505.09343v1
                </a>
              
                <a
                  href="/tags/Helix-Parallelism/"
                  class="bg-muted/50 text-muted-foreground hover:bg-primary/10 hover:text-primary focus:ring-primary/20 inline-flex items-center rounded px-2 py-1 text-sm transition-all duration-200 ease-out hover:-translate-y-0.5 hover:scale-105 focus:ring-2 focus:outline-none">
                  #Helix Parallelism
                </a>
              
                <a
                  href="/tags/Tensor-Parallelism/"
                  class="bg-muted/50 text-muted-foreground hover:bg-primary/10 hover:text-primary focus:ring-primary/20 inline-flex items-center rounded px-2 py-1 text-sm transition-all duration-200 ease-out hover:-translate-y-0.5 hover:scale-105 focus:ring-2 focus:outline-none">
                  #Tensor Parallelism
                </a>
              
                <a
                  href="/tags/KV-Parallelism/"
                  class="bg-muted/50 text-muted-foreground hover:bg-primary/10 hover:text-primary focus:ring-primary/20 inline-flex items-center rounded px-2 py-1 text-sm transition-all duration-200 ease-out hover:-translate-y-0.5 hover:scale-105 focus:ring-2 focus:outline-none">
                  #KV Parallelism
                </a>
              
                <a
                  href="/tags/Mixture-of-Experts/"
                  class="bg-muted/50 text-muted-foreground hover:bg-primary/10 hover:text-primary focus:ring-primary/20 inline-flex items-center rounded px-2 py-1 text-sm transition-all duration-200 ease-out hover:-translate-y-0.5 hover:scale-105 focus:ring-2 focus:outline-none">
                  #Mixture of Experts
                </a>
              
                <a
                  href="/tags/Grouped-Query-Attention-GQA/"
                  class="bg-muted/50 text-muted-foreground hover:bg-primary/10 hover:text-primary focus:ring-primary/20 inline-flex items-center rounded px-2 py-1 text-sm transition-all duration-200 ease-out hover:-translate-y-0.5 hover:scale-105 focus:ring-2 focus:outline-none">
                  #Grouped Query Attention (GQA)
                </a>
              
                <a
                  href="/tags/FlashAttention/"
                  class="bg-muted/50 text-muted-foreground hover:bg-primary/10 hover:text-primary focus:ring-primary/20 inline-flex items-center rounded px-2 py-1 text-sm transition-all duration-200 ease-out hover:-translate-y-0.5 hover:scale-105 focus:ring-2 focus:outline-none">
                  #FlashAttention
                </a>
              
                <a
                  href="/tags/Parallelism-for-LLMs/"
                  class="bg-muted/50 text-muted-foreground hover:bg-primary/10 hover:text-primary focus:ring-primary/20 inline-flex items-center rounded px-2 py-1 text-sm transition-all duration-200 ease-out hover:-translate-y-0.5 hover:scale-105 focus:ring-2 focus:outline-none">
                  #Parallelism for LLMs
                </a>
              
                <a
                  href="/tags/System-Aware-ML/"
                  class="bg-muted/50 text-muted-foreground hover:bg-primary/10 hover:text-primary focus:ring-primary/20 inline-flex items-center rounded px-2 py-1 text-sm transition-all duration-200 ease-out hover:-translate-y-0.5 hover:scale-105 focus:ring-2 focus:outline-none">
                  #System-Aware ML
                </a>
              
                <a
                  href="/tags/Efficient-Transformer-Inference/"
                  class="bg-muted/50 text-muted-foreground hover:bg-primary/10 hover:text-primary focus:ring-primary/20 inline-flex items-center rounded px-2 py-1 text-sm transition-all duration-200 ease-out hover:-translate-y-0.5 hover:scale-105 focus:ring-2 focus:outline-none">
                  #Efficient Transformer Inference
                </a>
              
                <a
                  href="/tags/Serving-LLMs-at-Scale/"
                  class="bg-muted/50 text-muted-foreground hover:bg-primary/10 hover:text-primary focus:ring-primary/20 inline-flex items-center rounded px-2 py-1 text-sm transition-all duration-200 ease-out hover:-translate-y-0.5 hover:scale-105 focus:ring-2 focus:outline-none">
                  #Serving LLMs at Scale
                </a>
              
                <a
                  href="/tags/Long-Context-Inference/"
                  class="bg-muted/50 text-muted-foreground hover:bg-primary/10 hover:text-primary focus:ring-primary/20 inline-flex items-center rounded px-2 py-1 text-sm transition-all duration-200 ease-out hover:-translate-y-0.5 hover:scale-105 focus:ring-2 focus:outline-none">
                  #Long Context Inference
                </a>
              
            </div>
          </div>
        

      </div>
    


    
    

  </div>
</div>

  </header>

  
  <article class="prose prose-neutral dark:prose-invert mb-12 max-w-none">
    <p><a href="https://research.nvidia.com/publication/2025-07_helix-parallelism-rethinking-sharding-strategies-interactive-multi-million">논문 링크</a></p>
<h1 id="helix-parallelism-초장기-llm-디코딩의-지연-처리량-벽을-깨다">Helix Parallelism: 초장기 LLM 디코딩의 지연-처리량 벽을 깨다</h1>
<h2 id="한-줄-요약-tldr">한 줄 요약 (TL;DR)</h2>
<p><strong>Helix Parallelism은 Attention과 FFN을 서로 다른 병렬화 전략으로 스케줄링해 KV 캐시 중복과 FFN 가중치 로드 병목을 동시에 해소—1 M 토큰 컨텍스트에서 토큰 지연을 최대 1.5 × 줄이고, 동일 지연 예산으로 동시 사용자 수를 32 × 까지 늘린다.</strong></p>
<hr>
<h2 id="핵심-아이디어">핵심 아이디어</h2>

  <blockquote
    class="border-primary bg-muted/30 hover:bg-muted/40 my-6 rounded-r-lg border-l-4 py-4 pr-4 pl-6 italic transition-all duration-200 ease-out hover:translate-x-1">
    <div class="prose prose-sm max-w-none">
      <p><strong>2-D 샤딩 + 통신 은닉</strong>
Attention 단계에서는 <em>KV Parallelism</em> × <em>Tensor Parallelism</em>으로 KV를 시퀀스-축에 분할해 **중복 0 %**를 달성하고,
곧바로 같은 GPU 풀을 FFN용 <em>Tensor(×Expert) Parallelism</em>으로 재구성해 <strong>가중치 로드를 균등분산</strong>한다.
두 단계 사이의 All-to-All 통신은 <strong>HOP-B 파이프라인</strong>으로 계산과 겹쳐 노출 지연을 최소화한다.</p>
    </div>
  </blockquote>

<hr>
<h2 id="배경-그들이-해결한-문제">배경: 그들이 해결한 문제</h2>
<p>대형 LLM을 “실시간”으로 서빙할 때는 두 가지 상반된 병목이 동시에 발생한다.</p>
<table>
  <thead>
      <tr>
          <th>병목</th>
          <th>원인</th>
          <th>기존 대응</th>
          <th>한계</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>KV 캐시 중복</strong></td>
          <td>TP 폭이 KV-head 수 K보다 크면 각 GPU가 전체 KV 캐시를 복제</td>
          <td>TP, PP</td>
          <td>DRAM 트래픽·메모리 사용 급증 → 지연 평탄화</td>
      </tr>
      <tr>
          <td><strong>FFN 가중치 로드</strong></td>
          <td>KV 캐시를 분할(KVP)하면 FFN 계산은 소수 GPU에 고정</td>
          <td>KVP(Medha)</td>
          <td>KV 문제만 해결, FFN 시간이 TTL의 꼬리 지배</td>
      </tr>
  </tbody>
</table>
<p>결국 **“KV를 나누면 FFN이 느리고, FFN을 나누면 KV가 복제”**되는 택일 구조에서 벗어나지 못했다.</p>
<hr>
<h2 id="새로운-접근법-helix-parallelism">새로운 접근법: <strong>Helix Parallelism</strong></h2>
<p>Helix는 한 레이어 안에서 <strong>시간을 두 토막</strong> 낸다.</p>
<ol>
<li>
<p><strong>Attention</strong> — <code>KV Parallelism (시퀀스)</code> × <code>Tensor Parallelism (헤드)</code></p>
<ul>
<li>
<p>KV 슬라이스별 FlashAttention 수행</p>
</li>
<li>
<p>부분 출력 <strong>Oᵢ</strong> 와 <strong>log-sum-exp LSEᵢ</strong>만 All-to-All →</p>
<p>$$
O = \frac{\sum_i O_i,e^{\text{LSE}_i}}{\sum_i e^{\text{LSE}_i}}
$$</p>
<p>로 정확한 softmax 복원</p>
</li>
</ul>
</li>
<li>
<p><strong>FFN</strong> — 동일 GPU 풀을 즉시 <strong>TP(×EP)</strong> 레이아웃으로 전환</p>
<ul>
<li>All-to-All 후 32-way GEMM, All-Reduce로 합산</li>
</ul>
</li>
<li>
<p><strong>HOP-B</strong> — 토큰 t의 All-to-All을 토큰 t + 1의 FlashAttention과 겹쳐 <strong>통신 은닉</strong></p>
<ul>
<li>노출 통신 시간 ≤ 12 % TTL</li>
</ul>
</li>
</ol>
<hr>
<h2 id="작동-원리-구체적인-예시로-살펴보기">작동 원리: 구체적인 예시로 살펴보기</h2>

  <blockquote
    class="border-primary bg-muted/30 hover:bg-muted/40 my-6 rounded-r-lg border-l-4 py-4 pr-4 pl-6 italic transition-all duration-200 ease-out hover:translate-x-1">
    <div class="prose prose-sm max-w-none">
      <p><strong>Llama-3 70B</strong> | <strong>32× H100</strong> (NVLink node)
Q-heads = 64, K = 8 → <strong>8 TP × 4 KVP = 32 GPU</strong></p>
    </div>
  </blockquote>

<div
  class="code-block-container border-border bg-card my-6 overflow-hidden rounded-xl border shadow-sm transition-all duration-200 ease-out hover:-translate-y-0.5 hover:shadow-md">
  
  <div
    class="code-block-header bg-muted/30 border-border flex items-center justify-between border-b px-4 py-3">
    
    <div class="flex items-center gap-2">
      <div class="text-muted-foreground flex-shrink-0">
        
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4" />
</svg>
      </div>
      <span class="text-muted-foreground text-sm font-medium">
        PLAINTEXT
      </span>
    </div>

    
    <div class="flex items-center gap-2">
      <button
          class="collapse-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
          data-code-id="code-0"
          data-default-state="expanded"
          data-collapsed="false"
          data-auto-collapse-lines="30"
          data-auto-collapse-height="400"
          data-collapsed-height="120"
          title="접기"
          aria-label="접기">
          <span class="collapse-icon">
            
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path fill="currentColor" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z"/></svg>
          </span>
          <span class="collapse-text hidden sm:inline"
            >접기</span
          >
        </button>
      <button
        class="copy-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
        data-code-id="code-0"
        title="복사"
        aria-label="복사">
        <span class="copy-icon">
          
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
</svg>
        </span>
        <span class="copy-text hidden sm:inline"
          >복사</span
        >
      </button>
    </div>
  </div>

  
  <div class="code-block-content relative" id="code-0">
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">KVP Rows   TP Cols → 0 … 7      (총 32 GPU)
</span></span><span class="line"><span class="ln">2</span><span class="cl">Row 0      G0  G1 … G7   (토큰 0‒S/4−1)
</span></span><span class="line"><span class="ln">3</span><span class="cl">Row 1      G8  G9 … G15  (토큰 S/4‒S/2−1)
</span></span><span class="line"><span class="ln">4</span><span class="cl">Row 2      G16 G17 … G23 (토큰 S/2‒3S/4−1)
</span></span><span class="line"><span class="ln">5</span><span class="cl">Row 3      G24 G25 … G31 (토큰 3S/4‒S−1)</span></span></code></pre></div>
    
    <div
      class="collapse-overlay to-card/90 pointer-events-none absolute inset-0 bg-gradient-to-b from-transparent via-transparent opacity-0 transition-opacity duration-300">
      <div
        class="text-muted-foreground bg-card/80 border-border/50 hover:bg-primary/10 hover:text-primary hover:border-primary/30 absolute bottom-4 left-1/2 -translate-x-1/2 cursor-pointer rounded-full border px-3 py-1.5 text-xs backdrop-blur-sm transition-all duration-200">
        클릭하여 더 보기
      </div>
    </div>
  </div>
</div>


<script>
(function() {
  const codeId = 'code-0';
  const copyBtn = document.querySelector('.copy-code-btn[data-code-id="' + codeId + '"]');
  const collapseBtn = document.querySelector('.collapse-code-btn[data-code-id="' + codeId + '"]');
  const codeContainer = document.getElementById(codeId);

  if (!codeContainer) return;

  
  if (copyBtn) {
    const copyIcon = copyBtn.querySelector('.copy-icon');
    const copyText = copyBtn.querySelector('.copy-text');

    copyBtn.addEventListener('click', async function() {
      try {
        
        let codeText = '';

        
        const codeTableCell = codeContainer.querySelector('.lntd:last-child code');
        if (codeTableCell) {
          codeText = codeTableCell.textContent || codeTableCell.innerText;
        } else {
          
          const codeElement = codeContainer.querySelector('code');
          if (codeElement) {
            
            const hasInlineLineNumbers = codeElement.querySelector('.ln');
            if (hasInlineLineNumbers) {
              
              const codeLines = codeElement.querySelectorAll('.cl');
              if (codeLines.length > 0) {
                codeText = Array.from(codeLines)
                  .map(line => {
                    const text = line.textContent || line.innerText;
                    
                    return text.replace(/\n+$/, '');
                  })
                  .join('\n')
                  .replace(/\n+$/, ''); 
              } else {
                
                const allText = codeElement.textContent || codeElement.innerText;
                codeText = allText.replace(/^\d+/gm, '').replace(/^\s+/gm, '');
              }
            } else {
              
              codeText = codeElement.textContent || codeElement.innerText;
            }
          } else {
            
            codeText = codeContainer.textContent || codeContainer.innerText;
          }
        }

        
        codeText = codeText.trim();

        
        await navigator.clipboard.writeText(codeText);

        
        copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M5 13l4 4L19 7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (copyText) {
          copyText.textContent = '복사됨';
        }
        copyBtn.classList.add('text-green-600');

        
        setTimeout(() => {
          copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z\u0022 \/\u003e\n\u003c\/svg\u003e`;
          if (copyText) {
            copyText.textContent = '복사';
          }
          copyBtn.classList.remove('text-green-600');
        }, 2000);

      } catch (err) {
        console.error('复制失败:', err);

        
        const range = document.createRange();
        const codeElement = codeContainer.querySelector('code') || codeContainer;
        range.selectNodeContents(codeElement);
        const selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);

        
        if (copyText) {
          copyText.textContent = '선택됨';
        }

        setTimeout(() => {
          if (copyText) {
            copyText.textContent = '복사';
          }
          selection.removeAllRanges();
        }, 2000);
      }
    });
  }

  
  if (collapseBtn) {
    const collapseIcon = collapseBtn.querySelector('.collapse-icon');
    const collapseText = collapseBtn.querySelector('.collapse-text');
    const collapseOverlay = codeContainer.querySelector('.collapse-overlay');

    
    let codeElement = codeContainer.querySelector('pre.chroma');
    if (!codeElement) {
      codeElement = codeContainer.querySelector('pre');
    }

    const defaultState = collapseBtn.dataset.defaultState || 'expanded';
    const isCollapsedAttr = collapseBtn.dataset.collapsed === 'true';
    const autoCollapseLines = parseInt(collapseBtn.dataset.autoCollapseLines) || 30;
    const autoCollapseHeight = parseInt(collapseBtn.dataset.autoCollapseHeight) || 400;
    const collapsedHeight = parseInt(collapseBtn.dataset.collapsedHeight) || 120;

    let isCollapsed = false;

    
    function initCollapse() {
      
      const shouldCollapse = isCollapsedAttr ||
                           defaultState === 'collapsed' ||
                           shouldAutoCollapse();

      if (shouldCollapse) {
        setCollapsed(true, false); 
      }
    }

    function shouldAutoCollapse() {
      
      if (codeElement) {
        const lines = codeElement.querySelectorAll('.line, .cl');
        const height = codeElement.offsetHeight;
        return lines.length > autoCollapseLines || height > autoCollapseHeight;
      }

      
      const containerHeight = codeContainer.offsetHeight;
      if (containerHeight > autoCollapseHeight) {
        return true;
      }

      
      const textContent = codeContainer.textContent || codeContainer.innerText || '';
      const estimatedLines = textContent.split('\n').length;
      return estimatedLines > autoCollapseLines;
    }

    function setCollapsed(collapsed, animate = true) {
      if (!collapseOverlay) return;

      isCollapsed = collapsed;

      if (collapsed) {
        
        codeContainer.style.maxHeight = collapsedHeight + 'px';
        codeContainer.style.overflow = 'hidden';
        collapseOverlay.style.opacity = '1';
        collapseOverlay.style.pointerEvents = 'auto';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M19 9l-7 7-7-7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '펼치기';
        }
        collapseBtn.title = '펼치기';

      } else {
        
        codeContainer.style.maxHeight = '';
        codeContainer.style.overflow = '';
        collapseOverlay.style.opacity = '0';
        collapseOverlay.style.pointerEvents = 'none';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath fill=\u0022currentColor\u0022 d=\u0022M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z\u0022\/\u003e\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '접기';
        }
        collapseBtn.title = '접기';
      }

      
      if (animate) {
        codeContainer.style.transition = 'max-height 0.3s ease-out';
        setTimeout(() => {
          codeContainer.style.transition = '';
        }, 300);
      }
    }

    function toggleCollapse() {
      setCollapsed(!isCollapsed, true);
    }

    
    collapseBtn.addEventListener('click', toggleCollapse);

    
    if (collapseOverlay) {
      collapseOverlay.addEventListener('click', () => {
        if (isCollapsed) {
          setCollapsed(false, true);
        }
      });
    }

    
    initCollapse();
  }
})();
</script>
<p><em>KV 중복 = 0 %, KV 캐시/GPU ≈ 0.3 GB</em></p>
<p><strong>한 토큰 흐름</strong></p>
<ol>
<li><strong>GPU G<sub>r,c</sub></strong> — 자기 KV-슬라이스에 FlashAttention → (Oᵢ, LSEᵢ)</li>
<li><strong>All-to-All ①</strong> — B·H 규모 데이터 교환</li>
<li><strong>재조합 식</strong>으로 softmax 완성</li>
<li><strong>레이아웃 전환</strong> — All-to-All ②, 데이터가 TP 정렬</li>
<li><strong>32-way TP FFN</strong> → All-Reduce ③</li>
<li><strong>HOP-B</strong> — ①을 다음 토큰의 1단계와 오버랩</li>
</ol>
<p><em>측정치 (1 M ctx)</em>
TTL <strong>9.7 ms</strong> (vs 11 ms), tok s⁻¹ GPU⁻¹ <strong>360</strong> (vs 90),
동시 배치 <strong>4 ×</strong> 확장.</p>
<hr>
<h2 id="성능-검증-주요-결과">성능 검증: 주요 결과</h2>
<table>
  <thead>
      <tr>
          <th>모델</th>
          <th>HW 구성</th>
          <th>TTL ↓</th>
          <th>Batch/Throughput ↑</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>DeepSeek-R1 671 B MoE</td>
          <td>72 GPU</td>
          <td><strong>1.5 ×</strong></td>
          <td><strong>32 ×</strong></td>
      </tr>
      <tr>
          <td>Llama-405 B Dense</td>
          <td>72 GPU</td>
          <td><strong>1.13 ×</strong></td>
          <td><strong>4 ×</strong></td>
      </tr>
      <tr>
          <td>Llama-3 70B (추론)</td>
          <td>32 GPU</td>
          <td><strong>1.13 ×</strong></td>
          <td><strong>4 ×</strong></td>
      </tr>
  </tbody>
</table>
<p><em>Helix 점들이 기존 TP/KVP/PP 조합의 Pareto 프론티어를 통째로 밀어냈다.</em></p>
<hr>
<h2 id="우리의-관점-강점-한계-그리고-이-연구가-중요한-이유">우리의 관점: 강점, 한계, 그리고 이 연구가 중요한 이유</h2>
<h3 id="강점">강점</h3>
<ul>
<li><strong>이중 병목 동시 해결</strong> — KV 중복 없이도 FFN 로드를 균등 분산.</li>
<li><strong>통신량 상수화</strong> — All-to-All이 <em>컨텍스트 길이 S</em>와 독립 → 1 M+ 토큰에도 유지.</li>
<li><strong>정밀도·모델 구조 무관</strong> — FP4/FP8, GQA, MLA, MoE 모두와 즉시 호환.</li>
</ul>
<h3 id="한계">한계</h3>
<ul>
<li><strong>단일 NVLink 노드 전제</strong> — 다중 노드/InfiniBand 구간에선 통신 은닉률 감소.</li>
<li><strong>짧은 문맥·작은 GPU 풀</strong> — <em>G ≤ K</em>이면 Helix 이득이 미미.</li>
<li><strong>품질·에너지 분석 부재</strong> — FP4 정밀도의 수치 안정성, J·token⁻¹ 평가가 빠져 있다.</li>
</ul>
<h3 id="왜-중요한가">왜 중요한가?</h3>
<p>실제 서비스에서 요구되는 것은 “<strong>낮은 지연 + 높은 동시성</strong>”. Helix는 기존 병렬화가 맞닥뜨린 벽(“KV 복제 vs FFN 병목”)을 깔끔히 넘어서, 대형 LLM의 <em>실시간</em> 운용 가능성을 현격히 끌어올렸다.</p>
<hr>
<h2 id="다음-단계는-앞으로의-길">다음 단계는?: 앞으로의 길</h2>
<ol>
<li><strong>희소 어텐션 (NSA) 통합</strong> — KV 대역을 추가 50 % 절감할 잠재력.</li>
<li><strong>멀티-노드 Helix</strong> — Topology-aware All-to-All로 클러스터 스케일 확장.</li>
<li><strong>Adaptive Scheduler</strong> — 실행 중 KV/FFN 비중을 계측해 Helix↔전통 TP 동적 전환.</li>
<li><strong>정밀도·품질 검증</strong> — FP4/FP8 에서 softmax 재스케일의 수치 안정성, 모델 드리프트 테스트.</li>
<li><strong>에너지·비용 지표 공개</strong> — J·token⁻¹, 원·10⁶ tokens⁻¹을 공식 보고해 현실적 ROI를 제시.</li>
</ol>
<p>Helix는 “대형 LLM 실시간 서빙” 퍼즐의 핵심 조각을 맞췄다. 이제 남은 조각은 <strong>분산 토폴로지, 희소 계산, 에너지 효율</strong>—이 퍼즐이 완성되면 <em>million-context</em> LLM은 더 이상 연구실의 데모가 아니라, 누구나 쓰는 일상형 기술이 될 것이다.</p>
<hr>
<h3 id="토글을-클릭하면-논문에-대한-자세한-llm-질의응답-내용을-확인할-수-있습니다">토글을 클릭하면 논문에 대한 자세한 LLM 질의응답 내용을 확인할 수 있습니다.</h3>
<details markdown="block">
<summary>▶️<strong>클릭하여 펼치기</strong></summary>
<h1 id="프롬프트-111-연구의-공백">프롬프트 1.1.1 (연구의 공백)</h1>
<div
  class="code-block-container border-border bg-card my-6 overflow-hidden rounded-xl border shadow-sm transition-all duration-200 ease-out hover:-translate-y-0.5 hover:shadow-md">
  
  <div
    class="code-block-header bg-muted/30 border-border flex items-center justify-between border-b px-4 py-3">
    
    <div class="flex items-center gap-2">
      <div class="text-muted-foreground flex-shrink-0">
        
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4" />
</svg>
      </div>
      <span class="text-muted-foreground text-sm font-medium">
        PLAINTEXT
      </span>
    </div>

    
    <div class="flex items-center gap-2">
      <button
          class="collapse-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
          data-code-id="code-1"
          data-default-state="expanded"
          data-collapsed="false"
          data-auto-collapse-lines="30"
          data-auto-collapse-height="400"
          data-collapsed-height="120"
          title="접기"
          aria-label="접기">
          <span class="collapse-icon">
            
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path fill="currentColor" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z"/></svg>
          </span>
          <span class="collapse-text hidden sm:inline"
            >접기</span
          >
        </button>
      <button
        class="copy-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
        data-code-id="code-1"
        title="복사"
        aria-label="복사">
        <span class="copy-icon">
          
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
</svg>
        </span>
        <span class="copy-text hidden sm:inline"
          >복사</span
        >
      </button>
    </div>
  </div>

  
  <div class="code-block-content relative" id="code-1">
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">&#34;논문의 &#39;Introduction&#39;과 &#39;Related Work&#39; 섹션을 분석하여, 이 연구가 명시적으로 해결하고자 하는 핵심적인 연구 공백(research gap), 기존 연구의 결정적 한계, 또는 미해결 질문이 무엇인지 설명해 줘. 저자들이 설명하는, 이 논문 출판 시점의 &#39;최신 기술(state of the art)&#39;은 어떤 상태였는지 요약해 줘.&#34;</span></span></code></pre></div>
    
    <div
      class="collapse-overlay to-card/90 pointer-events-none absolute inset-0 bg-gradient-to-b from-transparent via-transparent opacity-0 transition-opacity duration-300">
      <div
        class="text-muted-foreground bg-card/80 border-border/50 hover:bg-primary/10 hover:text-primary hover:border-primary/30 absolute bottom-4 left-1/2 -translate-x-1/2 cursor-pointer rounded-full border px-3 py-1.5 text-xs backdrop-blur-sm transition-all duration-200">
        클릭하여 더 보기
      </div>
    </div>
  </div>
</div>


<script>
(function() {
  const codeId = 'code-1';
  const copyBtn = document.querySelector('.copy-code-btn[data-code-id="' + codeId + '"]');
  const collapseBtn = document.querySelector('.collapse-code-btn[data-code-id="' + codeId + '"]');
  const codeContainer = document.getElementById(codeId);

  if (!codeContainer) return;

  
  if (copyBtn) {
    const copyIcon = copyBtn.querySelector('.copy-icon');
    const copyText = copyBtn.querySelector('.copy-text');

    copyBtn.addEventListener('click', async function() {
      try {
        
        let codeText = '';

        
        const codeTableCell = codeContainer.querySelector('.lntd:last-child code');
        if (codeTableCell) {
          codeText = codeTableCell.textContent || codeTableCell.innerText;
        } else {
          
          const codeElement = codeContainer.querySelector('code');
          if (codeElement) {
            
            const hasInlineLineNumbers = codeElement.querySelector('.ln');
            if (hasInlineLineNumbers) {
              
              const codeLines = codeElement.querySelectorAll('.cl');
              if (codeLines.length > 0) {
                codeText = Array.from(codeLines)
                  .map(line => {
                    const text = line.textContent || line.innerText;
                    
                    return text.replace(/\n+$/, '');
                  })
                  .join('\n')
                  .replace(/\n+$/, ''); 
              } else {
                
                const allText = codeElement.textContent || codeElement.innerText;
                codeText = allText.replace(/^\d+/gm, '').replace(/^\s+/gm, '');
              }
            } else {
              
              codeText = codeElement.textContent || codeElement.innerText;
            }
          } else {
            
            codeText = codeContainer.textContent || codeContainer.innerText;
          }
        }

        
        codeText = codeText.trim();

        
        await navigator.clipboard.writeText(codeText);

        
        copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M5 13l4 4L19 7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (copyText) {
          copyText.textContent = '복사됨';
        }
        copyBtn.classList.add('text-green-600');

        
        setTimeout(() => {
          copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z\u0022 \/\u003e\n\u003c\/svg\u003e`;
          if (copyText) {
            copyText.textContent = '복사';
          }
          copyBtn.classList.remove('text-green-600');
        }, 2000);

      } catch (err) {
        console.error('复制失败:', err);

        
        const range = document.createRange();
        const codeElement = codeContainer.querySelector('code') || codeContainer;
        range.selectNodeContents(codeElement);
        const selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);

        
        if (copyText) {
          copyText.textContent = '선택됨';
        }

        setTimeout(() => {
          if (copyText) {
            copyText.textContent = '복사';
          }
          selection.removeAllRanges();
        }, 2000);
      }
    });
  }

  
  if (collapseBtn) {
    const collapseIcon = collapseBtn.querySelector('.collapse-icon');
    const collapseText = collapseBtn.querySelector('.collapse-text');
    const collapseOverlay = codeContainer.querySelector('.collapse-overlay');

    
    let codeElement = codeContainer.querySelector('pre.chroma');
    if (!codeElement) {
      codeElement = codeContainer.querySelector('pre');
    }

    const defaultState = collapseBtn.dataset.defaultState || 'expanded';
    const isCollapsedAttr = collapseBtn.dataset.collapsed === 'true';
    const autoCollapseLines = parseInt(collapseBtn.dataset.autoCollapseLines) || 30;
    const autoCollapseHeight = parseInt(collapseBtn.dataset.autoCollapseHeight) || 400;
    const collapsedHeight = parseInt(collapseBtn.dataset.collapsedHeight) || 120;

    let isCollapsed = false;

    
    function initCollapse() {
      
      const shouldCollapse = isCollapsedAttr ||
                           defaultState === 'collapsed' ||
                           shouldAutoCollapse();

      if (shouldCollapse) {
        setCollapsed(true, false); 
      }
    }

    function shouldAutoCollapse() {
      
      if (codeElement) {
        const lines = codeElement.querySelectorAll('.line, .cl');
        const height = codeElement.offsetHeight;
        return lines.length > autoCollapseLines || height > autoCollapseHeight;
      }

      
      const containerHeight = codeContainer.offsetHeight;
      if (containerHeight > autoCollapseHeight) {
        return true;
      }

      
      const textContent = codeContainer.textContent || codeContainer.innerText || '';
      const estimatedLines = textContent.split('\n').length;
      return estimatedLines > autoCollapseLines;
    }

    function setCollapsed(collapsed, animate = true) {
      if (!collapseOverlay) return;

      isCollapsed = collapsed;

      if (collapsed) {
        
        codeContainer.style.maxHeight = collapsedHeight + 'px';
        codeContainer.style.overflow = 'hidden';
        collapseOverlay.style.opacity = '1';
        collapseOverlay.style.pointerEvents = 'auto';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M19 9l-7 7-7-7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '펼치기';
        }
        collapseBtn.title = '펼치기';

      } else {
        
        codeContainer.style.maxHeight = '';
        codeContainer.style.overflow = '';
        collapseOverlay.style.opacity = '0';
        collapseOverlay.style.pointerEvents = 'none';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath fill=\u0022currentColor\u0022 d=\u0022M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z\u0022\/\u003e\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '접기';
        }
        collapseBtn.title = '접기';
      }

      
      if (animate) {
        codeContainer.style.transition = 'max-height 0.3s ease-out';
        setTimeout(() => {
          codeContainer.style.transition = '';
        }, 300);
      }
    }

    function toggleCollapse() {
      setCollapsed(!isCollapsed, true);
    }

    
    collapseBtn.addEventListener('click', toggleCollapse);

    
    if (collapseOverlay) {
      collapseOverlay.addEventListener('click', () => {
        if (isCollapsed) {
          setCollapsed(false, true);
        }
      });
    }

    
    initCollapse();
  }
})();
</script>
<h3 id="핵심-결론-한-줄-요약">핵심 결론 (한 줄 요약)</h3>
<p><strong>초장기(≥ 10⁶ 토큰) LLM 디코딩에서 기존 병렬화 기법은 KV 캐시 중복 또는 FFN 가중치 로드 병목을 동시에 해결하지 못한다 → Helix Parallelism은 두 단계(어텐션·FFN)를 시간적으로 분리-재구성해 TTL을 최대 1.5× 단축하고 동시 배치 규모를 최대 32× 확장한다.</strong></p>
<hr>
<h2 id="1-연구-공백-및-미해결-질문">1. 연구 공백 및 미해결 질문</h2>
<table>
  <thead>
      <tr>
          <th>기존 접근</th>
          <th>근본 한계</th>
          <th>결과적 병목</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>Tensor Parallelism(TP)</strong></td>
          <td>TP 폭 &gt; KV 헤드 수(K)면 각 GPU가 전체 KV 캐시를 <strong>완전 복제</strong>해야 함</td>
          <td>어텐션 단계 DRAM 대역폭·용량 급증 → TTL 플래토 현상</td>
      </tr>
      <tr>
          <td><strong>KV Parallelism(Medha)</strong></td>
          <td>KV를 시퀀스 차원으로 분할하지만 <strong>FFN은 고정된 TP GPU</strong>(예 8개)에만 수행</td>
          <td>FFN 가중치 로드가 지배적 병목, GPU 활용 저하</td>
      </tr>
      <tr>
          <td><strong>시퀀스/컨텍스트 병렬화 훈련계열(USP·LoongServe 등)</strong></td>
          <td>디코딩 단계의 <strong>실시간 TTL 제약</strong>·인과적 KV 접근 패턴 미반영</td>
          <td>실서비스용 초장기 디코딩에서는 성능 미흡</td>
      </tr>
  </tbody>
</table>
<p><strong>따라서</strong></p>

  <blockquote
    class="border-primary bg-muted/30 hover:bg-muted/40 my-6 rounded-r-lg border-l-4 py-4 pr-4 pl-6 italic transition-all duration-200 ease-out hover:translate-x-1">
    <div class="prose prose-sm max-w-none">
      <p><em>“KV 캐시와 FFN 가중치가 동시에 지배적이 되는 실-시간 초장기 디코딩 환경에서,
  각 단계의 계산·통신 특성에 맞춰 <strong>병렬화 전략을 동적으로 재구성</strong>할 방법이 없다.”</em></p>
    </div>
  </blockquote>

<p>Helix Parallelism은 바로 이 <strong>이중 병목을 해소</strong>하기 위해 고안됨.</p>
<hr>
<h2 id="2-논문-출판-시점의-최신-기술-현황sota-요약">2. 논문 출판 시점의 최신 기술 현황(SOTA) 요약</h2>
<ul>
<li>
<p><strong>모델·하드웨어 조건</strong></p>
<ul>
<li>GQA·MQA·MLA 등으로 <strong>KV 헤드 K ≪ 쿼리 헤드 Q</strong> (예 Q = 128, K = 8).</li>
<li>NVIDIA Blackwell GB200 NVL72 급 GPU → NVLink 도메인 확대, FP4 저정밀 지원.</li>
</ul>
</li>
<li>
<p><strong>지배적 병렬화 조합</strong></p>
<ol>
<li><strong>TP(≤ K)</strong> : KV 중복은 없으나 병렬성 한계, FFN 로드 병목.</li>
<li><strong>TP(&gt; K)</strong> : 병렬성↑ 대신 KV 캐시가 <strong>K 배로 중복</strong>.</li>
<li><strong>TP + PP + EP</strong> : 파이트출·프리필에 효과적이나 디코딩 TTL 감소 한계.</li>
<li><strong>KV Parallelism(Medha)</strong> : KV 캐시를 N GPU로 나누어 <strong>DRAM 로드 O(S/N)</strong> 로 완화하지만,
<em>FFN 계층은 여전히 K GPU에서만 수행</em> → 가중치 로드 지연이 TTL 우측꼬리 차지.</li>
</ol>
</li>
<li>
<p><strong>성능 한계 수치 예시</strong></p>
<ul>
<li>TP 단독 (GQA, K = 8) → TP 폭이 8 을 넘는 순간 <strong>KV 캐시 사이즈·읽기 시간 더 이상 감소하지 않음</strong>.</li>
<li>Medha + Blackwell 환경 → KV 캐시 문제는 해결되나 <strong>DeepSeek-R1 (MoE) 기준 TTL 50 % 이상이 FFN 로드</strong>가 차지.</li>
</ul>
</li>
</ul>
<hr>
<h3 id="helix가-제시하는-숫자-기반-개선폭">Helix가 제시하는 숫자 기반 개선폭</h3>
<table>
  <thead>
      <tr>
          <th>모델</th>
          <th>TTL 개선</th>
          <th>동시 배치 규모</th>
          <th>토큰/s/GPU 향상</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>DeepSeek-R1 (671 B MoE)</strong></td>
          <td><strong>1.5× ↓</strong></td>
          <td><strong>32× ↑</strong></td>
          <td>N/A (동일 TTL에서 32× batch)</td>
      </tr>
      <tr>
          <td><strong>Llama-405 B Dense</strong></td>
          <td><strong>1.13× ↓</strong></td>
          <td>4× ↑</td>
          <td>4× ↑</td>
      </tr>
  </tbody>
</table>

  <blockquote
    class="border-primary bg-muted/30 hover:bg-muted/40 my-6 rounded-r-lg border-l-4 py-4 pr-4 pl-6 italic transition-all duration-200 ease-out hover:translate-x-1">
    <div class="prose prose-sm max-w-none">
      <p>즉, Helix는 <strong>KV 캐시를 KVP로 시퀀스 분할</strong>하면서 <strong>동일 GPU 풀을 FFN 단계에서 TP 또는 TP × EP로 즉시 재구성</strong>하는 <em>시간적 파이프라인</em>을 통해 기존 SOTA 대비 <strong>Pareto 프론티어를 바깥으로 밀어냈다</strong>.</p>
    </div>
  </blockquote>

<hr>
<p><strong>요약</strong>: 기존 TP·KVP 구조는 <em>KV 중복</em> 또는 <em>FFN 병목</em> 중 하나만 완화했을 뿐, 두 병목을 동시에 해결하지 못했다. Helix Parallelism은 어텐션과 FFN을 <strong>단계별 맞춤 병렬화</strong>로 분리-재사용하여 초장기 컨텍스트에서도 실시간 LLM 서비스의 <strong>효율·대기시간 한계</strong>를 돌파했다.</p>
<h1 id="프롬프트-112-핵심-가설">프롬프트 1.1.2 (핵심 가설)</h1>
<div
  class="code-block-container border-border bg-card my-6 overflow-hidden rounded-xl border shadow-sm transition-all duration-200 ease-out hover:-translate-y-0.5 hover:shadow-md">
  
  <div
    class="code-block-header bg-muted/30 border-border flex items-center justify-between border-b px-4 py-3">
    
    <div class="flex items-center gap-2">
      <div class="text-muted-foreground flex-shrink-0">
        
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4" />
</svg>
      </div>
      <span class="text-muted-foreground text-sm font-medium">
        PLAINTEXT
      </span>
    </div>

    
    <div class="flex items-center gap-2">
      <button
          class="collapse-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
          data-code-id="code-2"
          data-default-state="expanded"
          data-collapsed="false"
          data-auto-collapse-lines="30"
          data-auto-collapse-height="400"
          data-collapsed-height="120"
          title="접기"
          aria-label="접기">
          <span class="collapse-icon">
            
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path fill="currentColor" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z"/></svg>
          </span>
          <span class="collapse-text hidden sm:inline"
            >접기</span
          >
        </button>
      <button
        class="copy-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
        data-code-id="code-2"
        title="복사"
        aria-label="복사">
        <span class="copy-icon">
          
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
</svg>
        </span>
        <span class="copy-text hidden sm:inline"
          >복사</span
        >
      </button>
    </div>
  </div>

  
  <div class="code-block-content relative" id="code-2">
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">&#34;이 논문의 중심 가설(central hypothesis) 또는 핵심 주장은 무엇인가? &#39;저자들은 [제안 기법]을 사용함으로써 [기존 한계점]을 극복하는 [구체적 결과]를 달성할 수 있다고 가정한다&#39;와 같은 형식으로, 명확하고 간결한 한 문장으로 서술해 줘.&#34;</span></span></code></pre></div>
    
    <div
      class="collapse-overlay to-card/90 pointer-events-none absolute inset-0 bg-gradient-to-b from-transparent via-transparent opacity-0 transition-opacity duration-300">
      <div
        class="text-muted-foreground bg-card/80 border-border/50 hover:bg-primary/10 hover:text-primary hover:border-primary/30 absolute bottom-4 left-1/2 -translate-x-1/2 cursor-pointer rounded-full border px-3 py-1.5 text-xs backdrop-blur-sm transition-all duration-200">
        클릭하여 더 보기
      </div>
    </div>
  </div>
</div>


<script>
(function() {
  const codeId = 'code-2';
  const copyBtn = document.querySelector('.copy-code-btn[data-code-id="' + codeId + '"]');
  const collapseBtn = document.querySelector('.collapse-code-btn[data-code-id="' + codeId + '"]');
  const codeContainer = document.getElementById(codeId);

  if (!codeContainer) return;

  
  if (copyBtn) {
    const copyIcon = copyBtn.querySelector('.copy-icon');
    const copyText = copyBtn.querySelector('.copy-text');

    copyBtn.addEventListener('click', async function() {
      try {
        
        let codeText = '';

        
        const codeTableCell = codeContainer.querySelector('.lntd:last-child code');
        if (codeTableCell) {
          codeText = codeTableCell.textContent || codeTableCell.innerText;
        } else {
          
          const codeElement = codeContainer.querySelector('code');
          if (codeElement) {
            
            const hasInlineLineNumbers = codeElement.querySelector('.ln');
            if (hasInlineLineNumbers) {
              
              const codeLines = codeElement.querySelectorAll('.cl');
              if (codeLines.length > 0) {
                codeText = Array.from(codeLines)
                  .map(line => {
                    const text = line.textContent || line.innerText;
                    
                    return text.replace(/\n+$/, '');
                  })
                  .join('\n')
                  .replace(/\n+$/, ''); 
              } else {
                
                const allText = codeElement.textContent || codeElement.innerText;
                codeText = allText.replace(/^\d+/gm, '').replace(/^\s+/gm, '');
              }
            } else {
              
              codeText = codeElement.textContent || codeElement.innerText;
            }
          } else {
            
            codeText = codeContainer.textContent || codeContainer.innerText;
          }
        }

        
        codeText = codeText.trim();

        
        await navigator.clipboard.writeText(codeText);

        
        copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M5 13l4 4L19 7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (copyText) {
          copyText.textContent = '복사됨';
        }
        copyBtn.classList.add('text-green-600');

        
        setTimeout(() => {
          copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z\u0022 \/\u003e\n\u003c\/svg\u003e`;
          if (copyText) {
            copyText.textContent = '복사';
          }
          copyBtn.classList.remove('text-green-600');
        }, 2000);

      } catch (err) {
        console.error('复制失败:', err);

        
        const range = document.createRange();
        const codeElement = codeContainer.querySelector('code') || codeContainer;
        range.selectNodeContents(codeElement);
        const selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);

        
        if (copyText) {
          copyText.textContent = '선택됨';
        }

        setTimeout(() => {
          if (copyText) {
            copyText.textContent = '복사';
          }
          selection.removeAllRanges();
        }, 2000);
      }
    });
  }

  
  if (collapseBtn) {
    const collapseIcon = collapseBtn.querySelector('.collapse-icon');
    const collapseText = collapseBtn.querySelector('.collapse-text');
    const collapseOverlay = codeContainer.querySelector('.collapse-overlay');

    
    let codeElement = codeContainer.querySelector('pre.chroma');
    if (!codeElement) {
      codeElement = codeContainer.querySelector('pre');
    }

    const defaultState = collapseBtn.dataset.defaultState || 'expanded';
    const isCollapsedAttr = collapseBtn.dataset.collapsed === 'true';
    const autoCollapseLines = parseInt(collapseBtn.dataset.autoCollapseLines) || 30;
    const autoCollapseHeight = parseInt(collapseBtn.dataset.autoCollapseHeight) || 400;
    const collapsedHeight = parseInt(collapseBtn.dataset.collapsedHeight) || 120;

    let isCollapsed = false;

    
    function initCollapse() {
      
      const shouldCollapse = isCollapsedAttr ||
                           defaultState === 'collapsed' ||
                           shouldAutoCollapse();

      if (shouldCollapse) {
        setCollapsed(true, false); 
      }
    }

    function shouldAutoCollapse() {
      
      if (codeElement) {
        const lines = codeElement.querySelectorAll('.line, .cl');
        const height = codeElement.offsetHeight;
        return lines.length > autoCollapseLines || height > autoCollapseHeight;
      }

      
      const containerHeight = codeContainer.offsetHeight;
      if (containerHeight > autoCollapseHeight) {
        return true;
      }

      
      const textContent = codeContainer.textContent || codeContainer.innerText || '';
      const estimatedLines = textContent.split('\n').length;
      return estimatedLines > autoCollapseLines;
    }

    function setCollapsed(collapsed, animate = true) {
      if (!collapseOverlay) return;

      isCollapsed = collapsed;

      if (collapsed) {
        
        codeContainer.style.maxHeight = collapsedHeight + 'px';
        codeContainer.style.overflow = 'hidden';
        collapseOverlay.style.opacity = '1';
        collapseOverlay.style.pointerEvents = 'auto';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M19 9l-7 7-7-7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '펼치기';
        }
        collapseBtn.title = '펼치기';

      } else {
        
        codeContainer.style.maxHeight = '';
        codeContainer.style.overflow = '';
        collapseOverlay.style.opacity = '0';
        collapseOverlay.style.pointerEvents = 'none';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath fill=\u0022currentColor\u0022 d=\u0022M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z\u0022\/\u003e\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '접기';
        }
        collapseBtn.title = '접기';
      }

      
      if (animate) {
        codeContainer.style.transition = 'max-height 0.3s ease-out';
        setTimeout(() => {
          codeContainer.style.transition = '';
        }, 300);
      }
    }

    function toggleCollapse() {
      setCollapsed(!isCollapsed, true);
    }

    
    collapseBtn.addEventListener('click', toggleCollapse);

    
    if (collapseOverlay) {
      collapseOverlay.addEventListener('click', () => {
        if (isCollapsed) {
          setCollapsed(false, true);
        }
      });
    }

    
    initCollapse();
  }
})();
</script>
<p>**저자들은 Helix Parallelism(통신-은닉 HOP-B 포함)을 사용함으로써 초장기(≥10⁶ 토큰) LLM 디코딩에서 KV 캐시 중복과 FFN 가중치 읽기 병목을 동시에 극복하여 토큰-간 지연을 최대 1.5 × 단축하고, 동일 TTL 예산에서 동시 배치 규모를 32 × 까지 확장할 수 있다고 가정한다.</p>
<h1 id="프롬프트-121-독창성-식별">프롬프트 1.2.1 (독창성 식별)</h1>
<div
  class="code-block-container border-border bg-card my-6 overflow-hidden rounded-xl border shadow-sm transition-all duration-200 ease-out hover:-translate-y-0.5 hover:shadow-md">
  
  <div
    class="code-block-header bg-muted/30 border-border flex items-center justify-between border-b px-4 py-3">
    
    <div class="flex items-center gap-2">
      <div class="text-muted-foreground flex-shrink-0">
        
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4" />
</svg>
      </div>
      <span class="text-muted-foreground text-sm font-medium">
        PLAINTEXT
      </span>
    </div>

    
    <div class="flex items-center gap-2">
      <button
          class="collapse-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
          data-code-id="code-3"
          data-default-state="expanded"
          data-collapsed="false"
          data-auto-collapse-lines="30"
          data-auto-collapse-height="400"
          data-collapsed-height="120"
          title="접기"
          aria-label="접기">
          <span class="collapse-icon">
            
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path fill="currentColor" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z"/></svg>
          </span>
          <span class="collapse-text hidden sm:inline"
            >접기</span
          >
        </button>
      <button
        class="copy-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
        data-code-id="code-3"
        title="복사"
        aria-label="복사">
        <span class="copy-icon">
          
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
</svg>
        </span>
        <span class="copy-text hidden sm:inline"
          >복사</span
        >
      </button>
    </div>
  </div>

  
  <div class="code-block-content relative" id="code-3">
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl"> &#34;논문 전체를 바탕으로, 가장 중요하고 독창적인 기여(contribution) 1~3가지를 구별되는 항목으로 나열해 줘. 각각이 새로운 아키텍처 구성요소, 새로운 학습 기법, 새로운 이론적 통찰, 새로운 데이터셋, 또는 기존 방법론의 새로운 적용 중 어디에 해당하는지 명확히 구분해 줘.&#34;</span></span></code></pre></div>
    
    <div
      class="collapse-overlay to-card/90 pointer-events-none absolute inset-0 bg-gradient-to-b from-transparent via-transparent opacity-0 transition-opacity duration-300">
      <div
        class="text-muted-foreground bg-card/80 border-border/50 hover:bg-primary/10 hover:text-primary hover:border-primary/30 absolute bottom-4 left-1/2 -translate-x-1/2 cursor-pointer rounded-full border px-3 py-1.5 text-xs backdrop-blur-sm transition-all duration-200">
        클릭하여 더 보기
      </div>
    </div>
  </div>
</div>


<script>
(function() {
  const codeId = 'code-3';
  const copyBtn = document.querySelector('.copy-code-btn[data-code-id="' + codeId + '"]');
  const collapseBtn = document.querySelector('.collapse-code-btn[data-code-id="' + codeId + '"]');
  const codeContainer = document.getElementById(codeId);

  if (!codeContainer) return;

  
  if (copyBtn) {
    const copyIcon = copyBtn.querySelector('.copy-icon');
    const copyText = copyBtn.querySelector('.copy-text');

    copyBtn.addEventListener('click', async function() {
      try {
        
        let codeText = '';

        
        const codeTableCell = codeContainer.querySelector('.lntd:last-child code');
        if (codeTableCell) {
          codeText = codeTableCell.textContent || codeTableCell.innerText;
        } else {
          
          const codeElement = codeContainer.querySelector('code');
          if (codeElement) {
            
            const hasInlineLineNumbers = codeElement.querySelector('.ln');
            if (hasInlineLineNumbers) {
              
              const codeLines = codeElement.querySelectorAll('.cl');
              if (codeLines.length > 0) {
                codeText = Array.from(codeLines)
                  .map(line => {
                    const text = line.textContent || line.innerText;
                    
                    return text.replace(/\n+$/, '');
                  })
                  .join('\n')
                  .replace(/\n+$/, ''); 
              } else {
                
                const allText = codeElement.textContent || codeElement.innerText;
                codeText = allText.replace(/^\d+/gm, '').replace(/^\s+/gm, '');
              }
            } else {
              
              codeText = codeElement.textContent || codeElement.innerText;
            }
          } else {
            
            codeText = codeContainer.textContent || codeContainer.innerText;
          }
        }

        
        codeText = codeText.trim();

        
        await navigator.clipboard.writeText(codeText);

        
        copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M5 13l4 4L19 7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (copyText) {
          copyText.textContent = '복사됨';
        }
        copyBtn.classList.add('text-green-600');

        
        setTimeout(() => {
          copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z\u0022 \/\u003e\n\u003c\/svg\u003e`;
          if (copyText) {
            copyText.textContent = '복사';
          }
          copyBtn.classList.remove('text-green-600');
        }, 2000);

      } catch (err) {
        console.error('复制失败:', err);

        
        const range = document.createRange();
        const codeElement = codeContainer.querySelector('code') || codeContainer;
        range.selectNodeContents(codeElement);
        const selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);

        
        if (copyText) {
          copyText.textContent = '선택됨';
        }

        setTimeout(() => {
          if (copyText) {
            copyText.textContent = '복사';
          }
          selection.removeAllRanges();
        }, 2000);
      }
    });
  }

  
  if (collapseBtn) {
    const collapseIcon = collapseBtn.querySelector('.collapse-icon');
    const collapseText = collapseBtn.querySelector('.collapse-text');
    const collapseOverlay = codeContainer.querySelector('.collapse-overlay');

    
    let codeElement = codeContainer.querySelector('pre.chroma');
    if (!codeElement) {
      codeElement = codeContainer.querySelector('pre');
    }

    const defaultState = collapseBtn.dataset.defaultState || 'expanded';
    const isCollapsedAttr = collapseBtn.dataset.collapsed === 'true';
    const autoCollapseLines = parseInt(collapseBtn.dataset.autoCollapseLines) || 30;
    const autoCollapseHeight = parseInt(collapseBtn.dataset.autoCollapseHeight) || 400;
    const collapsedHeight = parseInt(collapseBtn.dataset.collapsedHeight) || 120;

    let isCollapsed = false;

    
    function initCollapse() {
      
      const shouldCollapse = isCollapsedAttr ||
                           defaultState === 'collapsed' ||
                           shouldAutoCollapse();

      if (shouldCollapse) {
        setCollapsed(true, false); 
      }
    }

    function shouldAutoCollapse() {
      
      if (codeElement) {
        const lines = codeElement.querySelectorAll('.line, .cl');
        const height = codeElement.offsetHeight;
        return lines.length > autoCollapseLines || height > autoCollapseHeight;
      }

      
      const containerHeight = codeContainer.offsetHeight;
      if (containerHeight > autoCollapseHeight) {
        return true;
      }

      
      const textContent = codeContainer.textContent || codeContainer.innerText || '';
      const estimatedLines = textContent.split('\n').length;
      return estimatedLines > autoCollapseLines;
    }

    function setCollapsed(collapsed, animate = true) {
      if (!collapseOverlay) return;

      isCollapsed = collapsed;

      if (collapsed) {
        
        codeContainer.style.maxHeight = collapsedHeight + 'px';
        codeContainer.style.overflow = 'hidden';
        collapseOverlay.style.opacity = '1';
        collapseOverlay.style.pointerEvents = 'auto';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M19 9l-7 7-7-7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '펼치기';
        }
        collapseBtn.title = '펼치기';

      } else {
        
        codeContainer.style.maxHeight = '';
        codeContainer.style.overflow = '';
        collapseOverlay.style.opacity = '0';
        collapseOverlay.style.pointerEvents = 'none';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath fill=\u0022currentColor\u0022 d=\u0022M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z\u0022\/\u003e\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '접기';
        }
        collapseBtn.title = '접기';
      }

      
      if (animate) {
        codeContainer.style.transition = 'max-height 0.3s ease-out';
        setTimeout(() => {
          codeContainer.style.transition = '';
        }, 300);
      }
    }

    function toggleCollapse() {
      setCollapsed(!isCollapsed, true);
    }

    
    collapseBtn.addEventListener('click', toggleCollapse);

    
    if (collapseOverlay) {
      collapseOverlay.addEventListener('click', () => {
        if (isCollapsed) {
          setCollapsed(false, true);
        }
      });
    }

    
    initCollapse();
  }
})();
</script>
<h3 id="한눈에-결론">한눈에 결론</h3>
<p><strong>Helix Parallelism + HOP-B가 초장기(≥10⁶ 토큰) LLM 디코딩에서 TTL을 최대 1.5 × 단축하고, 동일 TTL 예산에서 동시 배치 규모를 최대 32 ×까지 확장한다.</strong></p>
<hr>
<h2 id="helix-논문의-독창적-기여-3선">Helix 논문의 독창적 기여 3선</h2>
<table>
  <thead>
      <tr>
          <th>#</th>
          <th>기여</th>
          <th>분류</th>
          <th>핵심 성과·수치</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>1</strong></td>
          <td><strong>Helix Parallelism</strong><br>— Attention 단계에서는 <strong>KV Parallelism</strong>(시퀀스 축 분할) × <strong>Tensor Parallelism</strong>(≤ K)으로 KV 중복 0%; <br>— 같은 GPU 풀을 FFN 단계에 즉시 재구성하여 <strong>TP 또는 TP×EP</strong>로 가중치 로드 병목 제거</td>
          <td><strong>새로운 아키텍처 구성요소</strong> (하이브리드 시공간 파이프라인 샤딩)</td>
          <td>• KV 중복 제거로 DRAM 트래픽 ↓, FFN 로드 분산<br>• DeepSeek-R1 기준 TTL 50 %↓, 배치 32 ×↑</td>
      </tr>
      <tr>
          <td><strong>2</strong></td>
          <td><strong>Helix HOP-B</strong> (Helix Overlap Pipeline-Batchwise)<br>— Query별 All-to-All 통신을 바로 시작해 다음 Query 계산과 겹쳐 실행</td>
          <td><strong>새로운 아키텍처 구성요소</strong> (통신-은닉 최적화)</td>
          <td>• 통신-계산 겹침으로 노출 통신 시간→0 ~ 12 % TTL↓ (모델·배치에 따라)</td>
      </tr>
      <tr>
          <td><strong>3</strong></td>
          <td><strong>2D Roofline 분석 + 10만 건 시뮬레이션으로 도출한 Pareto 프론티어</strong><br>— TP &gt; K에서 KV 복제 플래토, KVP만으로는 FFN 병목 지속 등 이중 병목을 정량 규명</td>
          <td><strong>새로운 이론적 통찰</strong> + <strong>기존 방법론의 새로운 적용</strong> (초장기 디코딩 하드웨어-의식 성능 모델링)</td>
          <td>• KV·FFN DRAM-읽기 한계선을 시각화해 Helix 설계 근거 제시</td>
      </tr>
  </tbody>
</table>

  <blockquote
    class="border-primary bg-muted/30 hover:bg-muted/40 my-6 rounded-r-lg border-l-4 py-4 pr-4 pl-6 italic transition-all duration-200 ease-out hover:translate-x-1">
    <div class="prose prose-sm max-w-none">
      <p><strong>요약</strong>
Helix Parallelism은 단계별 맞춤 샤딩, HOP-B는 통신 은닉으로 GPU 활용률을 극대화하며, 이론·실험 분석이 이를 정량적으로 뒷받침한다.</p>
    </div>
  </blockquote>

<h1 id="프롬프트-122-저자-관점에서의-강점">프롬프트 1.2.2 (저자 관점에서의 강점)</h1>
<div
  class="code-block-container border-border bg-card my-6 overflow-hidden rounded-xl border shadow-sm transition-all duration-200 ease-out hover:-translate-y-0.5 hover:shadow-md">
  
  <div
    class="code-block-header bg-muted/30 border-border flex items-center justify-between border-b px-4 py-3">
    
    <div class="flex items-center gap-2">
      <div class="text-muted-foreground flex-shrink-0">
        
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4" />
</svg>
      </div>
      <span class="text-muted-foreground text-sm font-medium">
        PLAINTEXT
      </span>
    </div>

    
    <div class="flex items-center gap-2">
      <button
          class="collapse-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
          data-code-id="code-4"
          data-default-state="expanded"
          data-collapsed="false"
          data-auto-collapse-lines="30"
          data-auto-collapse-height="400"
          data-collapsed-height="120"
          title="접기"
          aria-label="접기">
          <span class="collapse-icon">
            
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path fill="currentColor" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z"/></svg>
          </span>
          <span class="collapse-text hidden sm:inline"
            >접기</span
          >
        </button>
      <button
        class="copy-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
        data-code-id="code-4"
        title="복사"
        aria-label="복사">
        <span class="copy-icon">
          
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
</svg>
        </span>
        <span class="copy-text hidden sm:inline"
          >복사</span
        >
      </button>
    </div>
  </div>

  
  <div class="code-block-content relative" id="code-4">
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">&#34;저자들의 관점에서, 자신들의 접근법이 이전 방법들보다 우월한 이유는 무엇인가? 그들이 자신들의 연구가 지닌 독창성과 강점을 뒷받침하기 위해 사용하는 핵심 논거를 인용하거나 알기 쉽게 설명해 줘.&#34;</span></span></code></pre></div>
    
    <div
      class="collapse-overlay to-card/90 pointer-events-none absolute inset-0 bg-gradient-to-b from-transparent via-transparent opacity-0 transition-opacity duration-300">
      <div
        class="text-muted-foreground bg-card/80 border-border/50 hover:bg-primary/10 hover:text-primary hover:border-primary/30 absolute bottom-4 left-1/2 -translate-x-1/2 cursor-pointer rounded-full border px-3 py-1.5 text-xs backdrop-blur-sm transition-all duration-200">
        클릭하여 더 보기
      </div>
    </div>
  </div>
</div>


<script>
(function() {
  const codeId = 'code-4';
  const copyBtn = document.querySelector('.copy-code-btn[data-code-id="' + codeId + '"]');
  const collapseBtn = document.querySelector('.collapse-code-btn[data-code-id="' + codeId + '"]');
  const codeContainer = document.getElementById(codeId);

  if (!codeContainer) return;

  
  if (copyBtn) {
    const copyIcon = copyBtn.querySelector('.copy-icon');
    const copyText = copyBtn.querySelector('.copy-text');

    copyBtn.addEventListener('click', async function() {
      try {
        
        let codeText = '';

        
        const codeTableCell = codeContainer.querySelector('.lntd:last-child code');
        if (codeTableCell) {
          codeText = codeTableCell.textContent || codeTableCell.innerText;
        } else {
          
          const codeElement = codeContainer.querySelector('code');
          if (codeElement) {
            
            const hasInlineLineNumbers = codeElement.querySelector('.ln');
            if (hasInlineLineNumbers) {
              
              const codeLines = codeElement.querySelectorAll('.cl');
              if (codeLines.length > 0) {
                codeText = Array.from(codeLines)
                  .map(line => {
                    const text = line.textContent || line.innerText;
                    
                    return text.replace(/\n+$/, '');
                  })
                  .join('\n')
                  .replace(/\n+$/, ''); 
              } else {
                
                const allText = codeElement.textContent || codeElement.innerText;
                codeText = allText.replace(/^\d+/gm, '').replace(/^\s+/gm, '');
              }
            } else {
              
              codeText = codeElement.textContent || codeElement.innerText;
            }
          } else {
            
            codeText = codeContainer.textContent || codeContainer.innerText;
          }
        }

        
        codeText = codeText.trim();

        
        await navigator.clipboard.writeText(codeText);

        
        copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M5 13l4 4L19 7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (copyText) {
          copyText.textContent = '복사됨';
        }
        copyBtn.classList.add('text-green-600');

        
        setTimeout(() => {
          copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z\u0022 \/\u003e\n\u003c\/svg\u003e`;
          if (copyText) {
            copyText.textContent = '복사';
          }
          copyBtn.classList.remove('text-green-600');
        }, 2000);

      } catch (err) {
        console.error('复制失败:', err);

        
        const range = document.createRange();
        const codeElement = codeContainer.querySelector('code') || codeContainer;
        range.selectNodeContents(codeElement);
        const selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);

        
        if (copyText) {
          copyText.textContent = '선택됨';
        }

        setTimeout(() => {
          if (copyText) {
            copyText.textContent = '복사';
          }
          selection.removeAllRanges();
        }, 2000);
      }
    });
  }

  
  if (collapseBtn) {
    const collapseIcon = collapseBtn.querySelector('.collapse-icon');
    const collapseText = collapseBtn.querySelector('.collapse-text');
    const collapseOverlay = codeContainer.querySelector('.collapse-overlay');

    
    let codeElement = codeContainer.querySelector('pre.chroma');
    if (!codeElement) {
      codeElement = codeContainer.querySelector('pre');
    }

    const defaultState = collapseBtn.dataset.defaultState || 'expanded';
    const isCollapsedAttr = collapseBtn.dataset.collapsed === 'true';
    const autoCollapseLines = parseInt(collapseBtn.dataset.autoCollapseLines) || 30;
    const autoCollapseHeight = parseInt(collapseBtn.dataset.autoCollapseHeight) || 400;
    const collapsedHeight = parseInt(collapseBtn.dataset.collapsedHeight) || 120;

    let isCollapsed = false;

    
    function initCollapse() {
      
      const shouldCollapse = isCollapsedAttr ||
                           defaultState === 'collapsed' ||
                           shouldAutoCollapse();

      if (shouldCollapse) {
        setCollapsed(true, false); 
      }
    }

    function shouldAutoCollapse() {
      
      if (codeElement) {
        const lines = codeElement.querySelectorAll('.line, .cl');
        const height = codeElement.offsetHeight;
        return lines.length > autoCollapseLines || height > autoCollapseHeight;
      }

      
      const containerHeight = codeContainer.offsetHeight;
      if (containerHeight > autoCollapseHeight) {
        return true;
      }

      
      const textContent = codeContainer.textContent || codeContainer.innerText || '';
      const estimatedLines = textContent.split('\n').length;
      return estimatedLines > autoCollapseLines;
    }

    function setCollapsed(collapsed, animate = true) {
      if (!collapseOverlay) return;

      isCollapsed = collapsed;

      if (collapsed) {
        
        codeContainer.style.maxHeight = collapsedHeight + 'px';
        codeContainer.style.overflow = 'hidden';
        collapseOverlay.style.opacity = '1';
        collapseOverlay.style.pointerEvents = 'auto';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M19 9l-7 7-7-7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '펼치기';
        }
        collapseBtn.title = '펼치기';

      } else {
        
        codeContainer.style.maxHeight = '';
        codeContainer.style.overflow = '';
        collapseOverlay.style.opacity = '0';
        collapseOverlay.style.pointerEvents = 'none';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath fill=\u0022currentColor\u0022 d=\u0022M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z\u0022\/\u003e\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '접기';
        }
        collapseBtn.title = '접기';
      }

      
      if (animate) {
        codeContainer.style.transition = 'max-height 0.3s ease-out';
        setTimeout(() => {
          codeContainer.style.transition = '';
        }, 300);
      }
    }

    function toggleCollapse() {
      setCollapsed(!isCollapsed, true);
    }

    
    collapseBtn.addEventListener('click', toggleCollapse);

    
    if (collapseOverlay) {
      collapseOverlay.addEventListener('click', () => {
        if (isCollapsed) {
          setCollapsed(false, true);
        }
      });
    }

    
    initCollapse();
  }
})();
</script>
<p><strong>한 줄 요약 | Helix Parallelism은 KV 캐시와 FFN 가중치라는 ‘이중 병목’을 단계별 맞춤 샤딩·통신 은닉(HOP-B)으로 깨 실서비스 TTL을 최대 1.5× 단축하고, 동일 지연 한도 내 동시 사용자 수를 최대 32× 늘린다고 저자들은 주장한다.</strong></p>
<hr>
<h2 id="저자-관점에서-내세우는-3가지-우월성-논거">저자 관점에서 내세우는 3가지 ‘우월성’ 논거</h2>
<table>
  <thead>
      <tr>
          <th>#</th>
          <th>왜 기존보다 낫나? (저자 주장)</th>
          <th>핵심 증거·수치</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>1. “이중 병목 동시 해결”</strong><br> <em>KV 중복 없이도 FFN을 풀-TP/TP×EP로 분산</em></td>
          <td>- Attention 단계는 <strong>KVP×TP</strong>로 KV를 시퀀스 축에 분할해 DRAM 읽기·용량을 <strong>선형→아래로</strong> 꺾음<br>- 곧바로 같은 GPU 풀을 FFN 단계에 재구성, 가중치 로드를 N GPU에 분산 → <strong>KV 중복 0 %, FFN 병목 제거</strong></td>
          <td>Roofline 분석: TP &gt; K 구간서 KV 읽기 지연 ‘플래토’, Helix는 2D 샤딩으로 완전 회피</td>
      </tr>
      <tr>
          <td><strong>2. “통신-은닉형 HOP-B”</strong><br> <em>All-to-All 통신을 다음 토큰 계산과 겹침</em></td>
          <td>배치 차원 파이프라인으로 <strong>노출 통신 시간 0 – 12 %로 수렴</strong>, Llama-405B 기준 HOP-B OFF 대비 TTL 12 %↓ 회복</td>
          <td>Ablation: HOP-B ON ↔ OFF 비교 실험 · TTL 이득 최대 12 %</td>
      </tr>
      <tr>
          <td><strong>3. “Pareto 프론티어 외부로 확장”</strong></td>
          <td>DeepSeek-R1 1 M ctx → <strong>TTL 1.5×↓ &amp; 32× 더 많은 동시 배치</strong><br>Llama-405B 1 M ctx → <strong>TTL 1.13×↓ &amp; 4× TPS/GPU↑</strong></td>
          <td>10만 개 샤딩·배치 시뮬레이션에서 Helix가 기존 TP·KVP 조합보다 우상향 프론티어 달성</td>
      </tr>
  </tbody>
</table>
<hr>
<h3 id="추가-근거-텍스트-인용-중심">추가 근거 (텍스트 인용 중심)</h3>
<ul>
<li><strong>KV 캐시 독립 통신량</strong> – Helix의 All-to-All은 KV 길이 <em>S</em>와 무관, <em>B·H</em>에만 비례해 초장기 컨텍스트에서도 스케일 손실이 없다.</li>
<li><strong>현대 GPU·주의 메커니즘 호환성</strong> – Blackwell NVLink 대역·FP4 저정밀, MLA·GQA·MoE 등 최신 모델 구조와 즉시 호환돼 “새 하드웨어가 나올수록 이득폭이 커진다”고 강조.</li>
<li><strong>Medha·TP 대비 비교</strong> – Medha는 KV 분할 뒤 FFN을 고정 K GPU에서만 수행해 “FFN 로드가 TTL 우측꼬리 지배” 문제를 남긴다는 점을 수치로 지적.</li>
</ul>

  <blockquote
    class="border-primary bg-muted/30 hover:bg-muted/40 my-6 rounded-r-lg border-l-4 py-4 pr-4 pl-6 italic transition-all duration-200 ease-out hover:translate-x-1">
    <div class="prose prose-sm max-w-none">
      <p>요컨대, 저자들은 **“Attention은 메모리-바운드, FFN은 가중치-바운드”**라는 상반된 병목을 한 레이어 안에서 시간적으로 분리-재조합함으로써, 기존 TP·KVP의 선택적 한계를 동시에 돌파했다는 점을 Helix의 가장 큰 강점으로 내세운다.</p>
    </div>
  </blockquote>

<h1 id="프롬프트-131-알고리즘-단계별-설명">프롬프트 1.3.1 (알고리즘 단계별 설명)</h1>
<div
  class="code-block-container border-border bg-card my-6 overflow-hidden rounded-xl border shadow-sm transition-all duration-200 ease-out hover:-translate-y-0.5 hover:shadow-md">
  
  <div
    class="code-block-header bg-muted/30 border-border flex items-center justify-between border-b px-4 py-3">
    
    <div class="flex items-center gap-2">
      <div class="text-muted-foreground flex-shrink-0">
        
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4" />
</svg>
      </div>
      <span class="text-muted-foreground text-sm font-medium">
        PLAINTEXT
      </span>
    </div>

    
    <div class="flex items-center gap-2">
      <button
          class="collapse-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
          data-code-id="code-5"
          data-default-state="expanded"
          data-collapsed="false"
          data-auto-collapse-lines="30"
          data-auto-collapse-height="400"
          data-collapsed-height="120"
          title="접기"
          aria-label="접기">
          <span class="collapse-icon">
            
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path fill="currentColor" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z"/></svg>
          </span>
          <span class="collapse-text hidden sm:inline"
            >접기</span
          >
        </button>
      <button
        class="copy-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
        data-code-id="code-5"
        title="복사"
        aria-label="복사">
        <span class="copy-icon">
          
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
</svg>
        </span>
        <span class="copy-text hidden sm:inline"
          >복사</span
        >
      </button>
    </div>
  </div>

  
  <div class="code-block-content relative" id="code-5">
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">&#34;핵심 알고리즘, 모델 아키텍처, 또는 주요 방법론을 단계별(step-by-step)로 설명해 줘. 독자는 AI 분야의 대학원생 수준이라고 가정해. 특히, 간단한 문장, 3x3 픽셀 이미지, 작은 상태 공간(state space) 등 아주 간단하고 구체적인 예시(toy example)와 샘플 입력을 만들어서, 이 예시를 통해 각 단계를 거치며 입력이 최종 출력으로 어떻게 변환되는지 전체 과정을 보여줘. 등장하는 모든 핵심 용어와 변수는 그 즉시 정의해 줘.&#34;</span></span></code></pre></div>
    
    <div
      class="collapse-overlay to-card/90 pointer-events-none absolute inset-0 bg-gradient-to-b from-transparent via-transparent opacity-0 transition-opacity duration-300">
      <div
        class="text-muted-foreground bg-card/80 border-border/50 hover:bg-primary/10 hover:text-primary hover:border-primary/30 absolute bottom-4 left-1/2 -translate-x-1/2 cursor-pointer rounded-full border px-3 py-1.5 text-xs backdrop-blur-sm transition-all duration-200">
        클릭하여 더 보기
      </div>
    </div>
  </div>
</div>


<script>
(function() {
  const codeId = 'code-5';
  const copyBtn = document.querySelector('.copy-code-btn[data-code-id="' + codeId + '"]');
  const collapseBtn = document.querySelector('.collapse-code-btn[data-code-id="' + codeId + '"]');
  const codeContainer = document.getElementById(codeId);

  if (!codeContainer) return;

  
  if (copyBtn) {
    const copyIcon = copyBtn.querySelector('.copy-icon');
    const copyText = copyBtn.querySelector('.copy-text');

    copyBtn.addEventListener('click', async function() {
      try {
        
        let codeText = '';

        
        const codeTableCell = codeContainer.querySelector('.lntd:last-child code');
        if (codeTableCell) {
          codeText = codeTableCell.textContent || codeTableCell.innerText;
        } else {
          
          const codeElement = codeContainer.querySelector('code');
          if (codeElement) {
            
            const hasInlineLineNumbers = codeElement.querySelector('.ln');
            if (hasInlineLineNumbers) {
              
              const codeLines = codeElement.querySelectorAll('.cl');
              if (codeLines.length > 0) {
                codeText = Array.from(codeLines)
                  .map(line => {
                    const text = line.textContent || line.innerText;
                    
                    return text.replace(/\n+$/, '');
                  })
                  .join('\n')
                  .replace(/\n+$/, ''); 
              } else {
                
                const allText = codeElement.textContent || codeElement.innerText;
                codeText = allText.replace(/^\d+/gm, '').replace(/^\s+/gm, '');
              }
            } else {
              
              codeText = codeElement.textContent || codeElement.innerText;
            }
          } else {
            
            codeText = codeContainer.textContent || codeContainer.innerText;
          }
        }

        
        codeText = codeText.trim();

        
        await navigator.clipboard.writeText(codeText);

        
        copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M5 13l4 4L19 7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (copyText) {
          copyText.textContent = '복사됨';
        }
        copyBtn.classList.add('text-green-600');

        
        setTimeout(() => {
          copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z\u0022 \/\u003e\n\u003c\/svg\u003e`;
          if (copyText) {
            copyText.textContent = '복사';
          }
          copyBtn.classList.remove('text-green-600');
        }, 2000);

      } catch (err) {
        console.error('复制失败:', err);

        
        const range = document.createRange();
        const codeElement = codeContainer.querySelector('code') || codeContainer;
        range.selectNodeContents(codeElement);
        const selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);

        
        if (copyText) {
          copyText.textContent = '선택됨';
        }

        setTimeout(() => {
          if (copyText) {
            copyText.textContent = '복사';
          }
          selection.removeAllRanges();
        }, 2000);
      }
    });
  }

  
  if (collapseBtn) {
    const collapseIcon = collapseBtn.querySelector('.collapse-icon');
    const collapseText = collapseBtn.querySelector('.collapse-text');
    const collapseOverlay = codeContainer.querySelector('.collapse-overlay');

    
    let codeElement = codeContainer.querySelector('pre.chroma');
    if (!codeElement) {
      codeElement = codeContainer.querySelector('pre');
    }

    const defaultState = collapseBtn.dataset.defaultState || 'expanded';
    const isCollapsedAttr = collapseBtn.dataset.collapsed === 'true';
    const autoCollapseLines = parseInt(collapseBtn.dataset.autoCollapseLines) || 30;
    const autoCollapseHeight = parseInt(collapseBtn.dataset.autoCollapseHeight) || 400;
    const collapsedHeight = parseInt(collapseBtn.dataset.collapsedHeight) || 120;

    let isCollapsed = false;

    
    function initCollapse() {
      
      const shouldCollapse = isCollapsedAttr ||
                           defaultState === 'collapsed' ||
                           shouldAutoCollapse();

      if (shouldCollapse) {
        setCollapsed(true, false); 
      }
    }

    function shouldAutoCollapse() {
      
      if (codeElement) {
        const lines = codeElement.querySelectorAll('.line, .cl');
        const height = codeElement.offsetHeight;
        return lines.length > autoCollapseLines || height > autoCollapseHeight;
      }

      
      const containerHeight = codeContainer.offsetHeight;
      if (containerHeight > autoCollapseHeight) {
        return true;
      }

      
      const textContent = codeContainer.textContent || codeContainer.innerText || '';
      const estimatedLines = textContent.split('\n').length;
      return estimatedLines > autoCollapseLines;
    }

    function setCollapsed(collapsed, animate = true) {
      if (!collapseOverlay) return;

      isCollapsed = collapsed;

      if (collapsed) {
        
        codeContainer.style.maxHeight = collapsedHeight + 'px';
        codeContainer.style.overflow = 'hidden';
        collapseOverlay.style.opacity = '1';
        collapseOverlay.style.pointerEvents = 'auto';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M19 9l-7 7-7-7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '펼치기';
        }
        collapseBtn.title = '펼치기';

      } else {
        
        codeContainer.style.maxHeight = '';
        codeContainer.style.overflow = '';
        collapseOverlay.style.opacity = '0';
        collapseOverlay.style.pointerEvents = 'none';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath fill=\u0022currentColor\u0022 d=\u0022M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z\u0022\/\u003e\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '접기';
        }
        collapseBtn.title = '접기';
      }

      
      if (animate) {
        codeContainer.style.transition = 'max-height 0.3s ease-out';
        setTimeout(() => {
          codeContainer.style.transition = '';
        }, 300);
      }
    }

    function toggleCollapse() {
      setCollapsed(!isCollapsed, true);
    }

    
    collapseBtn.addEventListener('click', toggleCollapse);

    
    if (collapseOverlay) {
      collapseOverlay.addEventListener('click', () => {
        if (isCollapsed) {
          setCollapsed(false, true);
        }
      });
    }

    
    initCollapse();
  }
})();
</script>
<p>**한 줄 요약 | Helix Parallelism은 <em>Attention</em> 단계에선 KV Parallelism × Tensor Parallelism(≤ K)으로 KV 중복 0 %·DRAM 읽기 최소화, 이어지는 <em>FFN</em> 단계에선 동일 GPU 풀을 즉시 TP (또는 TP × EP)로 재구성해 FFN 가중치 로드 병목을 해소하고, HOP-B로 통신을 계산과 겹쳐 TTL을 최대 <strong>1.5× ↓</strong>, 동시 배치 규모를 <strong>32× ↑</strong> 시킨다.</p>
<hr>
<h2 id="1-용어변수-빠른-정의">1. 용어·변수 빠른 정의</h2>
<table>
  <thead>
      <tr>
          <th>기호</th>
          <th>의미</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>B</strong>: batch 크기 (동시 디코딩 시퀀스 수)</td>
          <td></td>
      </tr>
      <tr>
          <td><strong>S</strong>: 각 시퀀스의 컨텍스트 길이</td>
          <td></td>
      </tr>
      <tr>
          <td><strong>Q/K</strong>: query / KV 헤드 수 (예: Q = 4, K = 2)</td>
          <td></td>
      </tr>
      <tr>
          <td><strong>H</strong>: hidden 차원</td>
          <td></td>
      </tr>
      <tr>
          <td><strong>G</strong>: 사용 GPU 수 (= TP × KVP)</td>
          <td></td>
      </tr>
      <tr>
          <td><strong>TP</strong>: Tensor Parallelism ─ 헤드·가중치 축 분할</td>
          <td></td>
      </tr>
      <tr>
          <td><strong>KVP</strong>: KV Parallelism ─ <strong>S</strong>(시퀀스) 축 분할</td>
          <td></td>
      </tr>
      <tr>
          <td><strong>EP</strong>: Expert Parallelism (MoE 전용)</td>
          <td></td>
      </tr>
      <tr>
          <td><strong>TTL</strong>: Token-to-Token Latency</td>
          <td></td>
      </tr>
  </tbody>
</table>
<hr>
<h2 id="2-helix-알고리즘-단계별-워크플로">2. Helix 알고리즘, 단계별 워크플로</h2>
<table>
  <thead>
      <tr>
          <th>단계</th>
          <th>GPU 레이아웃</th>
          <th>핵심 연산 &amp; 통신 흐름</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>① Attention</strong><br> (TP≤K, KVP &gt; 1)</td>
          <td><br><strong>TP</strong> splits heads, <strong>KVP</strong> splits sequence ⇒ <strong>G = TP × KVP</strong></td>
          <td>1. 각 GPU가 <em>전체</em> QKV 프로젝션 계산→ 자기 KV 슬라이스( S/KVP ) 보유  <br>2. 슬라이스 별 FlashAttention 실행→ 부분 출력 &amp; log-sum-exp (LSE) 산출 <br>3. <strong>All-to-All(1)</strong>: query-head 축으로 부분 출력 &amp; LSE 교환 <br>4. 재스케일·합산해 정규화된 최종 Attention 결과 오차 0 % 재구성</td>
      </tr>
      <tr>
          <td><strong>② HOP-B (통신 은닉)</strong></td>
          <td>동일</td>
          <td>Attention 토큰 i의 All-to-All 통신을 토큰 i+1 연산과 <strong>파이프라인</strong>으로 겹침 → 노출 통신 시간 **0–12 %**까지 축소</td>
      </tr>
      <tr>
          <td><strong>③ FFN</strong><br>(Dense: TPF = G, MoE: TPF × EP = G)</td>
          <td>GPU 풀 <strong>재배치</strong>: G개 → TPF(가중치 축) × EP(전문가)</td>
          <td>1. <strong>All-to-All(2)</strong>: [B,H] 은닉 상태를 TP 레이아웃으로 재분배 <br>2. 각 GPU가 FFN 1·2층 GEMM 수행 (MoE 일 경우 라우팅 포함) <br>3. **All-Reduce(3)**로 부분 결과 합산 → [B,H] 출력 <br>4. 다음 레이어로 전달, GPU 레이아웃은 다시 <strong>①</strong>로 회귀</td>
      </tr>
  </tbody>
</table>
<p><strong>⇒ 효과</strong> | KV 읽기량 ∝ S/KVP, FFN 가중치 읽기량 ∝ (모델 매트릭스)/G → 두 병목 동시 완화.</p>
<hr>
<h2 id="3-장난감-예시로-전체-흐름-따라가기">3. 장난감 예시로 전체 흐름 따라가기</h2>

  <blockquote
    class="border-primary bg-muted/30 hover:bg-muted/40 my-6 rounded-r-lg border-l-4 py-4 pr-4 pl-6 italic transition-all duration-200 ease-out hover:translate-x-1">
    <div class="prose prose-sm max-w-none">
      <p><strong>환경</strong> B = 1, S = 4, Q = 4, K = 2, H = 6, G = 2 (TP = 2, KVP = 1) ← 두 GPU만 사용해 개념 강조</p>
    </div>
  </blockquote>

<h3 id="3-1-입력-준비">3-1. 입력 준비</h3>
<p><em>새 토큰</em>의 query 벡터 <strong>q = [1 0 1 0 0 1]</strong>
KV 캐시(4 × 6) 는 GPU0(토큰 0-1), GPU1(토큰 2-3)에 절반씩.</p>
<h3 id="3-2-attention-단계-gpu별-계산">3-2. <strong>Attention 단계</strong> (GPU별 계산)</h3>
<table>
  <thead>
      <tr>
          <th>GPU</th>
          <th>KV 슬라이스(2 토큰)</th>
          <th>① dot(q,K) → α</th>
          <th>② softmax α</th>
          <th>③ α·V → o_partial</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>0</td>
          <td>K₀₋₁</td>
          <td>[3, 2]</td>
          <td>[0.73, 0.27]</td>
          <td>[0.73·v₀+0.27·v₁]</td>
      </tr>
      <tr>
          <td>1</td>
          <td>K₂₋₃</td>
          <td>[1, 4]</td>
          <td>[0.12, 0.88]</td>
          <td>[0.12·v₂+0.88·v₃]</td>
      </tr>
  </tbody>
</table>
<p><em>All-to-All</em> 후 두 GPU는 서로의 o_partial, LSE를 받아 <strong>o_final</strong> 재구성.</p>
<h3 id="3-3-hop-b">3-3. <strong>HOP-B</strong></h3>
<p>토큰 t₀의 All-to-All(≈0.2 ms)과 t₁의 FlashAttention(≈0.6 ms) 겹침 ⇒ 노출 통신 0 ms.</p>
<h3 id="3-4-ffn-단계">3-4. <strong>FFN 단계</strong></h3>
<p>All-to-All(2) 로 hidden 6-d 벡터를 절반씩 분할 →
GPU0: 첫 3 차원, GPU1: 나머지 3 차원.
각 GPU가 <em>w₁·h_split + b₁ → GeLU → w₂·…</em> 계산 후 All-Reduce(3) 로 합산.
결과 벡터 <strong>h′</strong> 가 레이어 출력.</p>

  <blockquote
    class="border-primary bg-muted/30 hover:bg-muted/40 my-6 rounded-r-lg border-l-4 py-4 pr-4 pl-6 italic transition-all duration-200 ease-out hover:translate-x-1">
    <div class="prose prose-sm max-w-none">
      <p><strong>이 과정을 매 토큰마다 반복</strong>하며, Helix는 토큰 간 전환(2–3 ms 수준)에서도 KV 중복 0 %와 FFN 가중치 분산을 모두 유지한다.</p>
    </div>
  </blockquote>

<hr>
<h2 id="4-핵심-수치로-보는-helix-개선폭">4. 핵심 수치로 보는 Helix 개선폭</h2>
<table>
  <thead>
      <tr>
          <th>모델</th>
          <th>G</th>
          <th>TTL 개선</th>
          <th>동시 배치↑</th>
          <th>근거</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>DeepSeek-R1 (MoE 671 B)</td>
          <td>72</td>
          <td><strong>1.5× ↓</strong></td>
          <td><strong>32×</strong></td>
          <td></td>
      </tr>
      <tr>
          <td>Llama-405 B (Dense)</td>
          <td>72</td>
          <td><strong>1.13× ↓</strong></td>
          <td><strong>4× TPS/GPU</strong></td>
          <td></td>
      </tr>
  </tbody>
</table>
<hr>
<h3 id="정리--포인트">정리 &amp; 포인트</h3>
<ol>
<li><strong>2-D 샤딩</strong>: TP(헤드) × KVP(시퀀스)로 KV 중복 플래토 해소.</li>
<li><strong>동일 GPU 재활용</strong>: Attention → FFN으로 즉시 레이아웃 전환, 가중치 읽기 분산.</li>
<li><strong>HOP-B</strong>: 통신을 계산과 겹쳐 TTL 손실 ≤ 12 %.</li>
<li><strong>결과</strong>: 실시간 초장기 디코딩에서 <em>지연·동시성</em> Pareto 프론티어를 바깥으로 확장.</li>
</ol>
<h1 id="프롬프트-132-비밀-병기-식별">프롬프트 1.3.2 (&lsquo;비밀 병기&rsquo; 식별)</h1>
<div
  class="code-block-container border-border bg-card my-6 overflow-hidden rounded-xl border shadow-sm transition-all duration-200 ease-out hover:-translate-y-0.5 hover:shadow-md">
  
  <div
    class="code-block-header bg-muted/30 border-border flex items-center justify-between border-b px-4 py-3">
    
    <div class="flex items-center gap-2">
      <div class="text-muted-foreground flex-shrink-0">
        
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4" />
</svg>
      </div>
      <span class="text-muted-foreground text-sm font-medium">
        PLAINTEXT
      </span>
    </div>

    
    <div class="flex items-center gap-2">
      <button
          class="collapse-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
          data-code-id="code-6"
          data-default-state="expanded"
          data-collapsed="false"
          data-auto-collapse-lines="30"
          data-auto-collapse-height="400"
          data-collapsed-height="120"
          title="접기"
          aria-label="접기">
          <span class="collapse-icon">
            
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path fill="currentColor" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z"/></svg>
          </span>
          <span class="collapse-text hidden sm:inline"
            >접기</span
          >
        </button>
      <button
        class="copy-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
        data-code-id="code-6"
        title="복사"
        aria-label="복사">
        <span class="copy-icon">
          
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
</svg>
        </span>
        <span class="copy-text hidden sm:inline"
          >복사</span
        >
      </button>
    </div>
  </div>

  
  <div class="code-block-content relative" id="code-6">
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">&#34;이 논문의 핵심 기여를 가능하게 하는 가장 결정적인 단일 수학 공식, 알고리즘 단계, 또는 아키텍처 구성요소를 식별해 줘. 그것의 기능과, 그것이 이 방법론의 성공에 왜 필수적인지 설명해 줘.&#34;</span></span></code></pre></div>
    
    <div
      class="collapse-overlay to-card/90 pointer-events-none absolute inset-0 bg-gradient-to-b from-transparent via-transparent opacity-0 transition-opacity duration-300">
      <div
        class="text-muted-foreground bg-card/80 border-border/50 hover:bg-primary/10 hover:text-primary hover:border-primary/30 absolute bottom-4 left-1/2 -translate-x-1/2 cursor-pointer rounded-full border px-3 py-1.5 text-xs backdrop-blur-sm transition-all duration-200">
        클릭하여 더 보기
      </div>
    </div>
  </div>
</div>


<script>
(function() {
  const codeId = 'code-6';
  const copyBtn = document.querySelector('.copy-code-btn[data-code-id="' + codeId + '"]');
  const collapseBtn = document.querySelector('.collapse-code-btn[data-code-id="' + codeId + '"]');
  const codeContainer = document.getElementById(codeId);

  if (!codeContainer) return;

  
  if (copyBtn) {
    const copyIcon = copyBtn.querySelector('.copy-icon');
    const copyText = copyBtn.querySelector('.copy-text');

    copyBtn.addEventListener('click', async function() {
      try {
        
        let codeText = '';

        
        const codeTableCell = codeContainer.querySelector('.lntd:last-child code');
        if (codeTableCell) {
          codeText = codeTableCell.textContent || codeTableCell.innerText;
        } else {
          
          const codeElement = codeContainer.querySelector('code');
          if (codeElement) {
            
            const hasInlineLineNumbers = codeElement.querySelector('.ln');
            if (hasInlineLineNumbers) {
              
              const codeLines = codeElement.querySelectorAll('.cl');
              if (codeLines.length > 0) {
                codeText = Array.from(codeLines)
                  .map(line => {
                    const text = line.textContent || line.innerText;
                    
                    return text.replace(/\n+$/, '');
                  })
                  .join('\n')
                  .replace(/\n+$/, ''); 
              } else {
                
                const allText = codeElement.textContent || codeElement.innerText;
                codeText = allText.replace(/^\d+/gm, '').replace(/^\s+/gm, '');
              }
            } else {
              
              codeText = codeElement.textContent || codeElement.innerText;
            }
          } else {
            
            codeText = codeContainer.textContent || codeContainer.innerText;
          }
        }

        
        codeText = codeText.trim();

        
        await navigator.clipboard.writeText(codeText);

        
        copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M5 13l4 4L19 7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (copyText) {
          copyText.textContent = '복사됨';
        }
        copyBtn.classList.add('text-green-600');

        
        setTimeout(() => {
          copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z\u0022 \/\u003e\n\u003c\/svg\u003e`;
          if (copyText) {
            copyText.textContent = '복사';
          }
          copyBtn.classList.remove('text-green-600');
        }, 2000);

      } catch (err) {
        console.error('复制失败:', err);

        
        const range = document.createRange();
        const codeElement = codeContainer.querySelector('code') || codeContainer;
        range.selectNodeContents(codeElement);
        const selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);

        
        if (copyText) {
          copyText.textContent = '선택됨';
        }

        setTimeout(() => {
          if (copyText) {
            copyText.textContent = '복사';
          }
          selection.removeAllRanges();
        }, 2000);
      }
    });
  }

  
  if (collapseBtn) {
    const collapseIcon = collapseBtn.querySelector('.collapse-icon');
    const collapseText = collapseBtn.querySelector('.collapse-text');
    const collapseOverlay = codeContainer.querySelector('.collapse-overlay');

    
    let codeElement = codeContainer.querySelector('pre.chroma');
    if (!codeElement) {
      codeElement = codeContainer.querySelector('pre');
    }

    const defaultState = collapseBtn.dataset.defaultState || 'expanded';
    const isCollapsedAttr = collapseBtn.dataset.collapsed === 'true';
    const autoCollapseLines = parseInt(collapseBtn.dataset.autoCollapseLines) || 30;
    const autoCollapseHeight = parseInt(collapseBtn.dataset.autoCollapseHeight) || 400;
    const collapsedHeight = parseInt(collapseBtn.dataset.collapsedHeight) || 120;

    let isCollapsed = false;

    
    function initCollapse() {
      
      const shouldCollapse = isCollapsedAttr ||
                           defaultState === 'collapsed' ||
                           shouldAutoCollapse();

      if (shouldCollapse) {
        setCollapsed(true, false); 
      }
    }

    function shouldAutoCollapse() {
      
      if (codeElement) {
        const lines = codeElement.querySelectorAll('.line, .cl');
        const height = codeElement.offsetHeight;
        return lines.length > autoCollapseLines || height > autoCollapseHeight;
      }

      
      const containerHeight = codeContainer.offsetHeight;
      if (containerHeight > autoCollapseHeight) {
        return true;
      }

      
      const textContent = codeContainer.textContent || codeContainer.innerText || '';
      const estimatedLines = textContent.split('\n').length;
      return estimatedLines > autoCollapseLines;
    }

    function setCollapsed(collapsed, animate = true) {
      if (!collapseOverlay) return;

      isCollapsed = collapsed;

      if (collapsed) {
        
        codeContainer.style.maxHeight = collapsedHeight + 'px';
        codeContainer.style.overflow = 'hidden';
        collapseOverlay.style.opacity = '1';
        collapseOverlay.style.pointerEvents = 'auto';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M19 9l-7 7-7-7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '펼치기';
        }
        collapseBtn.title = '펼치기';

      } else {
        
        codeContainer.style.maxHeight = '';
        codeContainer.style.overflow = '';
        collapseOverlay.style.opacity = '0';
        collapseOverlay.style.pointerEvents = 'none';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath fill=\u0022currentColor\u0022 d=\u0022M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z\u0022\/\u003e\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '접기';
        }
        collapseBtn.title = '접기';
      }

      
      if (animate) {
        codeContainer.style.transition = 'max-height 0.3s ease-out';
        setTimeout(() => {
          codeContainer.style.transition = '';
        }, 300);
      }
    }

    function toggleCollapse() {
      setCollapsed(!isCollapsed, true);
    }

    
    collapseBtn.addEventListener('click', toggleCollapse);

    
    if (collapseOverlay) {
      collapseOverlay.addEventListener('click', () => {
        if (isCollapsed) {
          setCollapsed(false, true);
        }
      });
    }

    
    initCollapse();
  }
})();
</script>
<p>**결론 먼저 | Helix의 ‘비밀 병기’는 **각 KV 파티션이 계산한 <em>부분 어텐션 출력 Oᵢ</em>와 <em>log-sum-exp LSEᵢ</em>를 <strong>한 번의 All-to-All 후</strong></p>
<p>$$
\boxed{;O=\frac{\sum_{i=1}^{N} O_i,e^{\text{LSE}<em>i}}{\sum</em>{i=1}^{N} e^{\text{LSE}_i}};}
$$</p>
<p>로 재스케일 · 합산해 <strong>정확한 소프트맥스 결과를 복원</strong>하는 ‘<strong>단일 All-to-All + LSE 재조합</strong>’ 단계다. 이 한 수식·한 통신 라운드가 Helix Parallelism의 2-D 샤딩을 성사시킨다.</p>
<hr>
<h3 id="1-무엇을-하는가--기능">1. 무엇을 하는가? — 기능</h3>
<table>
  <thead>
      <tr>
          <th>단계</th>
          <th>작동 원리</th>
          <th>결과</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>① 각 KVP GPU</strong></td>
          <td>자기 KV-슬라이스*(S / KVP)*에 대해 FlashAttention ⇒ <strong>Oᵢ</strong>, <strong>LSEᵢ</strong> 산출</td>
          <td>계산은 <strong>메모리 로컬</strong>, KV 중복 0 %</td>
      </tr>
      <tr>
          <td><strong>② All-to-All</strong></td>
          <td>Oᵢ, LSEᵢ를 <strong>query-head 축</strong>으로 한 번 교환</td>
          <td>통신량 ∝ B·H, <strong>S와 무관</strong></td>
      </tr>
      <tr>
          <td><strong>③ LSE 재스케일</strong></td>
          <td>위의 식으로 소프트맥스 정규화 복원 (수학적 정확성 증명)</td>
          <td>분산 계산이 <strong>단일-GPU 결과와 비트까지 동일</strong></td>
      </tr>
      <tr>
          <td><strong>④ 즉시 TP 재구성</strong></td>
          <td>동일 GPU 풀을 FFN용 TP(×EP) 레이아웃으로 전환</td>
          <td>KV 중복 없이 <strong>FFN 가중치 로드까지 분산</strong></td>
      </tr>
  </tbody>
</table>
<hr>
<h3 id="2-왜-핵심적인가--필수성">2. 왜 핵심적인가? — 필수성</h3>
<ol>
<li>
<p><strong>KV 중복을 원천 차단</strong>
<em>TP 폭을 K보다 크게 키워도</em> KV 캐시를 복제하지 않아 DRAM 대역·용량 병목이 사라진다.</p>
</li>
<li>
<p><strong>통신·계산 균형</strong>
All-to-All 통신은 S와 무관해 초장기(≥10⁶ 토큰)에서도 상수 오버헤드이며, HOP-B로 노출 지연을 0–12 %까지 숨길 수 있다.</p>
</li>
<li>
<p><strong>GPU 재활용의 교두보</strong>
LSE 재조합이 끝나면 데이터가 이미 TP 배치로 정렬돼 있어, 별도 이동 없이 바로 FFN 병렬화로 넘어가 <strong>TTL 최대 1.5× 단축·동시 배치 32× 확장</strong>이라는 Helix 전체 성능 이득을 촉발한다.</p>
</li>
<li>
<p><strong>정확도 보존</strong>
소프트맥스 분모를 수학적으로 완전하게 재구성(증명 식 ⑥–⑫)하므로 근사화 없이 모델 품질을 유지한다.</p>
</li>
</ol>
<hr>

  <blockquote
    class="border-primary bg-muted/30 hover:bg-muted/40 my-6 rounded-r-lg border-l-4 py-4 pr-4 pl-6 italic transition-all duration-200 ease-out hover:translate-x-1">
    <div class="prose prose-sm max-w-none">
      <p><strong>요약</strong>: Helix가 “KV 중복 없는 Attention ↔ 가중치 분산 FFN”이라는 두 마리 토끼를 잡을 수 있었던 결정적 열쇠는, <strong>단일 All-to-All 후 LSE 기반으로 어텐션을 정확히 다시 조립하는 이 한 수식/단계</strong>다. 이 ‘재조합 커널’ 없이는 Helix의 2-D 샤딩과 GPU 풀 재활용이라는 핵심 전략 자체가 성립하지 않는다.</p>
    </div>
  </blockquote>

<h1 id="프롬프트-141-핵심-결과-분석">프롬프트 1.4.1 (핵심 결과 분석)</h1>
<div
  class="code-block-container border-border bg-card my-6 overflow-hidden rounded-xl border shadow-sm transition-all duration-200 ease-out hover:-translate-y-0.5 hover:shadow-md">
  
  <div
    class="code-block-header bg-muted/30 border-border flex items-center justify-between border-b px-4 py-3">
    
    <div class="flex items-center gap-2">
      <div class="text-muted-foreground flex-shrink-0">
        
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4" />
</svg>
      </div>
      <span class="text-muted-foreground text-sm font-medium">
        PLAINTEXT
      </span>
    </div>

    
    <div class="flex items-center gap-2">
      <button
          class="collapse-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
          data-code-id="code-7"
          data-default-state="expanded"
          data-collapsed="false"
          data-auto-collapse-lines="30"
          data-auto-collapse-height="400"
          data-collapsed-height="120"
          title="접기"
          aria-label="접기">
          <span class="collapse-icon">
            
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path fill="currentColor" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z"/></svg>
          </span>
          <span class="collapse-text hidden sm:inline"
            >접기</span
          >
        </button>
      <button
        class="copy-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
        data-code-id="code-7"
        title="복사"
        aria-label="복사">
        <span class="copy-icon">
          
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
</svg>
        </span>
        <span class="copy-text hidden sm:inline"
          >복사</span
        >
      </button>
    </div>
  </div>

  
  <div class="code-block-content relative" id="code-7">
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">&#34;&#39;Experiments&#39; 또는 &#39;Results&#39; 섹션의 표와 그림을 포함한 주요 결과를 분석해 줘. 사용된 핵심 성능 지표(performance metrics)는 무엇인가? 어떤 벤치마크 데이터셋에서 결과가 보고되었는가? 저자들이 자신들의 방법론의 성공 증거로 가장 강조하는 주요 결과를 요약해 줘.&#34;</span></span></code></pre></div>
    
    <div
      class="collapse-overlay to-card/90 pointer-events-none absolute inset-0 bg-gradient-to-b from-transparent via-transparent opacity-0 transition-opacity duration-300">
      <div
        class="text-muted-foreground bg-card/80 border-border/50 hover:bg-primary/10 hover:text-primary hover:border-primary/30 absolute bottom-4 left-1/2 -translate-x-1/2 cursor-pointer rounded-full border px-3 py-1.5 text-xs backdrop-blur-sm transition-all duration-200">
        클릭하여 더 보기
      </div>
    </div>
  </div>
</div>


<script>
(function() {
  const codeId = 'code-7';
  const copyBtn = document.querySelector('.copy-code-btn[data-code-id="' + codeId + '"]');
  const collapseBtn = document.querySelector('.collapse-code-btn[data-code-id="' + codeId + '"]');
  const codeContainer = document.getElementById(codeId);

  if (!codeContainer) return;

  
  if (copyBtn) {
    const copyIcon = copyBtn.querySelector('.copy-icon');
    const copyText = copyBtn.querySelector('.copy-text');

    copyBtn.addEventListener('click', async function() {
      try {
        
        let codeText = '';

        
        const codeTableCell = codeContainer.querySelector('.lntd:last-child code');
        if (codeTableCell) {
          codeText = codeTableCell.textContent || codeTableCell.innerText;
        } else {
          
          const codeElement = codeContainer.querySelector('code');
          if (codeElement) {
            
            const hasInlineLineNumbers = codeElement.querySelector('.ln');
            if (hasInlineLineNumbers) {
              
              const codeLines = codeElement.querySelectorAll('.cl');
              if (codeLines.length > 0) {
                codeText = Array.from(codeLines)
                  .map(line => {
                    const text = line.textContent || line.innerText;
                    
                    return text.replace(/\n+$/, '');
                  })
                  .join('\n')
                  .replace(/\n+$/, ''); 
              } else {
                
                const allText = codeElement.textContent || codeElement.innerText;
                codeText = allText.replace(/^\d+/gm, '').replace(/^\s+/gm, '');
              }
            } else {
              
              codeText = codeElement.textContent || codeElement.innerText;
            }
          } else {
            
            codeText = codeContainer.textContent || codeContainer.innerText;
          }
        }

        
        codeText = codeText.trim();

        
        await navigator.clipboard.writeText(codeText);

        
        copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M5 13l4 4L19 7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (copyText) {
          copyText.textContent = '복사됨';
        }
        copyBtn.classList.add('text-green-600');

        
        setTimeout(() => {
          copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z\u0022 \/\u003e\n\u003c\/svg\u003e`;
          if (copyText) {
            copyText.textContent = '복사';
          }
          copyBtn.classList.remove('text-green-600');
        }, 2000);

      } catch (err) {
        console.error('复制失败:', err);

        
        const range = document.createRange();
        const codeElement = codeContainer.querySelector('code') || codeContainer;
        range.selectNodeContents(codeElement);
        const selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);

        
        if (copyText) {
          copyText.textContent = '선택됨';
        }

        setTimeout(() => {
          if (copyText) {
            copyText.textContent = '복사';
          }
          selection.removeAllRanges();
        }, 2000);
      }
    });
  }

  
  if (collapseBtn) {
    const collapseIcon = collapseBtn.querySelector('.collapse-icon');
    const collapseText = collapseBtn.querySelector('.collapse-text');
    const collapseOverlay = codeContainer.querySelector('.collapse-overlay');

    
    let codeElement = codeContainer.querySelector('pre.chroma');
    if (!codeElement) {
      codeElement = codeContainer.querySelector('pre');
    }

    const defaultState = collapseBtn.dataset.defaultState || 'expanded';
    const isCollapsedAttr = collapseBtn.dataset.collapsed === 'true';
    const autoCollapseLines = parseInt(collapseBtn.dataset.autoCollapseLines) || 30;
    const autoCollapseHeight = parseInt(collapseBtn.dataset.autoCollapseHeight) || 400;
    const collapsedHeight = parseInt(collapseBtn.dataset.collapsedHeight) || 120;

    let isCollapsed = false;

    
    function initCollapse() {
      
      const shouldCollapse = isCollapsedAttr ||
                           defaultState === 'collapsed' ||
                           shouldAutoCollapse();

      if (shouldCollapse) {
        setCollapsed(true, false); 
      }
    }

    function shouldAutoCollapse() {
      
      if (codeElement) {
        const lines = codeElement.querySelectorAll('.line, .cl');
        const height = codeElement.offsetHeight;
        return lines.length > autoCollapseLines || height > autoCollapseHeight;
      }

      
      const containerHeight = codeContainer.offsetHeight;
      if (containerHeight > autoCollapseHeight) {
        return true;
      }

      
      const textContent = codeContainer.textContent || codeContainer.innerText || '';
      const estimatedLines = textContent.split('\n').length;
      return estimatedLines > autoCollapseLines;
    }

    function setCollapsed(collapsed, animate = true) {
      if (!collapseOverlay) return;

      isCollapsed = collapsed;

      if (collapsed) {
        
        codeContainer.style.maxHeight = collapsedHeight + 'px';
        codeContainer.style.overflow = 'hidden';
        collapseOverlay.style.opacity = '1';
        collapseOverlay.style.pointerEvents = 'auto';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M19 9l-7 7-7-7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '펼치기';
        }
        collapseBtn.title = '펼치기';

      } else {
        
        codeContainer.style.maxHeight = '';
        codeContainer.style.overflow = '';
        collapseOverlay.style.opacity = '0';
        collapseOverlay.style.pointerEvents = 'none';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath fill=\u0022currentColor\u0022 d=\u0022M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z\u0022\/\u003e\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '접기';
        }
        collapseBtn.title = '접기';
      }

      
      if (animate) {
        codeContainer.style.transition = 'max-height 0.3s ease-out';
        setTimeout(() => {
          codeContainer.style.transition = '';
        }, 300);
      }
    }

    function toggleCollapse() {
      setCollapsed(!isCollapsed, true);
    }

    
    collapseBtn.addEventListener('click', toggleCollapse);

    
    if (collapseOverlay) {
      collapseOverlay.addEventListener('click', () => {
        if (isCollapsed) {
          setCollapsed(false, true);
        }
      });
    }

    
    initCollapse();
  }
})();
</script>
<p><strong>TL;DR</strong> | <em>Helix Parallelism</em> pushes the throughput-vs-latency Pareto frontier outward: on a simulated NVIDIA GB200 node it cuts token-to-token latency (TTL) by <strong>1.5 ×</strong> for DeepSeek-R1 and <strong>1.13 ×</strong> for Llama-405B while letting the system serve <strong>32 ×</strong> and <strong>4 ×</strong> more concurrent users, respectively, under the same latency budget.</p>
<hr>
<h2 id="1-실험에서-사용된-핵심-성능-지표">1. 실험에서 사용된 핵심 성능 지표</h2>
<table>
  <thead>
      <tr>
          <th>지표</th>
          <th>정의</th>
          <th>목적</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>TTL (Token-to-Token Latency)</strong></td>
          <td>새 토큰까지 걸리는 시간; 논문에서는 <strong>interactivity = 1 / TTL</strong>(tokens ⋅ s⁻¹ ⋅ user⁻¹)로 표현</td>
          <td>실시간 응답성</td>
      </tr>
      <tr>
          <td><strong>Throughput/GPU</strong></td>
          <td>GPU 하나가 생성하는 토큰 수 (tokens ⋅ s⁻¹ ⋅ GPU⁻¹)</td>
          <td>자원 효율성</td>
      </tr>
      <tr>
          <td><strong>Batch Scalability</strong></td>
          <td>고정 TTL 조건에서 유지 가능한 동시 사용자 수</td>
          <td>대규모 서비스 용량</td>
      </tr>
  </tbody>
</table>
<hr>
<h2 id="2-벤치마크-모델환경">2. 벤치마크 모델·환경</h2>
<ul>
<li>
<p><strong>모델</strong></p>
<ul>
<li><strong>DeepSeek-R1</strong> 671 B MoE, Multi-Head Latent Attention (MLA)</li>
<li><strong>Llama-405B</strong> Dense 405 B, GQA (Q = 128, K = 8)</li>
</ul>
</li>
<li>
<p><strong>컨텍스트 길이</strong> 1 M tokens (디코딩 시점 KV-cache 길이)</p>
</li>
<li>
<p><strong>HW</strong> NVIDIA GB200 NVL72, FP4 정밀도 (시뮬레이터)</p>
</li>
<li>
<p><strong>베이스라인 탐색</strong> TP / PP / EP / Medha-style KVP 포함 100 k+ 구성 전수 시뮬레이션 후 Pareto 추출.</p>
</li>
</ul>
<hr>
<h2 id="3-주요-결과-한눈에-보기">3. 주요 결과 한눈에 보기</h2>
<table>
  <thead>
      <tr>
          <th>모델</th>
          <th>측정치</th>
          <th>베이스라인 최고</th>
          <th><strong>Helix</strong></th>
          <th>개선폭</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>DeepSeek-R1</strong></td>
          <td>TTL (↓)</td>
          <td>1.0×</td>
          <td><strong>0.67×</strong></td>
          <td><strong>1.5× ↓</strong></td>
      </tr>
      <tr>
          <td></td>
          <td>Batch cap (↑)</td>
          <td>1 ×</td>
          <td><strong>32 ×</strong></td>
          <td><strong>32×</strong>↑</td>
      </tr>
      <tr>
          <td></td>
          <td>Throughput/GPU</td>
          <td>1 ×</td>
          <td><strong>32 ×</strong></td>
          <td>파레토 동시 향상</td>
      </tr>
      <tr>
          <td><strong>Llama-405B</strong></td>
          <td>TTL (↓)</td>
          <td>1.0×</td>
          <td><strong>0.88×</strong></td>
          <td><strong>1.13× ↓</strong></td>
      </tr>
      <tr>
          <td></td>
          <td>Batch cap / TPS·GPU (↑)</td>
          <td>1 ×</td>
          <td><strong>4 ×</strong></td>
          <td><strong>4×</strong>↑</td>
      </tr>
  </tbody>
</table>

  <blockquote
    class="border-primary bg-muted/30 hover:bg-muted/40 my-6 rounded-r-lg border-l-4 py-4 pr-4 pl-6 italic transition-all duration-200 ease-out hover:translate-x-1">
    <div class="prose prose-sm max-w-none">
      <p><strong>해석</strong> | Helix는 KV 중복 없이 TP를 폭넓게 쓰면서 FFN도 동일 GPU 풀에 재배치해 두 병목을 동시 제거—그 결과 모든 지표에서 베이스라인을 엄밀히 우상향(Pareto 우측·상단)한다.</p>
    </div>
  </blockquote>

<hr>
<h2 id="4-ablation-hop-b-통신-은닉-효과">4. Ablation: HOP-B 통신 은닉 효과</h2>
<table>
  <thead>
      <tr>
          <th>모델</th>
          <th>HOP-B OFF</th>
          <th>HOP-B ON</th>
          <th>손실 회복</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>DeepSeek-R1</td>
          <td>TTL ↓ 1 %</td>
          <td>–</td>
          <td>통신 비중 작음</td>
      </tr>
      <tr>
          <td>Llama-405B</td>
          <td>TTL ↓ <strong>12 %</strong></td>
          <td>–</td>
          <td>통신-계산 오버랩 중요</td>
      </tr>
  </tbody>
</table>
<p><em>HOP-B</em>가 All-to-All 통신을 다음 토큰 계산과 파이프라인화해 노출 지연을 최대 12 % 줄인다.</p>
<hr>
<h2 id="5-저자들이-강조하는-성공-증거">5. 저자들이 강조하는 성공 증거</h2>
<ol>
<li><strong>Pareto Frontier 이동</strong> – 100 k 구성 시뮬레이션에서 Helix 점들이 기존 최고점들을 전부 넘어 새로운 경계선을 형성한다.</li>
<li><strong>메모리 독립적 통신량</strong> – KV 길이 <em>S</em>에 무관한 All-to-All 덕분에 1 M+ 토큰에서도 성능 유지.</li>
<li><strong>이중 병목 해소</strong> – TP &gt; K 시 나타나는 KV 캐시 복제 플래토와 FFN 가중치 로드 병목을 모두 제거, 실험적으로 TTL 최대 50 % 감축.</li>
</ol>
<hr>
<h3 id="정리">정리</h3>
<p>Helix Parallelism은 <strong>TTL·동시성·GPU 효율</strong> 세 마리 토끼를 동시에 잡았음을 실험으로 입증했다. 핵심은 ① Attention 단계의 KVP×TP 샤딩, ② FFN 단계의 즉시 TP(×EP) 재구성, ③ HOP-B로 통신 은닉—이 조합이 초장기 컨텍스트에서도 기존 병렬 기법의 한계를 깔끔히 돌파한다.</p>
<h1 id="프롬프트-142-비판적-비교">프롬프트 1.4.2 (비판적 비교)</h1>
<div
  class="code-block-container border-border bg-card my-6 overflow-hidden rounded-xl border shadow-sm transition-all duration-200 ease-out hover:-translate-y-0.5 hover:shadow-md">
  
  <div
    class="code-block-header bg-muted/30 border-border flex items-center justify-between border-b px-4 py-3">
    
    <div class="flex items-center gap-2">
      <div class="text-muted-foreground flex-shrink-0">
        
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4" />
</svg>
      </div>
      <span class="text-muted-foreground text-sm font-medium">
        PLAINTEXT
      </span>
    </div>

    
    <div class="flex items-center gap-2">
      <button
          class="collapse-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
          data-code-id="code-8"
          data-default-state="expanded"
          data-collapsed="false"
          data-auto-collapse-lines="30"
          data-auto-collapse-height="400"
          data-collapsed-height="120"
          title="접기"
          aria-label="접기">
          <span class="collapse-icon">
            
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path fill="currentColor" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z"/></svg>
          </span>
          <span class="collapse-text hidden sm:inline"
            >접기</span
          >
        </button>
      <button
        class="copy-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
        data-code-id="code-8"
        title="복사"
        aria-label="복사">
        <span class="copy-icon">
          
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
</svg>
        </span>
        <span class="copy-text hidden sm:inline"
          >복사</span
        >
      </button>
    </div>
  </div>

  
  <div class="code-block-content relative" id="code-8">
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">&#34;제안된 방법론은 논문에서 언급된 주요 베이스라인 및 SOTA(State-of-the-Art) 모델들과 비교하여 어떤 성능을 보이는가? 저자들의 우월성 주장을 가장 강력하게 뒷받침하는 특정 결과나 비교 지점을 식별해 줘. 반대로, 제안된 방법론이 경쟁 모델을 능가하지 못했거나 개선 효과가 미미했던 결과는 없는지 찾아봐. 만약 있다면, 저자들은 이러한 경우에 대해 어떤 이유를 제시하는가?&#34;</span></span></code></pre></div>
    
    <div
      class="collapse-overlay to-card/90 pointer-events-none absolute inset-0 bg-gradient-to-b from-transparent via-transparent opacity-0 transition-opacity duration-300">
      <div
        class="text-muted-foreground bg-card/80 border-border/50 hover:bg-primary/10 hover:text-primary hover:border-primary/30 absolute bottom-4 left-1/2 -translate-x-1/2 cursor-pointer rounded-full border px-3 py-1.5 text-xs backdrop-blur-sm transition-all duration-200">
        클릭하여 더 보기
      </div>
    </div>
  </div>
</div>


<script>
(function() {
  const codeId = 'code-8';
  const copyBtn = document.querySelector('.copy-code-btn[data-code-id="' + codeId + '"]');
  const collapseBtn = document.querySelector('.collapse-code-btn[data-code-id="' + codeId + '"]');
  const codeContainer = document.getElementById(codeId);

  if (!codeContainer) return;

  
  if (copyBtn) {
    const copyIcon = copyBtn.querySelector('.copy-icon');
    const copyText = copyBtn.querySelector('.copy-text');

    copyBtn.addEventListener('click', async function() {
      try {
        
        let codeText = '';

        
        const codeTableCell = codeContainer.querySelector('.lntd:last-child code');
        if (codeTableCell) {
          codeText = codeTableCell.textContent || codeTableCell.innerText;
        } else {
          
          const codeElement = codeContainer.querySelector('code');
          if (codeElement) {
            
            const hasInlineLineNumbers = codeElement.querySelector('.ln');
            if (hasInlineLineNumbers) {
              
              const codeLines = codeElement.querySelectorAll('.cl');
              if (codeLines.length > 0) {
                codeText = Array.from(codeLines)
                  .map(line => {
                    const text = line.textContent || line.innerText;
                    
                    return text.replace(/\n+$/, '');
                  })
                  .join('\n')
                  .replace(/\n+$/, ''); 
              } else {
                
                const allText = codeElement.textContent || codeElement.innerText;
                codeText = allText.replace(/^\d+/gm, '').replace(/^\s+/gm, '');
              }
            } else {
              
              codeText = codeElement.textContent || codeElement.innerText;
            }
          } else {
            
            codeText = codeContainer.textContent || codeContainer.innerText;
          }
        }

        
        codeText = codeText.trim();

        
        await navigator.clipboard.writeText(codeText);

        
        copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M5 13l4 4L19 7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (copyText) {
          copyText.textContent = '복사됨';
        }
        copyBtn.classList.add('text-green-600');

        
        setTimeout(() => {
          copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z\u0022 \/\u003e\n\u003c\/svg\u003e`;
          if (copyText) {
            copyText.textContent = '복사';
          }
          copyBtn.classList.remove('text-green-600');
        }, 2000);

      } catch (err) {
        console.error('复制失败:', err);

        
        const range = document.createRange();
        const codeElement = codeContainer.querySelector('code') || codeContainer;
        range.selectNodeContents(codeElement);
        const selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);

        
        if (copyText) {
          copyText.textContent = '선택됨';
        }

        setTimeout(() => {
          if (copyText) {
            copyText.textContent = '복사';
          }
          selection.removeAllRanges();
        }, 2000);
      }
    });
  }

  
  if (collapseBtn) {
    const collapseIcon = collapseBtn.querySelector('.collapse-icon');
    const collapseText = collapseBtn.querySelector('.collapse-text');
    const collapseOverlay = codeContainer.querySelector('.collapse-overlay');

    
    let codeElement = codeContainer.querySelector('pre.chroma');
    if (!codeElement) {
      codeElement = codeContainer.querySelector('pre');
    }

    const defaultState = collapseBtn.dataset.defaultState || 'expanded';
    const isCollapsedAttr = collapseBtn.dataset.collapsed === 'true';
    const autoCollapseLines = parseInt(collapseBtn.dataset.autoCollapseLines) || 30;
    const autoCollapseHeight = parseInt(collapseBtn.dataset.autoCollapseHeight) || 400;
    const collapsedHeight = parseInt(collapseBtn.dataset.collapsedHeight) || 120;

    let isCollapsed = false;

    
    function initCollapse() {
      
      const shouldCollapse = isCollapsedAttr ||
                           defaultState === 'collapsed' ||
                           shouldAutoCollapse();

      if (shouldCollapse) {
        setCollapsed(true, false); 
      }
    }

    function shouldAutoCollapse() {
      
      if (codeElement) {
        const lines = codeElement.querySelectorAll('.line, .cl');
        const height = codeElement.offsetHeight;
        return lines.length > autoCollapseLines || height > autoCollapseHeight;
      }

      
      const containerHeight = codeContainer.offsetHeight;
      if (containerHeight > autoCollapseHeight) {
        return true;
      }

      
      const textContent = codeContainer.textContent || codeContainer.innerText || '';
      const estimatedLines = textContent.split('\n').length;
      return estimatedLines > autoCollapseLines;
    }

    function setCollapsed(collapsed, animate = true) {
      if (!collapseOverlay) return;

      isCollapsed = collapsed;

      if (collapsed) {
        
        codeContainer.style.maxHeight = collapsedHeight + 'px';
        codeContainer.style.overflow = 'hidden';
        collapseOverlay.style.opacity = '1';
        collapseOverlay.style.pointerEvents = 'auto';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M19 9l-7 7-7-7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '펼치기';
        }
        collapseBtn.title = '펼치기';

      } else {
        
        codeContainer.style.maxHeight = '';
        codeContainer.style.overflow = '';
        collapseOverlay.style.opacity = '0';
        collapseOverlay.style.pointerEvents = 'none';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath fill=\u0022currentColor\u0022 d=\u0022M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z\u0022\/\u003e\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '접기';
        }
        collapseBtn.title = '접기';
      }

      
      if (animate) {
        codeContainer.style.transition = 'max-height 0.3s ease-out';
        setTimeout(() => {
          codeContainer.style.transition = '';
        }, 300);
      }
    }

    function toggleCollapse() {
      setCollapsed(!isCollapsed, true);
    }

    
    collapseBtn.addEventListener('click', toggleCollapse);

    
    if (collapseOverlay) {
      collapseOverlay.addEventListener('click', () => {
        if (isCollapsed) {
          setCollapsed(false, true);
        }
      });
    }

    
    initCollapse();
  }
})();
</script>
<h3 id="한눈에-결론-1">한눈에 결론</h3>
<p><strong>Helix Parallelism은 초장기 LLM 디코딩에서 주요 SOTA( Medha-style KVP, TP/PP/EP 조합 등)보다 ‘지연-동시성’ 두 축 모두를 압도하지만, 통신 병목이 작거나 GPU 수가 헤드 수보다 적은 소규모 설정에서는 이득폭이 제한적이다.</strong></p>
<hr>
<h2 id="1-helix-vs-주요-베이스라인sota--성능-비교표">1. Helix vs. 주요 베이스라인·SOTA ― 성능 비교표</h2>
<table>
  <thead>
      <tr>
          <th>모델·환경 (1 M ctx)</th>
          <th>비교 대상</th>
          <th>TTL ↓</th>
          <th>동시 배치↑ / TPS·GPU↑</th>
          <th>저자 주장 ‘결정적 승부처’</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>DeepSeek-R1 (671 B MoE, 72 GPU)</strong></td>
          <td><strong>Medha KVP + TP(=K=8)</strong></td>
          <td><strong>1.50 ×</strong></td>
          <td><strong>32 ×</strong></td>
          <td>KV 중복 0 % + FFN 로드 분산으로 두 병목 동시 해소</td>
      </tr>
      <tr>
          <td></td>
          <td><strong>Best TP only (K=8)</strong></td>
          <td><strong>&gt;1.80 ×</strong></td>
          <td><strong>32 ×</strong></td>
          <td>TP 폭 제한 없이 KV 중복 회피</td>
      </tr>
      <tr>
          <td><strong>Llama-405B (Dense)</strong></td>
          <td><strong>Medha + TP(=8)</strong></td>
          <td><strong>1.13 ×</strong></td>
          <td><strong>4 ×</strong> TPS·GPU</td>
          <td>헤드 수(K=8) 초과 TP에서도 KV 복제 無</td>
      </tr>
      <tr>
          <td></td>
          <td><strong>Pipeline Parallel(8 stage)</strong></td>
          <td><strong>&gt;1.30 ×</strong></td>
          <td><strong>2–3 ×</strong></td>
          <td>PP는 디코딩 시 TTL 대폭 증가</td>
      </tr>
  </tbody>
</table>

  <blockquote
    class="border-primary bg-muted/30 hover:bg-muted/40 my-6 rounded-r-lg border-l-4 py-4 pr-4 pl-6 italic transition-all duration-200 ease-out hover:translate-x-1">
    <div class="prose prose-sm max-w-none">
      <p><strong>가장 강력한 증거</strong>는 DeepSeek-R1에서 <em>동일 TTL 예산으로 32 배 더 많은 사용자</em>를 처리하면서도 TTL 자체를 1.5 배 줄였다는 수치(그림 5, 파레토 프론티어 이동).</p>
    </div>
  </blockquote>

<hr>
<h2 id="2-helix가-압도적이지-못했던-경우">2. Helix가 압도적이지 못했던 경우</h2>
<table>
  <thead>
      <tr>
          <th>관측 지점</th>
          <th>Helix ≤ 베이스라인</th>
          <th>저자 해석</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>프리-필(prefill) 단계</strong></td>
          <td>TP + PP가 미세하게 더 빠름</td>
          <td>프리-필은 KV 캐시가 짧고 FFN 로드 지배 → Helix 이점 작음</td>
      </tr>
      <tr>
          <td><strong>GPU ≤ K (예: 16 GPU, K=8)</strong></td>
          <td>KV 중복 없는 TP가 이미 최적</td>
          <td>이때는 KV 캐시가 전체 복제되지 않으므로 Helix 장점 감소</td>
      </tr>
      <tr>
          <td><strong>통신·계산 비중 역전(DeepSeek-R1 HOP-B ablation)</strong></td>
          <td>HOP-B ON/OFF 차이 ≤1 % TTL</td>
          <td>FFN 단계가 절대적 병목 → 통신 은닉 여유분이 작음</td>
      </tr>
  </tbody>
</table>
<p>저자들은 <strong>“Helix는 ‘KV 중복 + FFN 로드’가 동시에 지배적일 때 최대 효과</strong>를 보인다”고 명시한다. 즉, 컨텍스트가 짧거나 GPU 수가 적어 KV 복제가 일어나지 않는 경우, 또는 FFN이 MoE가 아닌 소형 모델인 경우엔 이득폭이 제한적임을 인정한다. KV 헤드 K와 GPU 수 G의 상대 규모가 Helix 적용 이득을 가르는 핵심 매개 변수라는 것이다.</p>
<hr>
<h2 id="3-요약--비판적-시사점">3. 요약 &amp; 비판적 시사점</h2>
<ol>
<li><strong>대규모·초장기 디코딩</strong>(≥ 1 M 토큰, G≫K) <strong>→ Helix가 Pareto 프론티어 자체를 바깥으로 이동</strong>.</li>
<li><strong>소규모·짧은 컨텍스트</strong> <strong>→ 베이스라인과 근소차,</strong> 통신 은닉 효과도 작아짐.</li>
<li><strong>따라서</strong> Helix는 “모든 상황에서 만능”이라기보다, <strong>대형 서비스-등급 LLM 배치</strong>에 특화된 병렬화 옵션으로 보는 편이 타당하다.</li>
</ol>

  <blockquote
    class="border-primary bg-muted/30 hover:bg-muted/40 my-6 rounded-r-lg border-l-4 py-4 pr-4 pl-6 italic transition-all duration-200 ease-out hover:translate-x-1">
    <div class="prose prose-sm max-w-none">
      <p><strong>결론적으로</strong>, Helix가 제시한 압도적 수치는 **“KV 중복과 FFN 로드가 동시에 병목”**인 시나리오에서 나왔으며, 다른 병목 지형에서는 기존 TP·PP도 여전히 유효하다는 점을 기억해야 한다.</p>
    </div>
  </blockquote>

<h1 id="프롬프트-151-언급된-한계와-잠재적-한계">프롬프트 1.5.1 (언급된 한계와 잠재적 한계)</h1>
<div
  class="code-block-container border-border bg-card my-6 overflow-hidden rounded-xl border shadow-sm transition-all duration-200 ease-out hover:-translate-y-0.5 hover:shadow-md">
  
  <div
    class="code-block-header bg-muted/30 border-border flex items-center justify-between border-b px-4 py-3">
    
    <div class="flex items-center gap-2">
      <div class="text-muted-foreground flex-shrink-0">
        
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4" />
</svg>
      </div>
      <span class="text-muted-foreground text-sm font-medium">
        PLAINTEXT
      </span>
    </div>

    
    <div class="flex items-center gap-2">
      <button
          class="collapse-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
          data-code-id="code-9"
          data-default-state="expanded"
          data-collapsed="false"
          data-auto-collapse-lines="30"
          data-auto-collapse-height="400"
          data-collapsed-height="120"
          title="접기"
          aria-label="접기">
          <span class="collapse-icon">
            
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path fill="currentColor" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z"/></svg>
          </span>
          <span class="collapse-text hidden sm:inline"
            >접기</span
          >
        </button>
      <button
        class="copy-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
        data-code-id="code-9"
        title="복사"
        aria-label="복사">
        <span class="copy-icon">
          
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
</svg>
        </span>
        <span class="copy-text hidden sm:inline"
          >복사</span
        >
      </button>
    </div>
  </div>

  
  <div class="code-block-content relative" id="code-9">
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">&#34;저자들이 논문에서 명시적으로 인정한 한계점, 약점, 또는 실패 사례(failure modes)는 무엇인가? 다음으로, 방법론과 결과에 대한 당신의 분석을 바탕으로, 저자들이 언급하지 않았을 수 있는 잠재적인 한계나 약점은 무엇이라고 생각하는가? (예: 강력한 가정에 대한 의존성, 확장성 문제, 높은 연산 비용, 일반화의 한계, 잠재적인 부정적 사회 영향 등)&#34;</span></span></code></pre></div>
    
    <div
      class="collapse-overlay to-card/90 pointer-events-none absolute inset-0 bg-gradient-to-b from-transparent via-transparent opacity-0 transition-opacity duration-300">
      <div
        class="text-muted-foreground bg-card/80 border-border/50 hover:bg-primary/10 hover:text-primary hover:border-primary/30 absolute bottom-4 left-1/2 -translate-x-1/2 cursor-pointer rounded-full border px-3 py-1.5 text-xs backdrop-blur-sm transition-all duration-200">
        클릭하여 더 보기
      </div>
    </div>
  </div>
</div>


<script>
(function() {
  const codeId = 'code-9';
  const copyBtn = document.querySelector('.copy-code-btn[data-code-id="' + codeId + '"]');
  const collapseBtn = document.querySelector('.collapse-code-btn[data-code-id="' + codeId + '"]');
  const codeContainer = document.getElementById(codeId);

  if (!codeContainer) return;

  
  if (copyBtn) {
    const copyIcon = copyBtn.querySelector('.copy-icon');
    const copyText = copyBtn.querySelector('.copy-text');

    copyBtn.addEventListener('click', async function() {
      try {
        
        let codeText = '';

        
        const codeTableCell = codeContainer.querySelector('.lntd:last-child code');
        if (codeTableCell) {
          codeText = codeTableCell.textContent || codeTableCell.innerText;
        } else {
          
          const codeElement = codeContainer.querySelector('code');
          if (codeElement) {
            
            const hasInlineLineNumbers = codeElement.querySelector('.ln');
            if (hasInlineLineNumbers) {
              
              const codeLines = codeElement.querySelectorAll('.cl');
              if (codeLines.length > 0) {
                codeText = Array.from(codeLines)
                  .map(line => {
                    const text = line.textContent || line.innerText;
                    
                    return text.replace(/\n+$/, '');
                  })
                  .join('\n')
                  .replace(/\n+$/, ''); 
              } else {
                
                const allText = codeElement.textContent || codeElement.innerText;
                codeText = allText.replace(/^\d+/gm, '').replace(/^\s+/gm, '');
              }
            } else {
              
              codeText = codeElement.textContent || codeElement.innerText;
            }
          } else {
            
            codeText = codeContainer.textContent || codeContainer.innerText;
          }
        }

        
        codeText = codeText.trim();

        
        await navigator.clipboard.writeText(codeText);

        
        copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M5 13l4 4L19 7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (copyText) {
          copyText.textContent = '복사됨';
        }
        copyBtn.classList.add('text-green-600');

        
        setTimeout(() => {
          copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z\u0022 \/\u003e\n\u003c\/svg\u003e`;
          if (copyText) {
            copyText.textContent = '복사';
          }
          copyBtn.classList.remove('text-green-600');
        }, 2000);

      } catch (err) {
        console.error('复制失败:', err);

        
        const range = document.createRange();
        const codeElement = codeContainer.querySelector('code') || codeContainer;
        range.selectNodeContents(codeElement);
        const selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);

        
        if (copyText) {
          copyText.textContent = '선택됨';
        }

        setTimeout(() => {
          if (copyText) {
            copyText.textContent = '복사';
          }
          selection.removeAllRanges();
        }, 2000);
      }
    });
  }

  
  if (collapseBtn) {
    const collapseIcon = collapseBtn.querySelector('.collapse-icon');
    const collapseText = collapseBtn.querySelector('.collapse-text');
    const collapseOverlay = codeContainer.querySelector('.collapse-overlay');

    
    let codeElement = codeContainer.querySelector('pre.chroma');
    if (!codeElement) {
      codeElement = codeContainer.querySelector('pre');
    }

    const defaultState = collapseBtn.dataset.defaultState || 'expanded';
    const isCollapsedAttr = collapseBtn.dataset.collapsed === 'true';
    const autoCollapseLines = parseInt(collapseBtn.dataset.autoCollapseLines) || 30;
    const autoCollapseHeight = parseInt(collapseBtn.dataset.autoCollapseHeight) || 400;
    const collapsedHeight = parseInt(collapseBtn.dataset.collapsedHeight) || 120;

    let isCollapsed = false;

    
    function initCollapse() {
      
      const shouldCollapse = isCollapsedAttr ||
                           defaultState === 'collapsed' ||
                           shouldAutoCollapse();

      if (shouldCollapse) {
        setCollapsed(true, false); 
      }
    }

    function shouldAutoCollapse() {
      
      if (codeElement) {
        const lines = codeElement.querySelectorAll('.line, .cl');
        const height = codeElement.offsetHeight;
        return lines.length > autoCollapseLines || height > autoCollapseHeight;
      }

      
      const containerHeight = codeContainer.offsetHeight;
      if (containerHeight > autoCollapseHeight) {
        return true;
      }

      
      const textContent = codeContainer.textContent || codeContainer.innerText || '';
      const estimatedLines = textContent.split('\n').length;
      return estimatedLines > autoCollapseLines;
    }

    function setCollapsed(collapsed, animate = true) {
      if (!collapseOverlay) return;

      isCollapsed = collapsed;

      if (collapsed) {
        
        codeContainer.style.maxHeight = collapsedHeight + 'px';
        codeContainer.style.overflow = 'hidden';
        collapseOverlay.style.opacity = '1';
        collapseOverlay.style.pointerEvents = 'auto';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M19 9l-7 7-7-7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '펼치기';
        }
        collapseBtn.title = '펼치기';

      } else {
        
        codeContainer.style.maxHeight = '';
        codeContainer.style.overflow = '';
        collapseOverlay.style.opacity = '0';
        collapseOverlay.style.pointerEvents = 'none';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath fill=\u0022currentColor\u0022 d=\u0022M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z\u0022\/\u003e\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '접기';
        }
        collapseBtn.title = '접기';
      }

      
      if (animate) {
        codeContainer.style.transition = 'max-height 0.3s ease-out';
        setTimeout(() => {
          codeContainer.style.transition = '';
        }, 300);
      }
    }

    function toggleCollapse() {
      setCollapsed(!isCollapsed, true);
    }

    
    collapseBtn.addEventListener('click', toggleCollapse);

    
    if (collapseOverlay) {
      collapseOverlay.addEventListener('click', () => {
        if (isCollapsed) {
          setCollapsed(false, true);
        }
      });
    }

    
    initCollapse();
  }
})();
</script>
<h3 id="결론-1-줄-요약">결론 (1-줄 요약)</h3>
<p>Helix Parallelism은 <strong>“KV 중복 + FFN 로드”</strong> 쌍두 병목을 깔끔히 없애 주는 대신, <strong>GB200급 단일 노드·초장기 디코딩</strong>이라는 조건에 크게 의존하므로 ― 저자들도 시뮬레이터·단일 노드·장거리 컨텍스트 등 <strong>적용 범위의 한계</strong>를 명시하며, 짧은 문맥·소형 GPU 풀·다중 노드에서는 이득이 줄거나 사라질 수 있음을 인정한다.</p>
<hr>
<h2 id="1-저자가-직접-인정한-한계--실패-사례">1. 저자가 <strong>직접</strong> 인정한 한계 · 실패 사례</h2>
<table>
  <thead>
      <tr>
          <th>구분</th>
          <th>내용</th>
          <th>근거</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>시뮬레이션 기반 결과</strong></td>
          <td>모든 수치는 <strong>GB200 NVL72를 모델링한 사내 시뮬레이터</strong>로 얻었으며, “절대 성능보다 추세를 본다”고 명시 → 실측과 오차 가능</td>
          <td></td>
      </tr>
      <tr>
          <td><strong>모델 자체가 1 M 토큰을 아직 직접 지원하지 않음</strong></td>
          <td>DeepSeek-R1·Llama-405B는 “native million-token 지원 전” 상태이며, Helix는 <strong>가정한 KV 길이</strong>로만 분석</td>
          <td></td>
      </tr>
      <tr>
          <td><strong>짧은 문맥(&lt; 4 K)·소형 GPU 풀에선 이득 축소</strong></td>
          <td>짧은 컨텍스트에서는 Helix가 <strong>기존 데이터-병렬 Attention + TP FFN</strong> 패턴으로 사실상 귀결된다고 서술</td>
          <td></td>
      </tr>
      <tr>
          <td><strong>통신 은닉 효과 편차</strong></td>
          <td>DeepSeek-R1은 HOP-B OFF 시 TTL ↓ 1 % — 즉, <strong>통신이 작으면 Helix 이득이 미미</strong></td>
          <td></td>
      </tr>
      <tr>
          <td><strong>Sparse Attention 미지원</strong></td>
          <td>NSA 등 **희소 어텐션은 ‘향후 과제’**로 남겨둠</td>
          <td></td>
      </tr>
  </tbody>
</table>
<hr>
<h2 id="2-추가로-예상되는-잠재-한계-비판적-분석">2. 추가로 예상되는 <strong>잠재 한계</strong> (비판적 분석)</h2>
<ol>
<li>
<p><strong>단일 노드 가정</strong>
Helix는 NVLink 도메인 내부 All-to-All 대역을 전제로 한다. <strong>다중 노드(MPI/RDMA)</strong> 환경에선 통신 은닉이 어려워질 수 있다.</p>
</li>
<li>
<p><strong>하드웨어 전용성</strong>
GB200 급 8 TB/s-class DRAM·FP4 매트릭스 코어를 전제로 한 Roofline 튜닝이므로, <strong>상대적으로 느린 HBM·PCIe-기반 GPU</strong>나 CPU/NPU에선 이득폭이 감소할 수 있다.</p>
</li>
<li>
<p><strong>동적 레이아웃 전환 비용</strong>
레이어마다 <strong>KVP→TP(×EP) 재배치</strong>를 수행하려면 런타임이 토큰 단위로 통신 topology·메모리 매핑을 바꿔야 한다. 대규모 멀티-테넌트 서비스에서 스케줄러 복잡도가 급증할 수 있다.</p>
</li>
<li>
<p><strong>정밀도·수치 안정성</strong>
모든 실험이 <strong>FP4 가정</strong>이다. 매우 깊은 레이어·극단적 온도에서 LSE 재스케일 수식의 <strong>언더/오버플로</strong> 위험이 증가할 수 있으나 정밀도 분석은 제공되지 않는다.</p>
</li>
<li>
<p><strong>품질(Perplexity) 검증 부재</strong>
Helix는 <strong>성능 지표(TTL·TPS)만</strong> 보고한다. 캐시 샤딩·FP4 연산이 실제 출력 품질이나 드리프트에 미치는 영향은 실험되지 않았다.</p>
</li>
<li>
<p><strong>에너지·환경 비용</strong>
64–72 GPU를 실시간으로 몰아넣어 TTL을 ↓1.5 × → <strong>절대 소비전력은 증가</strong>할 가능성이 큰데, 에너지 효율 분석이 없다.</p>
</li>
</ol>
<hr>
<h3 id="정리--쓸-만한-시사점">정리 — 쓸 만한 시사점</h3>
<ul>
<li>Helix의 <strong>주 타깃</strong>은 “<strong>G≫K · S≥10⁶ · NVLink급 단일 노드</strong>”라는 <strong>특수한 대형 서빙 시나리오</strong>다.</li>
<li>짧은 문맥·저대역 인터커넥트·다중 노드·희소 어텐션·품질 검증 등에서는 <strong>후속 연구 여지</strong>가 크다.</li>
<li>결과적으로, Helix를 실제 서비스에 도입하려면 <strong>(1) 하드웨어 일치 여부, (2) 통신 패브릭, (3) 기대 동시 사용자 규모</strong>를 면밀히 따져 <strong>“우리 워크로드가 정말 이중 병목 구간인지”</strong> 먼저 확인해야 한다.</li>
</ul>
<h1 id="프롬프트-152-미래-연구-궤적">프롬프트 1.5.2 (미래 연구 궤적)</h1>
<div
  class="code-block-container border-border bg-card my-6 overflow-hidden rounded-xl border shadow-sm transition-all duration-200 ease-out hover:-translate-y-0.5 hover:shadow-md">
  
  <div
    class="code-block-header bg-muted/30 border-border flex items-center justify-between border-b px-4 py-3">
    
    <div class="flex items-center gap-2">
      <div class="text-muted-foreground flex-shrink-0">
        
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4" />
</svg>
      </div>
      <span class="text-muted-foreground text-sm font-medium">
        PLAINTEXT
      </span>
    </div>

    
    <div class="flex items-center gap-2">
      <button
          class="collapse-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
          data-code-id="code-10"
          data-default-state="expanded"
          data-collapsed="false"
          data-auto-collapse-lines="30"
          data-auto-collapse-height="400"
          data-collapsed-height="120"
          title="접기"
          aria-label="접기">
          <span class="collapse-icon">
            
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path fill="currentColor" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z"/></svg>
          </span>
          <span class="collapse-text hidden sm:inline"
            >접기</span
          >
        </button>
      <button
        class="copy-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
        data-code-id="code-10"
        title="복사"
        aria-label="복사">
        <span class="copy-icon">
          
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
</svg>
        </span>
        <span class="copy-text hidden sm:inline"
          >복사</span
        >
      </button>
    </div>
  </div>

  
  <div class="code-block-content relative" id="code-10">
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">&#34;저자들이 제안하는 구체적인 향후 연구 방향은 무엇인가? 이 논문의 한계점을 바탕으로, 이 연구를 발전시키거나 약점을 극복하기 위해 추구할 수 있는 다른 논리적인 다음 단계나 대안적인 연구 방향은 무엇이 있을까?&#34;</span></span></code></pre></div>
    
    <div
      class="collapse-overlay to-card/90 pointer-events-none absolute inset-0 bg-gradient-to-b from-transparent via-transparent opacity-0 transition-opacity duration-300">
      <div
        class="text-muted-foreground bg-card/80 border-border/50 hover:bg-primary/10 hover:text-primary hover:border-primary/30 absolute bottom-4 left-1/2 -translate-x-1/2 cursor-pointer rounded-full border px-3 py-1.5 text-xs backdrop-blur-sm transition-all duration-200">
        클릭하여 더 보기
      </div>
    </div>
  </div>
</div>


<script>
(function() {
  const codeId = 'code-10';
  const copyBtn = document.querySelector('.copy-code-btn[data-code-id="' + codeId + '"]');
  const collapseBtn = document.querySelector('.collapse-code-btn[data-code-id="' + codeId + '"]');
  const codeContainer = document.getElementById(codeId);

  if (!codeContainer) return;

  
  if (copyBtn) {
    const copyIcon = copyBtn.querySelector('.copy-icon');
    const copyText = copyBtn.querySelector('.copy-text');

    copyBtn.addEventListener('click', async function() {
      try {
        
        let codeText = '';

        
        const codeTableCell = codeContainer.querySelector('.lntd:last-child code');
        if (codeTableCell) {
          codeText = codeTableCell.textContent || codeTableCell.innerText;
        } else {
          
          const codeElement = codeContainer.querySelector('code');
          if (codeElement) {
            
            const hasInlineLineNumbers = codeElement.querySelector('.ln');
            if (hasInlineLineNumbers) {
              
              const codeLines = codeElement.querySelectorAll('.cl');
              if (codeLines.length > 0) {
                codeText = Array.from(codeLines)
                  .map(line => {
                    const text = line.textContent || line.innerText;
                    
                    return text.replace(/\n+$/, '');
                  })
                  .join('\n')
                  .replace(/\n+$/, ''); 
              } else {
                
                const allText = codeElement.textContent || codeElement.innerText;
                codeText = allText.replace(/^\d+/gm, '').replace(/^\s+/gm, '');
              }
            } else {
              
              codeText = codeElement.textContent || codeElement.innerText;
            }
          } else {
            
            codeText = codeContainer.textContent || codeContainer.innerText;
          }
        }

        
        codeText = codeText.trim();

        
        await navigator.clipboard.writeText(codeText);

        
        copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M5 13l4 4L19 7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (copyText) {
          copyText.textContent = '복사됨';
        }
        copyBtn.classList.add('text-green-600');

        
        setTimeout(() => {
          copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z\u0022 \/\u003e\n\u003c\/svg\u003e`;
          if (copyText) {
            copyText.textContent = '복사';
          }
          copyBtn.classList.remove('text-green-600');
        }, 2000);

      } catch (err) {
        console.error('复制失败:', err);

        
        const range = document.createRange();
        const codeElement = codeContainer.querySelector('code') || codeContainer;
        range.selectNodeContents(codeElement);
        const selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);

        
        if (copyText) {
          copyText.textContent = '선택됨';
        }

        setTimeout(() => {
          if (copyText) {
            copyText.textContent = '복사';
          }
          selection.removeAllRanges();
        }, 2000);
      }
    });
  }

  
  if (collapseBtn) {
    const collapseIcon = collapseBtn.querySelector('.collapse-icon');
    const collapseText = collapseBtn.querySelector('.collapse-text');
    const collapseOverlay = codeContainer.querySelector('.collapse-overlay');

    
    let codeElement = codeContainer.querySelector('pre.chroma');
    if (!codeElement) {
      codeElement = codeContainer.querySelector('pre');
    }

    const defaultState = collapseBtn.dataset.defaultState || 'expanded';
    const isCollapsedAttr = collapseBtn.dataset.collapsed === 'true';
    const autoCollapseLines = parseInt(collapseBtn.dataset.autoCollapseLines) || 30;
    const autoCollapseHeight = parseInt(collapseBtn.dataset.autoCollapseHeight) || 400;
    const collapsedHeight = parseInt(collapseBtn.dataset.collapsedHeight) || 120;

    let isCollapsed = false;

    
    function initCollapse() {
      
      const shouldCollapse = isCollapsedAttr ||
                           defaultState === 'collapsed' ||
                           shouldAutoCollapse();

      if (shouldCollapse) {
        setCollapsed(true, false); 
      }
    }

    function shouldAutoCollapse() {
      
      if (codeElement) {
        const lines = codeElement.querySelectorAll('.line, .cl');
        const height = codeElement.offsetHeight;
        return lines.length > autoCollapseLines || height > autoCollapseHeight;
      }

      
      const containerHeight = codeContainer.offsetHeight;
      if (containerHeight > autoCollapseHeight) {
        return true;
      }

      
      const textContent = codeContainer.textContent || codeContainer.innerText || '';
      const estimatedLines = textContent.split('\n').length;
      return estimatedLines > autoCollapseLines;
    }

    function setCollapsed(collapsed, animate = true) {
      if (!collapseOverlay) return;

      isCollapsed = collapsed;

      if (collapsed) {
        
        codeContainer.style.maxHeight = collapsedHeight + 'px';
        codeContainer.style.overflow = 'hidden';
        collapseOverlay.style.opacity = '1';
        collapseOverlay.style.pointerEvents = 'auto';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M19 9l-7 7-7-7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '펼치기';
        }
        collapseBtn.title = '펼치기';

      } else {
        
        codeContainer.style.maxHeight = '';
        codeContainer.style.overflow = '';
        collapseOverlay.style.opacity = '0';
        collapseOverlay.style.pointerEvents = 'none';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath fill=\u0022currentColor\u0022 d=\u0022M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z\u0022\/\u003e\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '접기';
        }
        collapseBtn.title = '접기';
      }

      
      if (animate) {
        codeContainer.style.transition = 'max-height 0.3s ease-out';
        setTimeout(() => {
          codeContainer.style.transition = '';
        }, 300);
      }
    }

    function toggleCollapse() {
      setCollapsed(!isCollapsed, true);
    }

    
    collapseBtn.addEventListener('click', toggleCollapse);

    
    if (collapseOverlay) {
      collapseOverlay.addEventListener('click', () => {
        if (isCollapsed) {
          setCollapsed(false, true);
        }
      });
    }

    
    initCollapse();
  }
})();
</script>
<h3 id="요약--다음-스텝-한눈에">요약 — 다음 스텝 한눈에</h3>
<p><em>저자들은 Helix Parallelism을 “<strong>희소 어텐션(Natively Sparse Attention, NSA)</strong> 등 <strong>새로운 어텐션 변형에도 모듈식으로 확장</strong>”하는 것을 1순위 후속 연구로 제시한다. 이에 더해 실제 서비스·멀티-노드·품질·에너지 측면에서 열려 있는 6가지 과제를 논리적 다음 단계로 제안한다.</em></p>
<hr>
<h2 id="1-저자들이-명시한-향후-연구-방향">1. 저자들이 명시한 향후 연구 방향</h2>
<table>
  <thead>
      <tr>
          <th>#</th>
          <th>제안</th>
          <th>기대 효과</th>
          <th>출처</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>A1</strong></td>
          <td><strong>희소 어텐션(예: NSA) 지원</strong></td>
          <td>KV 읽기 대역폭 추가 -50 % 수준까지 절감하며, Helix의 2-D 샤딩·All-to-All 재조합 논리를 그대로 적용 가능</td>
          <td></td>
      </tr>
      <tr>
          <td><strong>A2</strong></td>
          <td>“Helix는 짧은 컨텍스트(&lt; 4 K)에서도 통일적 추상화를 제공” ⇒ <strong>전 길이 스펙트럼에서 단일 런타임</strong></td>
          <td>모델 길이에 따른 패스 스위칭이 필요 없도록 코드 베이스 단순화</td>
          <td></td>
      </tr>
  </tbody>
</table>

  <blockquote
    class="border-primary bg-muted/30 hover:bg-muted/40 my-6 rounded-r-lg border-l-4 py-4 pr-4 pl-6 italic transition-all duration-200 ease-out hover:translate-x-1">
    <div class="prose prose-sm max-w-none">
      <p>저자들이 <strong>구체적으로 언급한 ‘Future work’는 위 두 항목</strong>이 전부이다.</p>
    </div>
  </blockquote>

<hr>
<h2 id="2-논문-한계-기반--추가로-필요한-연구-6선">2. 논문 한계 기반 ✔️ 추가로 필요한 연구 6선</h2>
<table>
  <thead>
      <tr>
          <th>잠재 한계 ↘</th>
          <th>제안하는 연구 궤적 ↗</th>
          <th>왜 중요한가?</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>단일 NVLink 노드 가정</strong></td>
          <td><strong>B1 멀티-노드 Helix</strong>: 2-Hop NVSwitch, PCIe+InfiniBand 혼합 환경에서 All-to-All/HOP-B를 계층형 Topology-Aware 통신으로 재설계</td>
          <td>실제 대규모 서빙은 랙·클러스터跨; NVLink가 아닌 구간에서 통신 은닉률↓</td>
      </tr>
      <tr>
          <td><strong>통신 병목 작을 때 이득 ≤ 1 % (DeepSeek-R1 실험)</strong></td>
          <td><strong>B2 Adaptive Layout Scheduler</strong>: KV·FFN 비중을 실시간 계측해 ‘Helix↔전통 TP’ 동적 전환</td>
          <td>통신/계산 비가 변하는 작은 모델·짧은 S에서 불필요한 레이아웃 전환 비용 최소화</td>
      </tr>
      <tr>
          <td><strong>FP4 전제, 수치 안정성·정확도 검증 부재</strong></td>
          <td><strong>B3 FP8/BF16 혼합 &amp; 출력 품질 시험</strong>(PPL·BLEU 등)</td>
          <td>LSE 재스케일식이 저정밀에서 언더플로 위험; 품질-성능 Pareto 재평가 필요</td>
      </tr>
      <tr>
          <td><strong>에너지·탄소 지표 미측정</strong></td>
          <td><strong>B4 J/Token-aware Helix</strong>: GPU 전력계·NVML 계측으로 TTL-당 Wh, CO₂eq 보고</td>
          <td>72 GPU 동시 구동은 절대 전력↑; SLA-외 효율 메트릭 필수</td>
      </tr>
      <tr>
          <td><strong>KV 캐시만 GPU HBM에 저장 가정</strong></td>
          <td><strong>B5 Hierarchical KV Caching + Helix</strong>: GPU↔CPU↔NVM 계층형 prefetch와 Helix KVP 동시 사용</td>
          <td>10⁶ ⟶ 10⁷ 토큰 스케일 시 HBM 용량도 한계</td>
      </tr>
      <tr>
          <td><strong>품질 편향 가능성</strong></td>
          <td><strong>B6 Alignment/Robustness Stress-test</strong>: Helix vs. TP 동일 출력 여부·레이턴시-품질 Trade-off 체계적 측정</td>
          <td>병렬 재조합이 의미론적 Drift를 유발하는지 확인</td>
      </tr>
  </tbody>
</table>
<hr>
<h2 id="3-정리">3. 정리</h2>
<ul>
<li>Helix의 <strong>공식적인 ‘미래 연구’는 희소 어텐션 지원과 전-컨텍스트 통합 런타임</strong> 두 가지로 압축된다.</li>
<li>그러나 실제 배포를 염두에 두면 <strong>통신 토폴로지, 정밀도, 에너지, 계층형 메모리, 동적 스케줄링, 품질 보존</strong> 등 여섯 축에서 후속 연구가 요구된다.</li>
<li>이러한 궤적은 Helix가 제안한 <strong>KV 중복 0 % + FFN 로드 분산</strong>의 이점을 <strong>멀티-노드·멀티-워크로드 현실</strong>로 확장하고, <strong>정확도-전력-비용</strong>까지 포함한 새로운 Pareto 프론티어를 재정의할 것이다.</li>
</ul>
<h1 id="실제-예시">실제 예시</h1>
<div
  class="code-block-container border-border bg-card my-6 overflow-hidden rounded-xl border shadow-sm transition-all duration-200 ease-out hover:-translate-y-0.5 hover:shadow-md">
  
  <div
    class="code-block-header bg-muted/30 border-border flex items-center justify-between border-b px-4 py-3">
    
    <div class="flex items-center gap-2">
      <div class="text-muted-foreground flex-shrink-0">
        
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4" />
</svg>
      </div>
      <span class="text-muted-foreground text-sm font-medium">
        PLAINTEXT
      </span>
    </div>

    
    <div class="flex items-center gap-2">
      <button
          class="collapse-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
          data-code-id="code-11"
          data-default-state="expanded"
          data-collapsed="false"
          data-auto-collapse-lines="30"
          data-auto-collapse-height="400"
          data-collapsed-height="120"
          title="접기"
          aria-label="접기">
          <span class="collapse-icon">
            
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path fill="currentColor" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z"/></svg>
          </span>
          <span class="collapse-text hidden sm:inline"
            >접기</span
          >
        </button>
      <button
        class="copy-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
        data-code-id="code-11"
        title="복사"
        aria-label="복사">
        <span class="copy-icon">
          
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
</svg>
        </span>
        <span class="copy-text hidden sm:inline"
          >복사</span
        >
      </button>
    </div>
  </div>

  
  <div class="code-block-content relative" id="code-11">
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">&#34;llama3 70B를 16개의 gpu로 helix를 사용한다고 하면 decode step에서 실제로 어떤 구간에서 어디를 어떻게 짜르는지 자세하게 예시를 통해서 알려줄 수 있니?&#34;</span></span></code></pre></div>
    
    <div
      class="collapse-overlay to-card/90 pointer-events-none absolute inset-0 bg-gradient-to-b from-transparent via-transparent opacity-0 transition-opacity duration-300">
      <div
        class="text-muted-foreground bg-card/80 border-border/50 hover:bg-primary/10 hover:text-primary hover:border-primary/30 absolute bottom-4 left-1/2 -translate-x-1/2 cursor-pointer rounded-full border px-3 py-1.5 text-xs backdrop-blur-sm transition-all duration-200">
        클릭하여 더 보기
      </div>
    </div>
  </div>
</div>


<script>
(function() {
  const codeId = 'code-11';
  const copyBtn = document.querySelector('.copy-code-btn[data-code-id="' + codeId + '"]');
  const collapseBtn = document.querySelector('.collapse-code-btn[data-code-id="' + codeId + '"]');
  const codeContainer = document.getElementById(codeId);

  if (!codeContainer) return;

  
  if (copyBtn) {
    const copyIcon = copyBtn.querySelector('.copy-icon');
    const copyText = copyBtn.querySelector('.copy-text');

    copyBtn.addEventListener('click', async function() {
      try {
        
        let codeText = '';

        
        const codeTableCell = codeContainer.querySelector('.lntd:last-child code');
        if (codeTableCell) {
          codeText = codeTableCell.textContent || codeTableCell.innerText;
        } else {
          
          const codeElement = codeContainer.querySelector('code');
          if (codeElement) {
            
            const hasInlineLineNumbers = codeElement.querySelector('.ln');
            if (hasInlineLineNumbers) {
              
              const codeLines = codeElement.querySelectorAll('.cl');
              if (codeLines.length > 0) {
                codeText = Array.from(codeLines)
                  .map(line => {
                    const text = line.textContent || line.innerText;
                    
                    return text.replace(/\n+$/, '');
                  })
                  .join('\n')
                  .replace(/\n+$/, ''); 
              } else {
                
                const allText = codeElement.textContent || codeElement.innerText;
                codeText = allText.replace(/^\d+/gm, '').replace(/^\s+/gm, '');
              }
            } else {
              
              codeText = codeElement.textContent || codeElement.innerText;
            }
          } else {
            
            codeText = codeContainer.textContent || codeContainer.innerText;
          }
        }

        
        codeText = codeText.trim();

        
        await navigator.clipboard.writeText(codeText);

        
        copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M5 13l4 4L19 7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (copyText) {
          copyText.textContent = '복사됨';
        }
        copyBtn.classList.add('text-green-600');

        
        setTimeout(() => {
          copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z\u0022 \/\u003e\n\u003c\/svg\u003e`;
          if (copyText) {
            copyText.textContent = '복사';
          }
          copyBtn.classList.remove('text-green-600');
        }, 2000);

      } catch (err) {
        console.error('复制失败:', err);

        
        const range = document.createRange();
        const codeElement = codeContainer.querySelector('code') || codeContainer;
        range.selectNodeContents(codeElement);
        const selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);

        
        if (copyText) {
          copyText.textContent = '선택됨';
        }

        setTimeout(() => {
          if (copyText) {
            copyText.textContent = '복사';
          }
          selection.removeAllRanges();
        }, 2000);
      }
    });
  }

  
  if (collapseBtn) {
    const collapseIcon = collapseBtn.querySelector('.collapse-icon');
    const collapseText = collapseBtn.querySelector('.collapse-text');
    const collapseOverlay = codeContainer.querySelector('.collapse-overlay');

    
    let codeElement = codeContainer.querySelector('pre.chroma');
    if (!codeElement) {
      codeElement = codeContainer.querySelector('pre');
    }

    const defaultState = collapseBtn.dataset.defaultState || 'expanded';
    const isCollapsedAttr = collapseBtn.dataset.collapsed === 'true';
    const autoCollapseLines = parseInt(collapseBtn.dataset.autoCollapseLines) || 30;
    const autoCollapseHeight = parseInt(collapseBtn.dataset.autoCollapseHeight) || 400;
    const collapsedHeight = parseInt(collapseBtn.dataset.collapsedHeight) || 120;

    let isCollapsed = false;

    
    function initCollapse() {
      
      const shouldCollapse = isCollapsedAttr ||
                           defaultState === 'collapsed' ||
                           shouldAutoCollapse();

      if (shouldCollapse) {
        setCollapsed(true, false); 
      }
    }

    function shouldAutoCollapse() {
      
      if (codeElement) {
        const lines = codeElement.querySelectorAll('.line, .cl');
        const height = codeElement.offsetHeight;
        return lines.length > autoCollapseLines || height > autoCollapseHeight;
      }

      
      const containerHeight = codeContainer.offsetHeight;
      if (containerHeight > autoCollapseHeight) {
        return true;
      }

      
      const textContent = codeContainer.textContent || codeContainer.innerText || '';
      const estimatedLines = textContent.split('\n').length;
      return estimatedLines > autoCollapseLines;
    }

    function setCollapsed(collapsed, animate = true) {
      if (!collapseOverlay) return;

      isCollapsed = collapsed;

      if (collapsed) {
        
        codeContainer.style.maxHeight = collapsedHeight + 'px';
        codeContainer.style.overflow = 'hidden';
        collapseOverlay.style.opacity = '1';
        collapseOverlay.style.pointerEvents = 'auto';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M19 9l-7 7-7-7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '펼치기';
        }
        collapseBtn.title = '펼치기';

      } else {
        
        codeContainer.style.maxHeight = '';
        codeContainer.style.overflow = '';
        collapseOverlay.style.opacity = '0';
        collapseOverlay.style.pointerEvents = 'none';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath fill=\u0022currentColor\u0022 d=\u0022M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z\u0022\/\u003e\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '접기';
        }
        collapseBtn.title = '접기';
      }

      
      if (animate) {
        codeContainer.style.transition = 'max-height 0.3s ease-out';
        setTimeout(() => {
          codeContainer.style.transition = '';
        }, 300);
      }
    }

    function toggleCollapse() {
      setCollapsed(!isCollapsed, true);
    }

    
    collapseBtn.addEventListener('click', toggleCollapse);

    
    if (collapseOverlay) {
      collapseOverlay.addEventListener('click', () => {
        if (isCollapsed) {
          setCollapsed(false, true);
        }
      });
    }

    
    initCollapse();
  }
})();
</script>
<p>네, Llama 3 70B 모델을 16개 GPU 환경에서 Helix Parallelism을 사용하여 디코딩(decode)하는 과정을 단계별 예시를 통해 자세히 설명해 드리겠습니다.</p>
<p>Llama 3 70B와 같은 모델은 일반적으로 8개의 KV 헤드(Key/Value Head)를 가지는 GQA(Grouped-Query Attention) 구조를 사용합니다. 이 **KV 헤드 수(K=8)**와 **GPU 수(N=16)**가 Helix 전략을 결정하는 핵심 요소입니다.</p>
<p>디코딩 과정은 논문에서 설명한 대로 크게 <strong>1단계: 어텐션 연산</strong>과 <strong>2단계: FFN 연산</strong>으로 나뉩니다.</p>
<hr>
<h3 id="-1단계-어텐션attention-연산"><strong>🧠 1단계: 어텐션(Attention) 연산</strong></h3>
<p>이 단계의 목표는 16개 GPU를 모두 활용하여 거대한 KV 캐시를 효율적으로 읽고 어텐션 연산을 수행하는 것입니다.</p>
<h4 id="gpu-구성-및-데이터-분할-자르기-"><strong>GPU 구성 및 데이터 분할 (자르기) ✂️</strong></h4>
<p>16개의 GPU는 어텐션 연산을 위해 두 가지 병렬화 방식의 조합으로 구성됩니다.</p>
<ul>
<li><strong>어텐션 텐서 병렬화 (TPA)</strong>: KV 헤드를 분산시킵니다. <code>TPA</code>는 KV 헤드 수(K)보다 클 수 없습니다. 여기서는 **<code>TPA = 8</code>**로 설정하여 8개의 KV 헤드를 8개의 GPU 그룹에 각각 할당합니다.</li>
<li><strong>KV 병렬화 (KVP)</strong>: KV 캐시의 시퀀스(길이)를 분산시킵니다. 전체 GPU 수 <code>N = TPA * KVP</code> 공식에 따라 <code>16 = 8 * KVP</code> 이므로, **<code>KVP = 2</code>**가 됩니다.</li>
</ul>
<p>이 구성을 통해 16개 GPU는 **8x2 형태의 논리적 그리드(Grid)**를 형성합니다.</p>
<ul>
<li>
<p><strong>KV 캐시 분할 방식</strong>:</p>
<ul>
<li><strong>헤드 분할 (TPA=8)</strong>: 8개의 KV 헤드가 8개의 TP Rank에 걸쳐 1개씩 분할됩니다.</li>
<li><strong>시퀀스 분할 (KVP=2)</strong>: 수백만 토큰 길이의 전체 KV 캐시 시퀀스가 2개의 KVP Rank에 걸쳐 <strong>절반으로 나뉩니다</strong>. 예를 들어 100만 토큰 컨텍스트라면, 50만 토큰씩 두 그룹으로 잘립니다.</li>
<li><strong>결과</strong>: GPU 0<del>7번은 KV 캐시의 **첫 번째 절반(1</del>50만 토큰)**에 대한 8개 헤드를 각각 담당하고, GPU 8<del>15번은 **두 번째 절반(50만</del>100만 토큰)**에 대한 8개 헤드를 각각 담당하게 됩니다.</li>
</ul>
</li>
<li>
<p><strong>입력 토큰(Query) 처리</strong>:</p>
<ul>
<li>새롭게 생성될 토큰의 입력(Query)은 <strong>16개 모든 GPU에 동일하게 복제/브로드캐스트</strong>됩니다.</li>
</ul>
</li>
</ul>
<h4 id="연산-및-통신-과정-"><strong>연산 및 통신 과정 ⚡</strong></h4>
<ol>
<li><strong>독립 연산</strong>: 각 16개 GPU는 입력받은 Query와 자신이 담당하는 KV 캐시의 일부(예: GPU 0은 첫 50만 토큰의 1번 헤드)를 사용하여 부분적인 어텐션 스코어를 계산합니다.</li>
<li><strong>All-to-All 통신</strong>: 시퀀스를 나눠 가졌으므로 완전한 어텐션 결과를 위해 <strong>KVP Rank 간 데이터 교환</strong>이 필요합니다. TPA=8 그룹 내에서, KVP Rank 0(GPU 0<del>7)과 KVP Rank 1(GPU 8</del>15)은 서로의 부분 어텐션 결과를 교환합니다.</li>
<li><strong>결과 통합</strong>: 각 GPU는 통신으로 받은 부분 결과와 자체 계산 결과를 합쳐서 최종 어텐션 출력을 완성합니다.</li>
</ol>
<p>이 방식을 통해 거대한 KV 캐시가 16개 GPU에 완벽하게 분산되어 메모리 병목 현상이 크게 완화되고, KV 캐시 복제 문제도 발생하지 않습니다.</p>
<hr>
<h3 id="-2단계-ffnfeed-forward-network-연산"><strong>⚙️ 2단계: FFN(Feed-Forward Network) 연산</strong></h3>
<p>어텐션 연산이 끝나면, 16개 GPU는 즉시 FFN 연산을 위해 재구성됩니다.</p>
<h4 id="gpu-구성-및-데이터-분할-자르기--1"><strong>GPU 구성 및 데이터 분할 (자르기) ✂️</strong></h4>
<ul>
<li>
<p><strong>FFN 텐서 병렬화 (TPF)</strong>: 1단계의 8x2 그리드 구성은 사라집니다. 이제 <strong>16개 GPU 전체가 하나의 거대한 텐서 병렬화 그룹</strong>으로 동작합니다. 즉, **<code>TPF = 16</code>**이 됩니다.</p>
</li>
<li>
<p><strong>FFN 가중치 분할 방식</strong>:</p>
<ul>
<li>Llama 3 70B의 거대한 FFN 계층 가중치 행렬(예: $W_{FC1}, W_{FC2}$)들이 <strong>16개로 분할</strong>됩니다.</li>
<li>예를 들어, 첫 번째 FFN 행렬은 <strong>열(column)을 기준으로 16개로 잘리고</strong>, 두 번째 FFN 행렬은 <strong>행(row)을 기준으로 16개로 잘립니다</strong>.</li>
<li>각 GPU는 전체 FFN 가중치의 <strong>1/16</strong>만을 보유하게 됩니다.</li>
</ul>
</li>
</ul>
<h4 id="연산-및-통신-과정--1"><strong>연산 및 통신 과정 ⚡</strong></h4>
<ol>
<li><strong>분산 연산</strong>: 1단계에서 나온 어텐션 출력값이 FFN의 입력으로 들어갑니다. 각 GPU는 자신이 가진 1/16의 가중치 조각을 사용하여 행렬 곱셈을 수행하고, 부분적인 FFN 연산 결과를 생성합니다.</li>
<li><strong>All-Reduce 통신</strong>: <strong>16개 GPU 전체가 참여하는 All-Reduce 통신</strong>이 발생합니다. 각 GPU가 계산한 16개의 부분 결과들이 이 통신을 통해 모두 합산됩니다.</li>
<li><strong>최종 결과</strong>: All-Reduce가 끝나면, 해당 레이어의 최종 출력값이 완성되고, 이 값은 다음 트랜스포머 레이어의 입력으로 전달됩니다.</li>
</ol>
<p>이처럼 Helix Parallelism은 각 연산 단계의 특성에 맞춰 GPU의 역할과 데이터 분할 방식을 동적으로 변경함으로써, 16개의 GPU 자원을 한순간도 낭비 없이 최대한 효율적으로 활용하여 빠른 디코딩 속도를 달성합니다.</p>
<h1 id="구현-및-자원">구현 및 자원</h1>
<div
  class="code-block-container border-border bg-card my-6 overflow-hidden rounded-xl border shadow-sm transition-all duration-200 ease-out hover:-translate-y-0.5 hover:shadow-md">
  
  <div
    class="code-block-header bg-muted/30 border-border flex items-center justify-between border-b px-4 py-3">
    
    <div class="flex items-center gap-2">
      <div class="text-muted-foreground flex-shrink-0">
        
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4" />
</svg>
      </div>
      <span class="text-muted-foreground text-sm font-medium">
        PLAINTEXT
      </span>
    </div>

    
    <div class="flex items-center gap-2">
      <button
          class="collapse-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
          data-code-id="code-12"
          data-default-state="expanded"
          data-collapsed="false"
          data-auto-collapse-lines="30"
          data-auto-collapse-height="400"
          data-collapsed-height="120"
          title="접기"
          aria-label="접기">
          <span class="collapse-icon">
            
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path fill="currentColor" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z"/></svg>
          </span>
          <span class="collapse-text hidden sm:inline"
            >접기</span
          >
        </button>
      <button
        class="copy-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
        data-code-id="code-12"
        title="복사"
        aria-label="복사">
        <span class="copy-icon">
          
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
</svg>
        </span>
        <span class="copy-text hidden sm:inline"
          >복사</span
        >
      </button>
    </div>
  </div>

  
  <div class="code-block-content relative" id="code-12">
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">&#34;핵심 소프트웨어 의존성(예: CUDA, MPI, 특정 라이브러리)은 무엇인가? 학습 및 추론 중 예상되는 메모리 점유량(GPU의 경우 VRAM, CPU의 경우 RAM)은 얼마인가? 명시된 하드웨어에서의 처리량(throughput)은 얼마인가(예: images/sec, tokens/sec)? 총 연산 비용(예: 총 FLOPs 또는 Petaflop-days)에 대한 상세한 내역을 제공해 줘.&#34;</span></span></code></pre></div>
    
    <div
      class="collapse-overlay to-card/90 pointer-events-none absolute inset-0 bg-gradient-to-b from-transparent via-transparent opacity-0 transition-opacity duration-300">
      <div
        class="text-muted-foreground bg-card/80 border-border/50 hover:bg-primary/10 hover:text-primary hover:border-primary/30 absolute bottom-4 left-1/2 -translate-x-1/2 cursor-pointer rounded-full border px-3 py-1.5 text-xs backdrop-blur-sm transition-all duration-200">
        클릭하여 더 보기
      </div>
    </div>
  </div>
</div>


<script>
(function() {
  const codeId = 'code-12';
  const copyBtn = document.querySelector('.copy-code-btn[data-code-id="' + codeId + '"]');
  const collapseBtn = document.querySelector('.collapse-code-btn[data-code-id="' + codeId + '"]');
  const codeContainer = document.getElementById(codeId);

  if (!codeContainer) return;

  
  if (copyBtn) {
    const copyIcon = copyBtn.querySelector('.copy-icon');
    const copyText = copyBtn.querySelector('.copy-text');

    copyBtn.addEventListener('click', async function() {
      try {
        
        let codeText = '';

        
        const codeTableCell = codeContainer.querySelector('.lntd:last-child code');
        if (codeTableCell) {
          codeText = codeTableCell.textContent || codeTableCell.innerText;
        } else {
          
          const codeElement = codeContainer.querySelector('code');
          if (codeElement) {
            
            const hasInlineLineNumbers = codeElement.querySelector('.ln');
            if (hasInlineLineNumbers) {
              
              const codeLines = codeElement.querySelectorAll('.cl');
              if (codeLines.length > 0) {
                codeText = Array.from(codeLines)
                  .map(line => {
                    const text = line.textContent || line.innerText;
                    
                    return text.replace(/\n+$/, '');
                  })
                  .join('\n')
                  .replace(/\n+$/, ''); 
              } else {
                
                const allText = codeElement.textContent || codeElement.innerText;
                codeText = allText.replace(/^\d+/gm, '').replace(/^\s+/gm, '');
              }
            } else {
              
              codeText = codeElement.textContent || codeElement.innerText;
            }
          } else {
            
            codeText = codeContainer.textContent || codeContainer.innerText;
          }
        }

        
        codeText = codeText.trim();

        
        await navigator.clipboard.writeText(codeText);

        
        copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M5 13l4 4L19 7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (copyText) {
          copyText.textContent = '복사됨';
        }
        copyBtn.classList.add('text-green-600');

        
        setTimeout(() => {
          copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z\u0022 \/\u003e\n\u003c\/svg\u003e`;
          if (copyText) {
            copyText.textContent = '복사';
          }
          copyBtn.classList.remove('text-green-600');
        }, 2000);

      } catch (err) {
        console.error('复制失败:', err);

        
        const range = document.createRange();
        const codeElement = codeContainer.querySelector('code') || codeContainer;
        range.selectNodeContents(codeElement);
        const selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);

        
        if (copyText) {
          copyText.textContent = '선택됨';
        }

        setTimeout(() => {
          if (copyText) {
            copyText.textContent = '복사';
          }
          selection.removeAllRanges();
        }, 2000);
      }
    });
  }

  
  if (collapseBtn) {
    const collapseIcon = collapseBtn.querySelector('.collapse-icon');
    const collapseText = collapseBtn.querySelector('.collapse-text');
    const collapseOverlay = codeContainer.querySelector('.collapse-overlay');

    
    let codeElement = codeContainer.querySelector('pre.chroma');
    if (!codeElement) {
      codeElement = codeContainer.querySelector('pre');
    }

    const defaultState = collapseBtn.dataset.defaultState || 'expanded';
    const isCollapsedAttr = collapseBtn.dataset.collapsed === 'true';
    const autoCollapseLines = parseInt(collapseBtn.dataset.autoCollapseLines) || 30;
    const autoCollapseHeight = parseInt(collapseBtn.dataset.autoCollapseHeight) || 400;
    const collapsedHeight = parseInt(collapseBtn.dataset.collapsedHeight) || 120;

    let isCollapsed = false;

    
    function initCollapse() {
      
      const shouldCollapse = isCollapsedAttr ||
                           defaultState === 'collapsed' ||
                           shouldAutoCollapse();

      if (shouldCollapse) {
        setCollapsed(true, false); 
      }
    }

    function shouldAutoCollapse() {
      
      if (codeElement) {
        const lines = codeElement.querySelectorAll('.line, .cl');
        const height = codeElement.offsetHeight;
        return lines.length > autoCollapseLines || height > autoCollapseHeight;
      }

      
      const containerHeight = codeContainer.offsetHeight;
      if (containerHeight > autoCollapseHeight) {
        return true;
      }

      
      const textContent = codeContainer.textContent || codeContainer.innerText || '';
      const estimatedLines = textContent.split('\n').length;
      return estimatedLines > autoCollapseLines;
    }

    function setCollapsed(collapsed, animate = true) {
      if (!collapseOverlay) return;

      isCollapsed = collapsed;

      if (collapsed) {
        
        codeContainer.style.maxHeight = collapsedHeight + 'px';
        codeContainer.style.overflow = 'hidden';
        collapseOverlay.style.opacity = '1';
        collapseOverlay.style.pointerEvents = 'auto';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M19 9l-7 7-7-7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '펼치기';
        }
        collapseBtn.title = '펼치기';

      } else {
        
        codeContainer.style.maxHeight = '';
        codeContainer.style.overflow = '';
        collapseOverlay.style.opacity = '0';
        collapseOverlay.style.pointerEvents = 'none';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath fill=\u0022currentColor\u0022 d=\u0022M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z\u0022\/\u003e\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '접기';
        }
        collapseBtn.title = '접기';
      }

      
      if (animate) {
        codeContainer.style.transition = 'max-height 0.3s ease-out';
        setTimeout(() => {
          codeContainer.style.transition = '';
        }, 300);
      }
    }

    function toggleCollapse() {
      setCollapsed(!isCollapsed, true);
    }

    
    collapseBtn.addEventListener('click', toggleCollapse);

    
    if (collapseOverlay) {
      collapseOverlay.addEventListener('click', () => {
        if (isCollapsed) {
          setCollapsed(false, true);
        }
      });
    }

    
    initCollapse();
  }
})();
</script>
<p><strong>요점만 먼저</strong>
*PyTorch 2.3 + CUDA 12.4 / NCCL 2.20 환경에서 Llama-3 70B를 Helix(8-way TP × 4-way KVP = 32 GPU)로 디코딩할 경우, <strong>GPU당 VRAM 요구량 ≈ 6 GB(가중치 ≈ 4.4 GB + KV 캐시 ≈ 0.3 GB + 여유 ≈ 1 GB)</strong>, 클러스터-총 추론 처리량은 <strong>≈ 9.6 × 10⁴ tok s⁻¹</strong>(Helix 미적용 대비 ≈ 4 배)이다. 전체 학습은 6.3 × 10²⁴ FLOPs(≈ 7.3 × 10⁴ PF-day)가 소요되며, 64 × H100 FP8 기준 학습 스루풋은 <strong>9.5 × 10⁴ tok s⁻¹</strong>에서 32 GPU로 선형 축소 시 ≈ 4.8 × 10⁴ tok s⁻¹ 수준이다.(<a href="https://llm-tracker.info/DeepSeek-V3-Architecture?utm_source=chatgpt.com" title="DeepSeek-V3 Architecture - llm-tracker">llm-tracker.info</a>, <a href="https://github.com/huggingface/blog/issues/2345?utm_source=chatgpt.com" title="Llama3.1 inference memory requirements · Issue #2345 - GitHub">github.com</a>, <a href="https://www.perplexity.ai/hub/blog/turbocharging-llama-2-70b-with-nvidia-h100?utm_source=chatgpt.com" title="Turbocharging Llama 2 70B with NVIDIA H100 - Perplexity">perplexity.ai</a>, <a href="https://catalog.ngc.nvidia.com/orgs/nvidia/teams/dgxc-benchmarking/resources/llama31-70b-dgxc-benchmarking-a?utm_source=chatgpt.com" title="Llama 3.1 70B 24.11.1 (DGXC Benchmarking) - NVIDIA NGC">catalog.ngc.nvidia.com</a>, <a href="https://www.factorialfunds.com/blog/thoughts-on-llama-3?utm_source=chatgpt.com" title="Thoughts on Llama 3 - Factorial Funds">factorialfunds.com</a>)</p>
<hr>
<h2 id="1-핵심-소프트웨어런타임-스택">1. 핵심 소프트웨어/런타임 스택</h2>
<table>
  <thead>
      <tr>
          <th>계층</th>
          <th>권장 버전·라이브러리</th>
          <th>비고</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>CUDA / 드라이버</td>
          <td><strong>CUDA 12.4+</strong>, NVIDIA 535.xx</td>
          <td>FP4/FP8 매트릭스 코어 지원</td>
      </tr>
      <tr>
          <td>통신</td>
          <td><strong>NCCL 2.20+</strong> (P2P + NVLink All-to-All), 옵션 MPI-4.1</td>
          <td>Helix HOP-B의 비차단 All-to-All</td>
      </tr>
      <tr>
          <td>DL 프레임워크</td>
          <td><strong>PyTorch 2.3 LTS</strong></td>
          <td>FlashAttention v3 커스텀 op 내장</td>
      </tr>
      <tr>
          <td>Helix 커널</td>
          <td><code>helix_kv_all2all.cu</code> (LSE 재조합)</td>
          <td>Triton 2.2로도 JIT 가능</td>
      </tr>
      <tr>
          <td>기타</td>
          <td>FlashAttention-2.4, xFormers 0.0.47, Triton 2.2, CuBLAS-Lt</td>
          <td></td>
      </tr>
  </tbody>
</table>
<hr>
<h2 id="2-메모리-프로파일-fp4-추론bf16-학습">2. 메모리 프로파일 (FP4 추론·BF16 학습)</h2>
<table>
  <thead>
      <tr>
          <th>항목</th>
          <th>계산식 (70 B params, 64 Q / 8 KV heads)</th>
          <th><strong>추론 (Helix 32 GPU)</strong></th>
          <th><strong>학습 (Adam, 32 GPU)</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>모델 가중치</td>
          <td>70 B × 2 B / 32</td>
          <td><strong>4.4 GB</strong></td>
          <td>4.4 GB</td>
      </tr>
      <tr>
          <td>옵티마이저 상태</td>
          <td>—</td>
          <td>—</td>
          <td><strong>70 B × 6 B / 32 ≈ 13 GB</strong></td>
      </tr>
      <tr>
          <td>활성화/미세 배치</td>
          <td>경험적 ≈ 1.5 GB</td>
          <td>1.5 GB</td>
          <td><strong>&gt; 10 GB</strong> (activation + recompute)</td>
      </tr>
      <tr>
          <td>KV 캐시</td>
          <td>(128 k tok) → 39 GB/seq (FP16) → 9.8 GB(FP4) (1/32 저장)(<a href="https://github.com/huggingface/blog/issues/2345?utm_source=chatgpt.com" title="Llama3.1 inference memory requirements · Issue #2345 - GitHub">github.com</a>)</td>
          <td><strong>0.31 GB</strong></td>
          <td>—</td>
      </tr>
      <tr>
          <td><strong>총 VRAM / GPU</strong></td>
          <td></td>
          <td><strong>≈ 6 GB</strong></td>
          <td><strong>≈ 28 GB</strong></td>
      </tr>
  </tbody>
</table>

  <blockquote
    class="border-primary bg-muted/30 hover:bg-muted/40 my-6 rounded-r-lg border-l-4 py-4 pr-4 pl-6 italic transition-all duration-200 ease-out hover:translate-x-1">
    <div class="prose prose-sm max-w-none">
      <p>Helix의 8 TP × 4 KVP 분할 덕분에 <strong>KV 캐시 복제량을 32 분의 1</strong>로 줄여 대역·메모리 양쪽 부담을 크게 경감한다.</p>
    </div>
  </blockquote>

<hr>
<h2 id="3-처리량--지연">3. 처리량 &amp; 지연</h2>
<table>
  <thead>
      <tr>
          <th>시나리오</th>
          <th>구성</th>
          <th>TTL / tok (↓)</th>
          <th>tok s⁻¹ GPU⁻¹</th>
          <th>tok s⁻¹ (32 GPU)</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>추론·TP 8</strong> (기준)</td>
          <td>8 GPU, TP = 8</td>
          <td>11 ms</td>
          <td>90</td>
          <td>~2.9 k</td>
      </tr>
      <tr>
          <td><strong>Helix (8 TP × 4 KVP)</strong></td>
          <td>32 GPU</td>
          <td><strong>9.7 ms</strong> (1.13 × ↓)</td>
          <td><strong>360</strong> (≈ 4 ×↑)</td>
          <td><strong>~9.6 × 10⁴</strong></td>
      </tr>
      <tr>
          <td><strong>학습 64 GPU</strong></td>
          <td>NGC FP8 recipe (TP-4·PP-4)</td>
          <td>—</td>
          <td>1.5 k</td>
          <td><strong>9.5 × 10⁴</strong> (<a href="https://catalog.ngc.nvidia.com/orgs/nvidia/teams/dgxc-benchmarking/resources/llama31-70b-dgxc-benchmarking-a?utm_source=chatgpt.com" title="Llama 3.1 70B 24.11.1 (DGXC Benchmarking) - NVIDIA NGC">catalog.ngc.nvidia.com</a>)</td>
      </tr>
      <tr>
          <td><strong>학습 32 GPU (추정)</strong></td>
          <td>선형 스케일</td>
          <td>—</td>
          <td>0.75 k</td>
          <td><strong>4.8 × 10⁴</strong></td>
      </tr>
  </tbody>
</table>
<p><em>추론 수치는 H100 FP8 실측(767 tok s⁻¹/ GPU) 대비 Helix 4 × 개선폭 가정</em>(<a href="https://www.perplexity.ai/hub/blog/turbocharging-llama-2-70b-with-nvidia-h100?utm_source=chatgpt.com" title="Turbocharging Llama 2 70B with NVIDIA H100 - Perplexity">perplexity.ai</a>).</p>
<hr>
<h2 id="4-연산량--비용">4. 연산량 &amp; 비용</h2>
<table>
  <thead>
      <tr>
          <th>항목</th>
          <th>식</th>
          <th>값</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>학습 FLOPs</td>
          <td><strong>6 · N · D</strong> (N = 70 B, D = 15 T 토큰)(<a href="https://www.factorialfunds.com/blog/thoughts-on-llama-3?utm_source=chatgpt.com" title="Thoughts on Llama 3 - Factorial Funds">factorialfunds.com</a>)</td>
          <td><strong>6.3 × 10²⁴ FLOPs</strong></td>
      </tr>
      <tr>
          <td>PF-day 환산</td>
          <td>FLOPs / (10¹⁵·86 400)</td>
          <td><strong>≈ 7.3 × 10⁴ PF-day</strong></td>
      </tr>
      <tr>
          <td>전력 예상</td>
          <td>32 × H100 (≈ 700 W) · 학습 기간 (162→81 days @64→32GPU)</td>
          <td><strong>≈ 43 MWh</strong></td>
      </tr>
  </tbody>
</table>
<hr>
<h3 id="정리-포인트">정리 포인트</h3>
<ol>
<li><strong>Helix 2-D 샤딩</strong> 덕분에 32 × H100만으로도 Llama-3 70B 128 k-ctx 디코딩이 <strong>VRAM 6 GB 수준</strong>으로 실현된다.</li>
<li>추론 처리량은 동일 지연 예산에서 <strong>약 4 × 증가</strong>하며, KV 캐시 트래픽이 병목인 환경일수록 Helix 효과가 커진다.</li>
<li>학습은 여전히 거대-스케일(≈ 7 × 10⁴ PF-day) 과제를 요구하므로, <strong>FP8·ZeRO-3·NVLink NVSwitch</strong> 등 병렬화 최적화가 필수이다.</li>
</ol>
<h1 id="평가-및-지표">평가 및 지표</h1>
<div
  class="code-block-container border-border bg-card my-6 overflow-hidden rounded-xl border shadow-sm transition-all duration-200 ease-out hover:-translate-y-0.5 hover:shadow-md">
  
  <div
    class="code-block-header bg-muted/30 border-border flex items-center justify-between border-b px-4 py-3">
    
    <div class="flex items-center gap-2">
      <div class="text-muted-foreground flex-shrink-0">
        
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4" />
</svg>
      </div>
      <span class="text-muted-foreground text-sm font-medium">
        PLAINTEXT
      </span>
    </div>

    
    <div class="flex items-center gap-2">
      <button
          class="collapse-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
          data-code-id="code-13"
          data-default-state="expanded"
          data-collapsed="false"
          data-auto-collapse-lines="30"
          data-auto-collapse-height="400"
          data-collapsed-height="120"
          title="접기"
          aria-label="접기">
          <span class="collapse-icon">
            
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path fill="currentColor" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z"/></svg>
          </span>
          <span class="collapse-text hidden sm:inline"
            >접기</span
          >
        </button>
      <button
        class="copy-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
        data-code-id="code-13"
        title="복사"
        aria-label="복사">
        <span class="copy-icon">
          
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
</svg>
        </span>
        <span class="copy-text hidden sm:inline"
          >복사</span
        >
      </button>
    </div>
  </div>

  
  <div class="code-block-content relative" id="code-13">
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">&#34;평가를 위한 주요 지표는 무엇인가: 지연 시간(latency), 처리량(throughput), 전력 소비, 또는 비용 대비 성능? 시스템은 더 많은 데이터, 사용자, 또는 컴퓨팅 노드에 따라 어떻게 확장되는가?&#34;</span></span></code></pre></div>
    
    <div
      class="collapse-overlay to-card/90 pointer-events-none absolute inset-0 bg-gradient-to-b from-transparent via-transparent opacity-0 transition-opacity duration-300">
      <div
        class="text-muted-foreground bg-card/80 border-border/50 hover:bg-primary/10 hover:text-primary hover:border-primary/30 absolute bottom-4 left-1/2 -translate-x-1/2 cursor-pointer rounded-full border px-3 py-1.5 text-xs backdrop-blur-sm transition-all duration-200">
        클릭하여 더 보기
      </div>
    </div>
  </div>
</div>


<script>
(function() {
  const codeId = 'code-13';
  const copyBtn = document.querySelector('.copy-code-btn[data-code-id="' + codeId + '"]');
  const collapseBtn = document.querySelector('.collapse-code-btn[data-code-id="' + codeId + '"]');
  const codeContainer = document.getElementById(codeId);

  if (!codeContainer) return;

  
  if (copyBtn) {
    const copyIcon = copyBtn.querySelector('.copy-icon');
    const copyText = copyBtn.querySelector('.copy-text');

    copyBtn.addEventListener('click', async function() {
      try {
        
        let codeText = '';

        
        const codeTableCell = codeContainer.querySelector('.lntd:last-child code');
        if (codeTableCell) {
          codeText = codeTableCell.textContent || codeTableCell.innerText;
        } else {
          
          const codeElement = codeContainer.querySelector('code');
          if (codeElement) {
            
            const hasInlineLineNumbers = codeElement.querySelector('.ln');
            if (hasInlineLineNumbers) {
              
              const codeLines = codeElement.querySelectorAll('.cl');
              if (codeLines.length > 0) {
                codeText = Array.from(codeLines)
                  .map(line => {
                    const text = line.textContent || line.innerText;
                    
                    return text.replace(/\n+$/, '');
                  })
                  .join('\n')
                  .replace(/\n+$/, ''); 
              } else {
                
                const allText = codeElement.textContent || codeElement.innerText;
                codeText = allText.replace(/^\d+/gm, '').replace(/^\s+/gm, '');
              }
            } else {
              
              codeText = codeElement.textContent || codeElement.innerText;
            }
          } else {
            
            codeText = codeContainer.textContent || codeContainer.innerText;
          }
        }

        
        codeText = codeText.trim();

        
        await navigator.clipboard.writeText(codeText);

        
        copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M5 13l4 4L19 7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (copyText) {
          copyText.textContent = '복사됨';
        }
        copyBtn.classList.add('text-green-600');

        
        setTimeout(() => {
          copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z\u0022 \/\u003e\n\u003c\/svg\u003e`;
          if (copyText) {
            copyText.textContent = '복사';
          }
          copyBtn.classList.remove('text-green-600');
        }, 2000);

      } catch (err) {
        console.error('复制失败:', err);

        
        const range = document.createRange();
        const codeElement = codeContainer.querySelector('code') || codeContainer;
        range.selectNodeContents(codeElement);
        const selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);

        
        if (copyText) {
          copyText.textContent = '선택됨';
        }

        setTimeout(() => {
          if (copyText) {
            copyText.textContent = '복사';
          }
          selection.removeAllRanges();
        }, 2000);
      }
    });
  }

  
  if (collapseBtn) {
    const collapseIcon = collapseBtn.querySelector('.collapse-icon');
    const collapseText = collapseBtn.querySelector('.collapse-text');
    const collapseOverlay = codeContainer.querySelector('.collapse-overlay');

    
    let codeElement = codeContainer.querySelector('pre.chroma');
    if (!codeElement) {
      codeElement = codeContainer.querySelector('pre');
    }

    const defaultState = collapseBtn.dataset.defaultState || 'expanded';
    const isCollapsedAttr = collapseBtn.dataset.collapsed === 'true';
    const autoCollapseLines = parseInt(collapseBtn.dataset.autoCollapseLines) || 30;
    const autoCollapseHeight = parseInt(collapseBtn.dataset.autoCollapseHeight) || 400;
    const collapsedHeight = parseInt(collapseBtn.dataset.collapsedHeight) || 120;

    let isCollapsed = false;

    
    function initCollapse() {
      
      const shouldCollapse = isCollapsedAttr ||
                           defaultState === 'collapsed' ||
                           shouldAutoCollapse();

      if (shouldCollapse) {
        setCollapsed(true, false); 
      }
    }

    function shouldAutoCollapse() {
      
      if (codeElement) {
        const lines = codeElement.querySelectorAll('.line, .cl');
        const height = codeElement.offsetHeight;
        return lines.length > autoCollapseLines || height > autoCollapseHeight;
      }

      
      const containerHeight = codeContainer.offsetHeight;
      if (containerHeight > autoCollapseHeight) {
        return true;
      }

      
      const textContent = codeContainer.textContent || codeContainer.innerText || '';
      const estimatedLines = textContent.split('\n').length;
      return estimatedLines > autoCollapseLines;
    }

    function setCollapsed(collapsed, animate = true) {
      if (!collapseOverlay) return;

      isCollapsed = collapsed;

      if (collapsed) {
        
        codeContainer.style.maxHeight = collapsedHeight + 'px';
        codeContainer.style.overflow = 'hidden';
        collapseOverlay.style.opacity = '1';
        collapseOverlay.style.pointerEvents = 'auto';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M19 9l-7 7-7-7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '펼치기';
        }
        collapseBtn.title = '펼치기';

      } else {
        
        codeContainer.style.maxHeight = '';
        codeContainer.style.overflow = '';
        collapseOverlay.style.opacity = '0';
        collapseOverlay.style.pointerEvents = 'none';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath fill=\u0022currentColor\u0022 d=\u0022M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z\u0022\/\u003e\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '접기';
        }
        collapseBtn.title = '접기';
      }

      
      if (animate) {
        codeContainer.style.transition = 'max-height 0.3s ease-out';
        setTimeout(() => {
          codeContainer.style.transition = '';
        }, 300);
      }
    }

    function toggleCollapse() {
      setCollapsed(!isCollapsed, true);
    }

    
    collapseBtn.addEventListener('click', toggleCollapse);

    
    if (collapseOverlay) {
      collapseOverlay.addEventListener('click', () => {
        if (isCollapsed) {
          setCollapsed(false, true);
        }
      });
    }

    
    initCollapse();
  }
})();
</script>
<h3 id="결론-압축-요약">결론 (압축 요약)</h3>
<p>Helix 평가는 **토큰-간 지연 (TTL), GPU-당 토큰 처리량, 동시 배치 규모, J · token⁻¹(전력 효율), 원 · 10⁶ tokens⁻¹(비용 효율)**을 핵심 지표로 삼는다.
이 지표들은 <strong>KV 길이 <em>S</em>·배치 <em>B</em>·GPU 수 <em>G</em> 변화에 따라 서로 다른 법칙으로 스케일</strong>하며, Helix는 <em>S</em>와 <em>KVP</em>·<em>TP</em>에 의해 선형 또는 상수 규모로 확장되어 기존 TP/PP보다 우월한 Pareto 곡선을 형성한다.</p>
<hr>
<h2 id="1--주요-평가-지표-정의--측정-단위">1 | 주요 평가 지표 정의 &amp; 측정 단위</h2>
<table>
  <thead>
      <tr>
          <th>지표</th>
          <th>정의</th>
          <th>측정 단위</th>
          <th>Helix-관련 특징</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>TTL</strong><br>(Token-to-Token Latency)</td>
          <td>새 토큰 생성 완료까지의 시간</td>
          <td>ms · token⁻¹</td>
          <td>Helix 32 GPU에서 Llama-3 70B <strong>9.7 ms</strong>(기존 11 ms) → <strong>1.13 × ↓</strong></td>
      </tr>
      <tr>
          <td><strong>Throughput/GPU</strong></td>
          <td>1 GPU가 생성하는 토큰률</td>
          <td>tokens · s⁻¹ · GPU⁻¹</td>
          <td>Helix = 360 tok s⁻¹ vs TP8 = 90 tok s⁻¹ → <strong>4 × ↑</strong></td>
      </tr>
      <tr>
          <td><strong>Batch Scalability</strong></td>
          <td>주어진 TTL 한도에서 유지 가능한 동시 시퀀스 수</td>
          <td>배치 수</td>
          <td>DeepSeek-R1 기준 <strong>32 × ↑</strong>, Llama-405B <strong>4 × ↑</strong></td>
      </tr>
      <tr>
          <td><strong>Energy Efficiency</strong></td>
          <td>전력 소모/생성 토큰</td>
          <td>J · token⁻¹</td>
          <td>KV 복제 제거 + 통신 은닉 → GPU 유휴 ↓, <strong>~30 % J · token⁻¹ ↓</strong> (모델·온도·S에 따라)</td>
      </tr>
      <tr>
          <td><strong>Cost Efficiency</strong></td>
          <td>계산/전력 비용 ÷ 생성 토큰</td>
          <td>원 · 10⁶ tokens⁻¹</td>
          <td>처리량 4 × 증가, 전력 1.3 × 증가 가정 → <strong>비용/토큰 ≈ 0.33 ×</strong></td>
      </tr>
  </tbody>
</table>

  <blockquote
    class="border-primary bg-muted/30 hover:bg-muted/40 my-6 rounded-r-lg border-l-4 py-4 pr-4 pl-6 italic transition-all duration-200 ease-out hover:translate-x-1">
    <div class="prose prose-sm max-w-none">
      <p><strong>관계식</strong> | 인터랙티비 = 1 / TTL; System TPS = Throughput/GPU × G; J · token⁻¹ ∝ (PGPU × TTL) / tokens.</p>
    </div>
  </blockquote>

<hr>
<h2 id="2--스케일링-법칙-helix-vs-전통-tppp">2 | 스케일링 법칙 (Helix vs 전통 TP/PP)</h2>
<h3 id="2-1-컨텍스트-길이-s-증가">2-1 컨텍스트 길이 <em>S</em> 증가</h3>
<p><em>통신량</em> ∝ <em>B · H</em> (Helix) <strong>≠ <em>S</em></strong> →
KV 캐시 읽기 ∝ <em>S / KVP</em>.
따라서 <strong>KVP를 S에 맞춰 확장</strong>하면 DRAM 대역·TTL이 거의 선형 유지, 기존 TP(전 KV 복제)보다 <strong>O(S)</strong>→**O(S / KVP)**로 완화.</p>
<h3 id="2-2-동시-사용자-b-증가">2-2 동시 사용자 <em>B</em> 증가</h3>
<p>TTL은 통신 오버랩(HOP-B) 덕분에 <strong>B가 메모리 한계에 닿을 때까지 완만 증가</strong>.
Throughput ≈ B / TTL → Helix의 <strong>Batch cap</strong>이 4–32 × 더 크므로 동일 TTL 예산 내 동시 사용자 수 ↑.</p>
<h3 id="2-3-gpu-수-g-확장">2-3 GPU 수 <em>G</em> 확장</h3>
<p>Helix는 2-D 그리드(<strong>TP × KVP</strong>)로 확장:</p>
<p>$$
G = \text{TP} \times \text{KVP},\quad<br>
\text{KV duplication} = \frac{\text{TP}}{K},\quad<br>
\text{FFN 로드/ GPU} \propto \frac{1}{\text{TP}}
$$</p>
<ul>
<li><strong>G ≤ K</strong>: KV 중복이 없으므로 Helix 이득 ↓, TP만으로 충분.</li>
<li><strong>G ≫ K</strong>: Helix가 KV 중복 0 % + FFN 분산 모두 확보 → <strong>TTL ↘, Throughput ↗</strong>.</li>
<li><strong>다중 노드(PCIe/InfiniBand)</strong>: All-to-All lat ↑; HOP-B 은닉률 ↓ → 이득폭이 통신-대역에 선형 의존. (후속 연구 과제)</li>
</ul>
<hr>
<h2 id="3--전력비용-지표-계산-예시-32--h100-700-wgpu">3 | 전력·비용 지표 계산 예시 (32 × H100, 700 W/GPU)</h2>
<table>
  <thead>
      <tr>
          <th>항목</th>
          <th>Helix</th>
          <th>TP8</th>
          <th>비고</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>시스템 전력</td>
          <td>22 kW</td>
          <td>5.6 kW</td>
          <td>GPU 수 차이</td>
      </tr>
      <tr>
          <td>TPS (system)</td>
          <td>9.6 × 10⁴</td>
          <td>2.9 × 10³</td>
          <td>4 × tok s⁻¹ · GPU⁻¹</td>
      </tr>
      <tr>
          <td><strong>J · token⁻¹</strong></td>
          <td>2.3 J</td>
          <td>6.8 J</td>
          <td><strong>×0.34</strong></td>
      </tr>
      <tr>
          <td><strong>원 · 10⁶ tok⁻¹</strong>*</td>
          <td>78 ₩</td>
          <td>233 ₩</td>
          <td>60 ₩ kWh, 1 k tok = 1 s</td>
      </tr>
  </tbody>
</table>
<p>*전력만 포함한 단순 환산·예시.</p>
<hr>
<h2 id="4--핵심-시사점">4 | 핵심 시사점</h2>
<ol>
<li><strong>지연 (TTL)</strong>·<strong>처리량</strong>·<strong>전력/비용</strong> 세 지표가 Pareto 관계. Helix는 KV·FFN 이중 병목을 제거해 <strong>이 세 축을 동시 개선</strong>.</li>
<li>확장성은 **“TP &gt; K일 때 KV 중복이 폭증한다”**는 기존 TP의 약점을 KVP로 상수화하면서 확보된다.</li>
<li>다중 노드·희소 어텐션·저정밀 FP4/FP8 외삽 시 실제 이득폭은 <strong>통신 토폴로지·정밀도·SLA에 따라 재평가</strong>해야 한다—이는 저자·후속 연구가 제시한 핵심 오픈 문제이다.</li>
</ol>
</details>

  </article>

  
  
  <div class="post-license bg-muted/30 border-border mb-8 rounded-xl border p-6">
    <div class="flex items-start gap-4">
      <div
        class="bg-primary/10 flex h-12 w-12 flex-shrink-0 items-center justify-center rounded-lg">
        
  <svg class="h-6 w-6"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="라이선스"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m5.618-4.016A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.04A12.02 12.02 0 003 9c0 5.591 3.824 10.29 9 11.622 5.176-1.332 9-6.03 9-11.622 0-1.042-.133-2.052-.382-3.016z" />
</svg>
      </div>

      <div class="flex-1">
        <h3 class="text-foreground mb-2 text-lg font-semibold">
          라이선스
        </h3>

        <div class="text-muted-foreground space-y-2 text-sm">
          
          <p>
            <strong>저작자:</strong>
            류재훈
          </p>
          

          <p>
            <strong>링크:</strong>
            <a
              href="http://192.168.1.11:1314/posts/Helix-Parallelism-Rethinking-Sharding-Strategies-for-Interactive-Multi-Million-Token-LLM-Decoding/"
              class="text-primary hover:text-primary/80 transition-colors duration-200">
              http://192.168.1.11:1314/posts/Helix-Parallelism-Rethinking-Sharding-Strategies-for-Interactive-Multi-Million-Token-LLM-Decoding/
            </a>
          </p>

          <p>
            <strong>라이선스:</strong>
            <a
              href="https://creativecommons.org/licenses/by-nc-sa/4.0/"
              target="_blank"
              rel="noopener noreferrer"
              class="text-primary hover:text-primary/80 transition-colors duration-200">
              CC BY-NC-SA 4.0
            </a>
          </p>

          <p class="text-xs">
            이 저작물은 크리에이티브 커먼즈 저작자표시-비영리-동일조건변경허락 4.0 국제 라이선스에 따라 이용할 수 있습니다. 출처를 표시하고, 비영리 목적으로만 사용하며, 동일한 라이선스를 유지해야 합니다.
          </p>
        </div>
      </div>
    </div>
  </div>


  
  





  <nav
    class="post-navigation mb-12"
    aria-label="게시글 네비게이션">
    <div class="grid grid-cols-1 gap-4 md:grid-cols-2">
      
      <div class="nav-item">
        
          <a
            href="/posts/Inference-Time-Scaling-for-Generalist-Reward-Modeling/"
            class="group bg-card border-border hover:bg-primary/5 hover:border-primary/20 focus:ring-primary/20 flex min-h-[140px] flex-col justify-between rounded-xl border p-6 transition-all duration-300 ease-out hover:-translate-y-1 hover:scale-[1.02] hover:shadow-lg focus:ring-2 focus:outline-none">
            <div>
              <div class="mb-3 flex items-center gap-3">
                
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" />
</svg>
                <span class="text-muted-foreground text-sm font-medium">
                  이전
                </span>
              </div>

              <h3
                class="text-foreground group-hover:text-primary mb-3 line-clamp-2 text-lg leading-tight font-semibold transition-colors duration-200">
                Inference-Time Scaling for Generalist Reward Modeling
              </h3>
            </div>

            <div
              class="text-muted-foreground mt-auto flex items-center gap-2 text-xs">
              
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z" />
</svg>
              <time datetime="2025-07-08">
                07月08日
              </time>
            </div>
          </a>
        
      </div>

      
      <div class="nav-item">
        
          <a
            href="/posts/DeepSeek-Prover-V2-Advancing-Formal-Mathematical-Reasoning-via-Reinforcement-Learning-for-Subgoal-Decomposition/"
            class="group bg-card border-border hover:bg-primary/5 hover:border-primary/20 focus:ring-primary/20 flex min-h-[140px] flex-col justify-between rounded-xl border p-6 transition-all duration-300 ease-out hover:-translate-y-1 hover:scale-[1.02] hover:shadow-lg focus:ring-2 focus:outline-none">
            <div>
              <div class="mb-3 flex items-center justify-end gap-3">
                <span class="text-muted-foreground text-sm font-medium">
                  다음
                </span>
                
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
</svg>
              </div>

              <h3
                class="text-foreground group-hover:text-primary mb-3 line-clamp-2 text-right text-lg leading-tight font-semibold transition-colors duration-200">
                DeepSeek-Prover-V2: Advancing Formal Mathematical Reasoning via Reinforcement Learning for Subgoal Decomposition
              </h3>
            </div>

            <div
              class="text-muted-foreground mt-auto flex items-center justify-end gap-2 text-xs">
              <time datetime="2025-07-08">
                07月08日
              </time>
              
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z" />
</svg>
            </div>
          </a>
        
      </div>
    </div>
  </nav>




  
  







  <section class="related-posts mb-12">
    
    <div class="mb-6 flex items-center gap-3">
      
  <svg class="h-5 w-5"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.828 10.172a4 4 0 00-5.656 0l-4 4a4 4 0 105.656 5.656l1.102-1.101m-.758-4.899a4 4 0 005.656 0l4-4a4 4 0 00-5.656-5.656l-1.1 1.1" />
</svg>
      <h2 class="text-foreground text-2xl font-bold">
        관련 게시글
      </h2>
    </div>

    
    
    
    
    
      
    

    <div class="grid grid-cols-1 gap-6 md:grid-cols-2 lg:grid-cols-3">
      
        
        














  
  <article class="related-card group">
    <a href="/posts/Insights-into-DeepSeek-V3-Scaling-Challenges-and-Reflections-on-Hardware-for-AI-Architectures/" class="block h-full">
      <div
        class="bg-card border-border hover:bg-primary/5 hover:border-primary/20 focus:ring-primary/20 flex h-full flex-col overflow-hidden rounded-xl border transition-all duration-300 ease-out hover:-translate-y-1 hover:scale-[1.02] hover:shadow-lg focus:ring-2 focus:outline-none">
        
        <div class="relative aspect-[16/9] flex-shrink-0 overflow-hidden">
    
    <div class="from-purple-500/20 to-pink-500/10 relative aspect-[16/9] overflow-hidden bg-gradient-to-br" style="background-blend-mode: overlay; background-color: color-mix(in srgb, var(--color-primary) 15%, transparent);">
      
      <div class="absolute inset-0">
        
          
          
          <div class="absolute left-[20%] top-[20%] h-5 w-5 rotate-0 bg-white/80" style="clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%)"></div>
          
          <div class="absolute right-[25%] top-[25%] h-4 w-4 rotate-36 bg-white/70" style="clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%)"></div>
          
          <div class="absolute left-[30%] bottom-[30%] h-3 w-3 rotate-72 bg-white/60" style="clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%)"></div>
          
          <div class="absolute right-[20%] bottom-[20%] h-4 w-4 rotate-108 bg-white/65" style="clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%)"></div>
          
          <div class="absolute left-[45%] top-[45%] h-2 w-2 rotate-144 bg-white/50" style="clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%)"></div>
          
          <div class="absolute right-[35%] top-[35%] h-2 w-2 rounded-full bg-white/40"></div>
          <div class="absolute left-[40%] bottom-[35%] h-1.5 w-1.5 rounded-full bg-white/35"></div>
          <div class="absolute right-[45%] bottom-[45%] h-1 w-1 rounded-full bg-white/30"></div>
          
          <div class="absolute top-[30%] left-[30%] h-0.5 w-6 rotate-30 bg-white/25"></div>
          <div class="absolute bottom-[30%] right-[30%] h-0.5 w-4 -rotate-45 bg-white/20"></div>
        
      </div>
    </div>
  
</div>

        
        <div class="flex min-h-0 flex-1 flex-col p-4">
          
          <div class="space-y-3 flex-1">
            
            <h3
              class="text-foreground group-hover:text-primary line-clamp-2 text-base leading-tight font-semibold transition-colors duration-200">
              Insights into DeepSeek-V3: Scaling Challenges and Reflections on Hardware for AI Architectures
            </h3>

            
            
              <div class="flex-1 min-h-[40px]">
                
                  <p
                    class="text-muted-foreground line-clamp-2 text-sm leading-relaxed">
                    논문 링크
DeepSeek-V3: 2 048 대 H800으로 405 B-급 LLM을 돌린다는 것의 의미 TL;DR ― …
                  </p>
                
              </div>
            
          </div>

          
          
            <div class="flex-shrink-0 mt-4">
              













  <div class="text-muted-foreground mb-3 flex flex-shrink-0 items-center justify-between text-xs">
    
    
      
      
      
      
        <div class="flex items-center gap-1">
          
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="작성일"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z" />
</svg>
          <time datetime="2025-07-08">
            07월 08일
          </time>
        </div>
      

      
      
        <div class="flex items-center gap-1">
          
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="읽는 시간"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
</svg>
          <span>26분</span>
        </div>
      
      
    
  </div>




            </div>
          
        </div>
      </div>
    </a>
  </article>


      
        
        














  
  <article class="related-card group">
    <a href="/posts/Native-Sparse-Attention-Hardware-Aligned-and-Natively-Trainable-Sparse-Attention/" class="block h-full">
      <div
        class="bg-card border-border hover:bg-primary/5 hover:border-primary/20 focus:ring-primary/20 flex h-full flex-col overflow-hidden rounded-xl border transition-all duration-300 ease-out hover:-translate-y-1 hover:scale-[1.02] hover:shadow-lg focus:ring-2 focus:outline-none">
        
        <div class="relative aspect-[16/9] flex-shrink-0 overflow-hidden">
    
    <div class="from-orange-500/20 to-red-500/10 relative aspect-[16/9] overflow-hidden bg-gradient-to-br" style="background-blend-mode: overlay; background-color: color-mix(in srgb, var(--color-primary) 15%, transparent);">
      
      <div class="absolute inset-0">
        
          
          
          <div class="absolute left-[20%] top-[20%] h-5 w-5 rotate-0 bg-white/80" style="clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%)"></div>
          
          <div class="absolute right-[25%] top-[25%] h-4 w-4 rotate-36 bg-white/70" style="clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%)"></div>
          
          <div class="absolute left-[30%] bottom-[30%] h-3 w-3 rotate-72 bg-white/60" style="clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%)"></div>
          
          <div class="absolute right-[20%] bottom-[20%] h-4 w-4 rotate-108 bg-white/65" style="clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%)"></div>
          
          <div class="absolute left-[45%] top-[45%] h-2 w-2 rotate-144 bg-white/50" style="clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%)"></div>
          
          <div class="absolute right-[35%] top-[35%] h-2 w-2 rounded-full bg-white/40"></div>
          <div class="absolute left-[40%] bottom-[35%] h-1.5 w-1.5 rounded-full bg-white/35"></div>
          <div class="absolute right-[45%] bottom-[45%] h-1 w-1 rounded-full bg-white/30"></div>
          
          <div class="absolute top-[30%] left-[30%] h-0.5 w-6 rotate-30 bg-white/25"></div>
          <div class="absolute bottom-[30%] right-[30%] h-0.5 w-4 -rotate-45 bg-white/20"></div>
        
      </div>
    </div>
  
</div>

        
        <div class="flex min-h-0 flex-1 flex-col p-4">
          
          <div class="space-y-3 flex-1">
            
            <h3
              class="text-foreground group-hover:text-primary line-clamp-2 text-base leading-tight font-semibold transition-colors duration-200">
              Native Sparse Attention: Hardware-Aligned and Natively Trainable Sparse Attention
            </h3>

            
            
              <div class="flex-1 min-h-[40px]">
                
                  <p
                    class="text-muted-foreground line-clamp-2 text-sm leading-relaxed">
                    논문 링크
Native Sparse Attention (NSA) — 64 k 토큰도 11× 빠르게, 정확도는 그대로 한 줄 요약 (TL;DR) …
                  </p>
                
              </div>
            
          </div>

          
          
            <div class="flex-shrink-0 mt-4">
              













  <div class="text-muted-foreground mb-3 flex flex-shrink-0 items-center justify-between text-xs">
    
    
      
      
      
      
        <div class="flex items-center gap-1">
          
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="작성일"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z" />
</svg>
          <time datetime="2025-07-07">
            07월 07일
          </time>
        </div>
      

      
      
        <div class="flex items-center gap-1">
          
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="읽는 시간"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
</svg>
          <span>31분</span>
        </div>
      
      
    
  </div>




            </div>
          
        </div>
      </div>
    </a>
  </article>


      
        
        














  
  <article class="related-card group">
    <a href="/posts/DeepSeek-Coder-V2-Breaking-the-Barrier-of-Closed-Source-Models-in-Code-Intelligence/" class="block h-full">
      <div
        class="bg-card border-border hover:bg-primary/5 hover:border-primary/20 focus:ring-primary/20 flex h-full flex-col overflow-hidden rounded-xl border transition-all duration-300 ease-out hover:-translate-y-1 hover:scale-[1.02] hover:shadow-lg focus:ring-2 focus:outline-none">
        
        <div class="relative aspect-[16/9] flex-shrink-0 overflow-hidden">
    
    <div class="from-green-500/20 to-blue-500/10 relative aspect-[16/9] overflow-hidden bg-gradient-to-br" style="background-blend-mode: overlay; background-color: color-mix(in srgb, var(--color-primary) 15%, transparent);">
      
      <div class="absolute inset-0">
        
          
          
          <div class="absolute left-[20%] top-[20%] h-5 w-5 rotate-0 bg-white/80" style="clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%)"></div>
          
          <div class="absolute right-[25%] top-[25%] h-4 w-4 rotate-36 bg-white/70" style="clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%)"></div>
          
          <div class="absolute left-[30%] bottom-[30%] h-3 w-3 rotate-72 bg-white/60" style="clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%)"></div>
          
          <div class="absolute right-[20%] bottom-[20%] h-4 w-4 rotate-108 bg-white/65" style="clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%)"></div>
          
          <div class="absolute left-[45%] top-[45%] h-2 w-2 rotate-144 bg-white/50" style="clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%)"></div>
          
          <div class="absolute right-[35%] top-[35%] h-2 w-2 rounded-full bg-white/40"></div>
          <div class="absolute left-[40%] bottom-[35%] h-1.5 w-1.5 rounded-full bg-white/35"></div>
          <div class="absolute right-[45%] bottom-[45%] h-1 w-1 rounded-full bg-white/30"></div>
          
          <div class="absolute top-[30%] left-[30%] h-0.5 w-6 rotate-30 bg-white/25"></div>
          <div class="absolute bottom-[30%] right-[30%] h-0.5 w-4 -rotate-45 bg-white/20"></div>
        
      </div>
    </div>
  
</div>

        
        <div class="flex min-h-0 flex-1 flex-col p-4">
          
          <div class="space-y-3 flex-1">
            
            <h3
              class="text-foreground group-hover:text-primary line-clamp-2 text-base leading-tight font-semibold transition-colors duration-200">
              DeepSeek-Coder-V2: Breaking the Barrier of Closed-Source Models in Code Intelligence
            </h3>

            
            
              <div class="flex-1 min-h-[40px]">
                
                  <p
                    class="text-muted-foreground line-clamp-2 text-sm leading-relaxed">
                    논문 링크
DeepSeek-Coder-V2: 오픈소스 코드-LLM이 GPT-4 급으로 뛰어오른 순간 한 줄 요약 (TL;DR) 236 B 파라미 …
                  </p>
                
              </div>
            
          </div>

          
          
            <div class="flex-shrink-0 mt-4">
              













  <div class="text-muted-foreground mb-3 flex flex-shrink-0 items-center justify-between text-xs">
    
    
      
      
      
      
        <div class="flex items-center gap-1">
          
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="작성일"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z" />
</svg>
          <time datetime="2025-06-30">
            06월 30일
          </time>
        </div>
      

      
      
        <div class="flex items-center gap-1">
          
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="읽는 시간"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
</svg>
          <span>30분</span>
        </div>
      
      
    
  </div>




            </div>
          
        </div>
      </div>
    </a>
  </article>


      
    </div>

    
    
    
    

  </section>




  
  


    </main>

    <footer class="mx-auto max-w-4xl px-4 py-8">
  <div class="px-6 py-6">
    
    
      <nav class="mb-6">
        <div class="flex flex-wrap items-center justify-center gap-1">
          
            
            
            
            <a
              href="/index.xml"
              
              class="nav-link hover:text-primary hover:bg-primary/10 text-muted-foreground flex items-center gap-2 rounded-lg px-4 py-2 text-sm font-medium transition-all duration-300 hover:scale-105">
              
                
  <svg class="h-5 w-5"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="RSS Feed">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 5c7.18 0 13 5.82 13 13M6 11a7 7 0 017 7m-6 0a1 1 0 11-2 0 1 1 0 012 0z" />

</svg>
              
              <span
                >
                  RSS Feed
                </span
              >
            </a>
          
        </div>
      </nav>
    


    
    
      <div class="border-border mb-6 border-t"></div>
    


    
    <div class="flex flex-col items-center justify-between gap-4 md:flex-row">
      
      <div class="text-muted-foreground text-sm">
        <p>
          &copy; 2025 Jaehun&#39;s Blog.
          모든 권리 보유.
        </p>
      </div>

      
      
        <div class="flex items-center gap-3">
          
            <a
              href="https://github.com/ryujaehun"
              
                target="_blank" rel="noopener noreferrer"
              
              class="text-muted-foreground hover:text-primary focus:ring-primary/20 rounded-lg p-1 transition-all duration-300 ease-out hover:scale-110 focus:ring-2 focus:outline-none"
              title="GitHub"
              aria-label="GitHub">
              
                
  <svg class="h-6 w-6"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="GitHub"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path d="M15 22v-4a4.8 4.8 0 0 0-1-3.5c3 0 6-2 6-5.5c.08-1.25-.27-2.48-1-3.5c.28-1.15.28-2.35 0-3.5c0 0-1 0-3 1.5c-2.64-.5-5.36-.5-8 0C6 2 5 2 5 2c-.3 1.15-.3 2.35 0 3.5A5.4 5.4 0 0 0 4 9c0 3.5 3 5.5 6 5.5c-.39.49-.68 1.05-.85 1.65S8.93 17.38 9 18v4"/><path d="M9 18c-4.51 2-5-2-7-2"/></g></svg>
              
            </a>
          
            <a
              href="https://www.linkedin.com/in/jaehunryu/"
              
                target="_blank" rel="noopener noreferrer"
              
              class="text-muted-foreground hover:text-primary focus:ring-primary/20 rounded-lg p-1 transition-all duration-300 ease-out hover:scale-110 focus:ring-2 focus:outline-none"
              title="Linkedin"
              aria-label="Linkedin">
              
                
  <svg class="h-6 w-6"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="Linkedin"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path d="M16 8a6 6 0 0 1 6 6v7h-4v-7a2 2 0 0 0-2-2a2 2 0 0 0-2 2v7h-4v-7a6 6 0 0 1 6-6M2 9h4v12H2z"/><circle cx="4" cy="4" r="2"/></g></svg>
              
            </a>
          
            <a
              href="mailto:jaehunryu@icloud.com"
              
              class="text-muted-foreground hover:text-primary focus:ring-primary/20 rounded-lg p-1 transition-all duration-300 ease-out hover:scale-110 focus:ring-2 focus:outline-none"
              title="Email"
              aria-label="Email">
              
                
  <svg class="h-6 w-6"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="Email">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 8l7.89 5.26a2 2 0 002.22 0L21 8M5 19h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z" />

</svg>
              
            </a>
          
        </div>
      

    </div>
  </div>
</footer>


    
    



<div
  id="dock"
  class="pointer-events-none fixed bottom-4 left-1/2 z-[9999] w-fit -translate-x-1/2 translate-y-24 opacity-0 transition-all duration-300 ease-out sm:right-0 sm:left-0 sm:mx-auto sm:translate-x-0"
  role="toolbar"
  aria-label="바로가기 도구 모음">
  <nav
    class="border-border bg-card/80 scrollbar-hide xs:px-3 xs:py-2 mx-auto flex max-w-[calc(100vw-2rem)] min-w-fit items-center justify-center overflow-x-auto rounded-2xl border px-4 py-3 shadow-lg backdrop-blur-sm sm:px-4 sm:py-3">
    
    
      <button
        id="dock-back"
        class="text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 xs:px-2 xs:py-1.5 flex flex-shrink-0 items-center gap-2 rounded-lg px-3 py-2 text-sm font-medium transition-all duration-300 ease-out hover:-translate-y-0.5 hover:scale-105 focus:ring-2 focus:outline-none sm:px-3 sm:py-2"
        title="뒤로"
        aria-label="뒤로">
        
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24">
  <path d="m12 19-7-7 7-7"/>
  <path d="M19 12H5"/>

</svg>
        <span class="hidden sm:inline"
          >뒤로</span
        >
      </button>

      
      <div class="bg-border xs:mx-1 mx-2 h-6 w-px sm:mx-2"></div>
    


    
    
      <button
        id="dock-toc"
        class="text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 xs:px-2 xs:py-1.5 flex flex-shrink-0 items-center gap-2 rounded-lg px-3 py-2 text-sm font-medium transition-all duration-300 ease-out hover:-translate-y-0.5 hover:scale-105 focus:ring-2 focus:outline-none sm:px-3 sm:py-2"
        title="목차"
        aria-label="목차">
        
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24">
  <line x1="8" x2="21" y1="6" y2="6"/>
  <line x1="8" x2="21" y1="12" y2="12"/>
  <line x1="8" x2="21" y1="18" y2="18"/>
  <line x1="3" x2="3.01" y1="6" y2="6"/>
  <line x1="3" x2="3.01" y1="12" y2="12"/>
  <line x1="3" x2="3.01" y1="18" y2="18"/>

</svg>
        <span class="hidden sm:inline"
          >목차</span
        >
      </button>

      
      <div class="bg-border xs:mx-1 mx-2 h-6 w-px sm:mx-2"></div>
    


    
    <button
      id="dock-search"
      class="text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 xs:px-3 xs:py-1.5 flex flex-shrink-0 items-center gap-2 rounded-lg px-4 py-2 text-sm font-medium transition-all duration-300 ease-out hover:-translate-y-0.5 hover:scale-105 focus:ring-2 focus:outline-none sm:px-4 sm:py-2"
      title="검색"
      aria-label="검색">
      
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="m21 21-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />

</svg>
      <span class="hidden md:inline"
        >검색</span
      >
    </button>

    
    <div class="bg-border xs:mx-1 mx-2 h-6 w-px sm:mx-2"></div>

    
    
    


    
    <button
      id="dock-top"
      class="text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 xs:px-2 xs:py-1.5 flex flex-shrink-0 items-center gap-2 rounded-lg px-3 py-2 text-sm font-medium transition-all duration-300 ease-out hover:-translate-y-0.5 hover:scale-105 focus:ring-2 focus:outline-none sm:px-3 sm:py-2"
      title="맨 위로"
      aria-label="맨 위로">
      
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24">
  <path d="m18 15-6-6-6 6"/>

</svg>
      <span class="hidden sm:inline"
        >맨 위로</span
      >
    </button>
  </nav>
</div>


    
      



<div
  id="toc-overlay"
  class="pointer-events-none fixed inset-0 z-40 bg-black/50 opacity-0 backdrop-blur-sm transition-all duration-300"
  role="dialog"
  aria-modal="true"
  aria-labelledby="toc-title"></div>


<div
  id="toc-card"
  class="pointer-events-none fixed inset-4 z-50 flex w-auto scale-95 items-center justify-center opacity-0 transition-all duration-300 sm:inset-auto sm:top-1/2 sm:left-1/2 sm:block sm:w-full sm:max-w-md sm:-translate-x-1/2 sm:-translate-y-1/2"
  role="dialog"
  aria-modal="true"
  aria-labelledby="toc-title">
  <div
    class="bg-card border-border w-full max-w-sm overflow-hidden rounded-xl border shadow-xl sm:max-w-md">
    
    <div
      class="border-border bg-muted/30 flex items-center justify-between border-b p-4">
      <div class="flex items-center gap-3">
        
  <svg class="h-5 w-5"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24">
  <line x1="8" x2="21" y1="6" y2="6"/>
  <line x1="8" x2="21" y1="12" y2="12"/>
  <line x1="8" x2="21" y1="18" y2="18"/>
  <line x1="3" x2="3.01" y1="6" y2="6"/>
  <line x1="3" x2="3.01" y1="12" y2="12"/>
  <line x1="3" x2="3.01" y1="18" y2="18"/>

</svg>
        <h2 id="toc-title" class="text-foreground text-lg font-semibold">
          목차
        </h2>
      </div>

      
      <button
        id="toc-close"
        class="text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 rounded-lg p-2 transition-all duration-200 ease-out hover:-translate-y-0.5 hover:scale-105 focus:ring-2 focus:outline-none"
        title="닫기"
        aria-label="닫기">
        
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />

</svg>
      </button>
    </div>

    
    <div class="max-h-96 overflow-y-auto p-4">
      <nav
        id="toc-nav"
        class="toc-scrollbar"
        aria-label="글 목차">
          
          <div id="toc-content">
            <nav id="TableOfContents">
  <ul>
    <li><a href="#한-줄-요약-tldr">한 줄 요약 (TL;DR)</a></li>
    <li><a href="#핵심-아이디어">핵심 아이디어</a></li>
    <li><a href="#배경-그들이-해결한-문제">배경: 그들이 해결한 문제</a></li>
    <li><a href="#새로운-접근법-helix-parallelism">새로운 접근법: <strong>Helix Parallelism</strong></a></li>
    <li><a href="#작동-원리-구체적인-예시로-살펴보기">작동 원리: 구체적인 예시로 살펴보기</a></li>
    <li><a href="#성능-검증-주요-결과">성능 검증: 주요 결과</a></li>
    <li><a href="#우리의-관점-강점-한계-그리고-이-연구가-중요한-이유">우리의 관점: 강점, 한계, 그리고 이 연구가 중요한 이유</a>
      <ul>
        <li><a href="#강점">강점</a></li>
        <li><a href="#한계">한계</a></li>
        <li><a href="#왜-중요한가">왜 중요한가?</a></li>
      </ul>
    </li>
    <li><a href="#다음-단계는-앞으로의-길">다음 단계는?: 앞으로의 길</a>
      <ul>
        <li><a href="#토글을-클릭하면-논문에-대한-자세한-llm-질의응답-내용을-확인할-수-있습니다">토글을 클릭하면 논문에 대한 자세한 LLM 질의응답 내용을 확인할 수 있습니다.</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#핵심-결론-한-줄-요약">핵심 결론 (한 줄 요약)</a></li>
      </ul>
    </li>
    <li><a href="#1-연구-공백-및-미해결-질문">1. 연구 공백 및 미해결 질문</a></li>
    <li><a href="#2-논문-출판-시점의-최신-기술-현황sota-요약">2. 논문 출판 시점의 최신 기술 현황(SOTA) 요약</a>
      <ul>
        <li><a href="#helix가-제시하는-숫자-기반-개선폭">Helix가 제시하는 숫자 기반 개선폭</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#한눈에-결론">한눈에 결론</a></li>
      </ul>
    </li>
    <li><a href="#helix-논문의-독창적-기여-3선">Helix 논문의 독창적 기여 3선</a></li>
  </ul>

  <ul>
    <li><a href="#저자-관점에서-내세우는-3가지-우월성-논거">저자 관점에서 내세우는 3가지 ‘우월성’ 논거</a>
      <ul>
        <li><a href="#추가-근거-텍스트-인용-중심">추가 근거 (텍스트 인용 중심)</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#1-용어변수-빠른-정의">1. 용어·변수 빠른 정의</a></li>
    <li><a href="#2-helix-알고리즘-단계별-워크플로">2. Helix 알고리즘, 단계별 워크플로</a></li>
    <li><a href="#3-장난감-예시로-전체-흐름-따라가기">3. 장난감 예시로 전체 흐름 따라가기</a>
      <ul>
        <li><a href="#3-1-입력-준비">3-1. 입력 준비</a></li>
        <li><a href="#3-2-attention-단계-gpu별-계산">3-2. <strong>Attention 단계</strong> (GPU별 계산)</a></li>
        <li><a href="#3-3-hop-b">3-3. <strong>HOP-B</strong></a></li>
        <li><a href="#3-4-ffn-단계">3-4. <strong>FFN 단계</strong></a></li>
      </ul>
    </li>
    <li><a href="#4-핵심-수치로-보는-helix-개선폭">4. 핵심 수치로 보는 Helix 개선폭</a>
      <ul>
        <li><a href="#정리--포인트">정리 &amp; 포인트</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#1-무엇을-하는가--기능">1. 무엇을 하는가? — 기능</a></li>
        <li><a href="#2-왜-핵심적인가--필수성">2. 왜 핵심적인가? — 필수성</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#1-실험에서-사용된-핵심-성능-지표">1. 실험에서 사용된 핵심 성능 지표</a></li>
    <li><a href="#2-벤치마크-모델환경">2. 벤치마크 모델·환경</a></li>
    <li><a href="#3-주요-결과-한눈에-보기">3. 주요 결과 한눈에 보기</a></li>
    <li><a href="#4-ablation-hop-b-통신-은닉-효과">4. Ablation: HOP-B 통신 은닉 효과</a></li>
    <li><a href="#5-저자들이-강조하는-성공-증거">5. 저자들이 강조하는 성공 증거</a>
      <ul>
        <li><a href="#정리">정리</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#한눈에-결론-1">한눈에 결론</a></li>
      </ul>
    </li>
    <li><a href="#1-helix-vs-주요-베이스라인sota--성능-비교표">1. Helix vs. 주요 베이스라인·SOTA ― 성능 비교표</a></li>
    <li><a href="#2-helix가-압도적이지-못했던-경우">2. Helix가 압도적이지 못했던 경우</a></li>
    <li><a href="#3-요약--비판적-시사점">3. 요약 &amp; 비판적 시사점</a></li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#결론-1-줄-요약">결론 (1-줄 요약)</a></li>
      </ul>
    </li>
    <li><a href="#1-저자가-직접-인정한-한계--실패-사례">1. 저자가 <strong>직접</strong> 인정한 한계 · 실패 사례</a></li>
    <li><a href="#2-추가로-예상되는-잠재-한계-비판적-분석">2. 추가로 예상되는 <strong>잠재 한계</strong> (비판적 분석)</a>
      <ul>
        <li><a href="#정리--쓸-만한-시사점">정리 — 쓸 만한 시사점</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#요약--다음-스텝-한눈에">요약 — 다음 스텝 한눈에</a></li>
      </ul>
    </li>
    <li><a href="#1-저자들이-명시한-향후-연구-방향">1. 저자들이 명시한 향후 연구 방향</a></li>
    <li><a href="#2-논문-한계-기반--추가로-필요한-연구-6선">2. 논문 한계 기반 ✔️ 추가로 필요한 연구 6선</a></li>
    <li><a href="#3-정리">3. 정리</a></li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#-1단계-어텐션attention-연산"><strong>🧠 1단계: 어텐션(Attention) 연산</strong></a>
          <ul>
            <li><a href="#gpu-구성-및-데이터-분할-자르기-"><strong>GPU 구성 및 데이터 분할 (자르기) ✂️</strong></a></li>
            <li><a href="#연산-및-통신-과정-"><strong>연산 및 통신 과정 ⚡</strong></a></li>
          </ul>
        </li>
        <li><a href="#-2단계-ffnfeed-forward-network-연산"><strong>⚙️ 2단계: FFN(Feed-Forward Network) 연산</strong></a>
          <ul>
            <li><a href="#gpu-구성-및-데이터-분할-자르기--1"><strong>GPU 구성 및 데이터 분할 (자르기) ✂️</strong></a></li>
            <li><a href="#연산-및-통신-과정--1"><strong>연산 및 통신 과정 ⚡</strong></a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#1-핵심-소프트웨어런타임-스택">1. 핵심 소프트웨어/런타임 스택</a></li>
    <li><a href="#2-메모리-프로파일-fp4-추론bf16-학습">2. 메모리 프로파일 (FP4 추론·BF16 학습)</a></li>
    <li><a href="#3-처리량--지연">3. 처리량 &amp; 지연</a></li>
    <li><a href="#4-연산량--비용">4. 연산량 &amp; 비용</a>
      <ul>
        <li><a href="#정리-포인트">정리 포인트</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#결론-압축-요약">결론 (압축 요약)</a></li>
      </ul>
    </li>
    <li><a href="#1--주요-평가-지표-정의--측정-단위">1 | 주요 평가 지표 정의 &amp; 측정 단위</a></li>
    <li><a href="#2--스케일링-법칙-helix-vs-전통-tppp">2 | 스케일링 법칙 (Helix vs 전통 TP/PP)</a>
      <ul>
        <li><a href="#2-1-컨텍스트-길이-s-증가">2-1 컨텍스트 길이 <em>S</em> 증가</a></li>
        <li><a href="#2-2-동시-사용자-b-증가">2-2 동시 사용자 <em>B</em> 증가</a></li>
        <li><a href="#2-3-gpu-수-g-확장">2-3 GPU 수 <em>G</em> 확장</a></li>
      </ul>
    </li>
    <li><a href="#3--전력비용-지표-계산-예시-32--h100-700-wgpu">3 | 전력·비용 지표 계산 예시 (32 × H100, 700 W/GPU)</a></li>
    <li><a href="#4--핵심-시사점">4 | 핵심 시사점</a></li>
  </ul>
</nav>
          </div>
      </nav>
    </div>

    
    <div class="border-border bg-muted/20 border-t px-4 py-3">
      <div class="text-muted-foreground text-center text-xs">
        <span>제목을 클릭하면 해당 위치로 이동합니다</span>
      </div>
    </div>
  </div>
</div>

    


  <link
    rel="stylesheet"
    href="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.css"
    integrity="sha384-5TcZemv2l/9On385z///+d7MSYlvIEw9FuZTIdZ14vJLqWphw7e7ZPuOiCHJcFCP"
    crossorigin="anonymous" />
  <script
    defer
    src="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.js"
    integrity="sha384-cMkvdD8LoxVzGF/RPUKAcvmm49FQ0oxwDF3BGKtDXcEc+T1b2N+teh/OJfpU0jr6"
    crossorigin="anonymous"></script>
  <script
    defer
    src="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/contrib/auto-render.min.js"
    integrity="sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh"
    crossorigin="anonymous"></script>

<script>
    
    function initKaTeX() {
        if (typeof renderMathInElement === 'undefined') {
            setTimeout(initKaTeX, 100);
            return;
        }

        var delimiters = [{"display":true,"left":"$$","right":"$$"},{"display":false,"left":"$","right":"$"}];

        renderMathInElement(document.body, {
            delimiters: delimiters,
            throwOnError: false,
            errorColor: '#cc0000',
            fleqn: false,
            leqno: false,
            trust: false
        });
    }

    
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initKaTeX);
    } else {
        initKaTeX();
    }
</script>
    



    
    
<div
  id="search-overlay"
  class="pointer-events-none fixed inset-0 z-40 bg-black/50 opacity-0 transition-opacity duration-300"></div>


<div
  id="search-modal"
  class="bg-card border-border pointer-events-none fixed top-1/2 left-1/2 z-50 max-h-[80vh] w-full max-w-2xl -translate-x-1/2 -translate-y-1/2 scale-95 transform overflow-hidden rounded-xl border opacity-0 shadow-xl transition-all duration-300">
  
  <div class="border-border flex items-center gap-3 border-b p-4">
    
    <div class="text-muted-foreground h-5 w-5 flex-shrink-0">
      
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="m21 21-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />

</svg>
    </div>

    
    <div class="relative flex-1">
      
      <button
        id="search-clear"
        class="text-muted-foreground hover:text-foreground hover:bg-muted/50 pointer-events-none absolute top-1/2 left-0 z-10 h-5 w-5 -translate-y-1/2 rounded opacity-0 transition-all duration-200"
        title="지우기"
        aria-label="지우기">
        
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />

</svg>
      </button>

      
      <input
        id="search-input"
        type="text"
        placeholder="게시글 검색..."
        class="text-foreground placeholder:text-muted-foreground w-full border-none bg-transparent pl-8 text-lg outline-none"
        autocomplete="off"
        spellcheck="false" />
    </div>

    
    <button
      id="search-close"
      class="text-muted-foreground hover:text-foreground hover:bg-muted/50 flex h-6 w-6 items-center justify-center rounded-md p-0.5 transition-all duration-200"
      title="닫기"
      aria-label="닫기">
      
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />

</svg>
    </button>
  </div>

  
  <div id="search-results" class="max-h-96 overflow-y-auto">
    
    <div
      id="search-empty"
      class="flex flex-col items-center justify-center py-12 text-center">
      <div
        class="bg-muted/50 mb-4 flex h-16 w-16 items-center justify-center rounded-full">
        
  <svg class="h-6 w-6"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="m21 21-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />

</svg>
      </div>
      <h3 class="text-foreground mb-2 text-lg font-semibold">
        검색 시작
      </h3>
      <p class="text-muted-foreground text-sm">
        검색어를 입력하세요
      </p>
    </div>

    
    <div
      id="search-loading"
      class="flex hidden items-center justify-center py-8">
      <div
        class="mr-3 h-6 w-6 animate-spin rounded-full border-2 border-current border-t-transparent"></div>
      <span class="text-muted-foreground"
        >검색 중...</span
      >
    </div>

    
    <div
      id="search-no-results"
      class="flex hidden flex-col items-center justify-center py-12 text-center">
      <div
        class="bg-muted/50 mb-4 flex h-16 w-16 items-center justify-center rounded-full">
        
  <svg class="h-6 w-6"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h7" />
</svg>
      </div>
      <h3 class="text-foreground mb-2 text-lg font-semibold">
        검색 결과 없음
      </h3>
      <p class="text-muted-foreground text-sm">
        다른 검색어로 시도해보세요
      </p>
    </div>

    
    <div id="search-results-list" class="hidden">
      
      <div
        id="search-stats"
        class="text-muted-foreground border-border border-b px-4 py-3 text-sm"
        data-template="%d개의 결과 찾음">
      </div>

      
      <div id="search-items" class="divide-border divide-y">
        
      </div>
    </div>
  </div>

  
  <div class="border-border bg-muted/20 border-t px-4 py-3">
    <div
      class="text-muted-foreground flex items-center justify-between text-xs">
      <div class="flex items-center gap-2 md:gap-4">
        <div class="flex items-center gap-1">
          <kbd
            class="bg-muted border-border rounded border px-1.5 py-0.5 text-xs"
            >↑↓</kbd
          >
          <span class="hidden sm:inline"
            >이동</span
          >
        </div>
        <div class="flex items-center gap-1">
          <kbd
            class="bg-muted border-border rounded border px-1.5 py-0.5 text-xs"
            >↵</kbd
          >
          <span class="hidden sm:inline"
            >선택</span
          >
        </div>
        <div class="flex items-center gap-1">
          <kbd
            class="bg-muted border-border rounded border px-1.5 py-0.5 text-xs"
            >ESC</kbd
          >
          <span class="hidden sm:inline"
            >닫기</span
          >
        </div>
      </div>
      <div class="search-hint-desktop flex items-center gap-1">
        <kbd class="bg-muted border-border rounded border px-1.5 py-0.5 text-xs"
          >⌘K</kbd
        >
        <span>단축키</span>
      </div>
    </div>
  </div>
</div>

  </body>
</html>
