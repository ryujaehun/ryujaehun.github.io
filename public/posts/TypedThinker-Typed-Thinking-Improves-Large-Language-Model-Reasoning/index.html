<!doctype html>
<html
  lang="ko-kr"
  data-theme="claude">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1314&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8" />
<meta
  name="viewport"
  content="width=device-width, initial-scale=1, shrink-to-fit=no" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />

<title>TypedThinker: Typed Thinking Improves Large Language Model Reasoning | Jaehun&#39;s Blog</title>

<meta name="description" content="논문 링크
Q : 이 논문을 아주 자세하게 읽고 논문의 강점과 독창적인 지점을 설명해주고 핵심 알고리즘을 예시 입력을 들어서 전체적인 과정을 설명해줘 추가적으로 논문의 한계점에 대해서도 알려줘 논문의 강점과 독창적인 지점 1...." />
<meta name="keywords" content="개발, 컴파일러, 프로그래밍, 에세이" />
<meta name="author" content="" />
<meta name="language" content="ko-kr" />

<meta name="robots" content="index, follow" />
<link rel="canonical" href="http://192.168.1.11:1314/posts/TypedThinker-Typed-Thinking-Improves-Large-Language-Model-Reasoning/" />



  <link rel="icon" type="image/svg+xml" href="/favicon.svg" />



<link rel="manifest" href="/site.webmanifest" />
<meta property="og:url" content="http://192.168.1.11:1314/posts/TypedThinker-Typed-Thinking-Improves-Large-Language-Model-Reasoning/">
  <meta property="og:site_name" content="Jaehun&#39;s Blog">
  <meta property="og:title" content="TypedThinker: Typed Thinking Improves Large Language Model Reasoning">
  <meta property="og:description" content="논문 링크
Q : 이 논문을 아주 자세하게 읽고 논문의 강점과 독창적인 지점을 설명해주고 핵심 알고리즘을 예시 입력을 들어서 전체적인 과정을 설명해줘 추가적으로 논문의 한계점에 대해서도 알려줘 논문의 강점과 독창적인 지점 1. 강점 다양한 추론 방식의 활용
기존 LLM(대형 언어 모델)의 한계를 극복하기 위해 연역(deductive), 귀납(inductive), 가설(abductive), 유추(analogical) 네 가지의 논리적 추론 방식을 적용함.
각각의 추론 방식이 특정 유형의 문제에서 효과적인지를 실험적으로 분석함.">
  <meta property="og:locale" content="ko_kr">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-02-24T00:00:00+00:00">
    <meta property="article:modified_time" content="2025-02-24T00:00:00+00:00">
    <meta property="og:image" content="http://192.168.1.11:1314/images/og-default.avif">


  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:image" content="http://192.168.1.11:1314/images/og-default.avif">
  <meta name="twitter:title" content="TypedThinker: Typed Thinking Improves Large Language Model Reasoning">
  <meta name="twitter:description" content="논문 링크
Q : 이 논문을 아주 자세하게 읽고 논문의 강점과 독창적인 지점을 설명해주고 핵심 알고리즘을 예시 입력을 들어서 전체적인 과정을 설명해줘 추가적으로 논문의 한계점에 대해서도 알려줘 논문의 강점과 독창적인 지점 1. 강점 다양한 추론 방식의 활용
기존 LLM(대형 언어 모델)의 한계를 극복하기 위해 연역(deductive), 귀납(inductive), 가설(abductive), 유추(analogical) 네 가지의 논리적 추론 방식을 적용함.
각각의 추론 방식이 특정 유형의 문제에서 효과적인지를 실험적으로 분석함.">


  <meta itemprop="name" content="TypedThinker: Typed Thinking Improves Large Language Model Reasoning">
  <meta itemprop="description" content="논문 링크
Q : 이 논문을 아주 자세하게 읽고 논문의 강점과 독창적인 지점을 설명해주고 핵심 알고리즘을 예시 입력을 들어서 전체적인 과정을 설명해줘 추가적으로 논문의 한계점에 대해서도 알려줘 논문의 강점과 독창적인 지점 1. 강점 다양한 추론 방식의 활용
기존 LLM(대형 언어 모델)의 한계를 극복하기 위해 연역(deductive), 귀납(inductive), 가설(abductive), 유추(analogical) 네 가지의 논리적 추론 방식을 적용함.
각각의 추론 방식이 특정 유형의 문제에서 효과적인지를 실험적으로 분석함.">
  <meta itemprop="datePublished" content="2025-02-24T00:00:00+00:00">
  <meta itemprop="dateModified" content="2025-02-24T00:00:00+00:00">
  <meta itemprop="wordCount" content="20528">
  <meta itemprop="image" content="http://192.168.1.11:1314/images/og-default.avif">
  <meta itemprop="keywords" content="Paper-Review,With-Gpt,ICLR2025">







<script>
  window.HUGO_SEARCH_CONFIG = {
    searchIndexURL: "\"/index.json\""
  };
</script>


































<script>

  window.HUGO_GALLERY_CONFIG = {
    justified_gallery:  false ,
    lightbox:  false ,
    justified: "{}",
    lightbox_options: "{}"
  };
</script>




  
    <link rel="stylesheet" href="/css/compiled.css" />
  





  
    <link rel="stylesheet" href="/css/chroma.css" />
  












      <script src="/js/main.js"></script>



  <script src="/js/gumshoe.polyfills.min.js"></script>



        <script src="/js/toc.js" defer></script>



      <script src="/js/search.js" defer></script>



      <script src="/js/dock.js" defer></script>











  











    <script>
      
      (function() {
        const theme = localStorage.getItem('theme') || 'system';
        const colorScheme = localStorage.getItem('colorScheme') || 'claude';

        
        document.documentElement.setAttribute('data-theme', colorScheme);

        
        function applyTheme() {
          if (theme === 'dark' || (theme === 'system' && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
            document.documentElement.classList.add('dark');
          } else {
            document.documentElement.classList.remove('dark');
          }
        }

        applyTheme();

        
        if (theme === 'system') {
          window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', applyTheme);
        }
      })();
    </script>
  </head>

  <body class="bg-background text-foreground min-h-screen antialiased">
    
    
  <div
    id="reading-progress-container"
    class="reading-progress-container pointer-events-none fixed top-0 right-0 left-0 z-50 transition-opacity duration-300 ease-out"
    data-height="3"
    data-smooth-scroll="true"
    data-hide-on-complete="false">
    
    <div class="reading-progress-bg w-full"></div>

    
    <div
      id="reading-progress-bar"
      class="from-primary to-primary/80 reading-progress-bar 
        transition-all duration-150 ease-out
       absolute top-0 left-0 w-0 bg-gradient-to-r"></div>
  </div>

  <script>
    (function () {
      "use strict";

      const progressContainer = document.getElementById(
        "reading-progress-container",
      );
      const progressBar = document.getElementById("reading-progress-bar");

      if (!progressContainer || !progressBar) return;

      
      const config = {
        smoothScroll: progressContainer.dataset.smoothScroll === "true",
        hideOnComplete: progressContainer.dataset.hideOnComplete === "true",
      };

      let isVisible = true;
      let gumshoeInstance = null;

      
      function calculateProgress() {
        const scrollTop =
          window.pageYOffset || document.documentElement.scrollTop;
        const documentHeight = document.documentElement.scrollHeight;
        const windowHeight = window.innerHeight;
        const scrollableHeight = documentHeight - windowHeight;

        if (scrollableHeight <= 0) return 0;

        return Math.min(Math.max((scrollTop / scrollableHeight) * 100, 0), 100);
      }

      
      function updateProgress() {
        const progress = calculateProgress();
        progressBar.style.width = progress + "%";

        
        if (config.hideOnComplete && progress >= 99.5) {
          if (isVisible) {
            progressContainer.style.opacity = "0";
            isVisible = false;
          }
        } else if (!isVisible) {
          progressContainer.style.opacity = "1";
          isVisible = true;
        }
      }

      
      let ticking = false;
      function requestTick() {
        if (!ticking) {
          requestAnimationFrame(() => {
            updateProgress();
            ticking = false;
          });
          ticking = true;
        }
      }

      
      function init() {
        
        window.addEventListener("scroll", requestTick, { passive: true });
        window.addEventListener("resize", requestTick, { passive: true });
        document.addEventListener("visibilitychange", () => {
          if (!document.hidden) requestTick();
        });

        
        requestTick();

        
        window.addEventListener("beforeunload", () => {
          window.removeEventListener("scroll", requestTick);
          window.removeEventListener("resize", requestTick);
        });
      }

      
      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", init);
      } else {
        init();
      }
    })();
  </script>

    <header class="sticky top-0 z-50 mx-auto max-w-4xl px-4 py-6">
  <div
    class="border-border bg-card/80 flex items-center rounded-xl border px-6 py-4 shadow-sm backdrop-blur-sm">
    
    <div class="hidden w-full items-center md:flex">
      
      <div class="flex items-center">
        
          
          <a
            href="/"
            class="bg-primary text-primary-foreground hover:bg-primary/90 flex h-10 w-10 items-center justify-center rounded-full text-lg font-bold transition-transform duration-200 hover:scale-105"
            aria-label="Jaehun&#39;s Blog">
            J
          </a>
        
      </div>

      
      <nav class="mx-8 flex flex-1 items-center justify-center">
        <div class="flex items-center space-x-1">
          
          
            
            
            
              
                
              
            
            
            <a
              href="/posts/"
              class="nav-link 
                text-muted-foreground hover:text-primary hover:bg-primary/10
               focus:ring-primary/20 relative flex items-center gap-2 rounded-lg px-4 py-2 text-sm font-medium transition-all duration-300 ease-out hover:-translate-y-0.5 hover:scale-105 focus:ring-2 focus:outline-none">
              
                
  <svg class="h-5 w-5"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="nav.posts">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 20H5a2 2 0 01-2-2V6a2 2 0 012-2h10a2 2 0 012 2v1m2 13a2 2 0 01-2-2V7m2 13a2 2 0 002-2V9a2 2 0 00-2-2h-2m-4-3H9M7 16h6M7 8h6v4H7V8z" />

</svg>
              
              <span
                >
                  게시글
                </span
              >
            </a>
          
            
            
            
              
                
              
            
            
            <a
              href="/categories/"
              class="nav-link 
                text-muted-foreground hover:text-primary hover:bg-primary/10
               focus:ring-primary/20 relative flex items-center gap-2 rounded-lg px-4 py-2 text-sm font-medium transition-all duration-300 ease-out hover:-translate-y-0.5 hover:scale-105 focus:ring-2 focus:outline-none">
              
                
  <svg class="h-5 w-5"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="nav.categories">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10" />

</svg>
              
              <span
                >
                  카테고리
                </span
              >
            </a>
          
            
            
            
              
                
              
            
            
            <a
              href="/tags/"
              class="nav-link 
                text-muted-foreground hover:text-primary hover:bg-primary/10
               focus:ring-primary/20 relative flex items-center gap-2 rounded-lg px-4 py-2 text-sm font-medium transition-all duration-300 ease-out hover:-translate-y-0.5 hover:scale-105 focus:ring-2 focus:outline-none">
              
                
  <svg class="h-5 w-5"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="nav.tags">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 7h.01M7 3h5c.512 0 1.024.195 1.414.586l7 7a2 2 0 010 2.828l-7 7a2 2 0 01-2.828 0l-7-7A1.994 1.994 0 013 12V7a4 4 0 014-4z" />

</svg>
              
              <span
                >
                  태그
                </span
              >
            </a>
          
            
            
            
              
                
              
            
            
            <a
              href="/archives/"
              class="nav-link 
                text-muted-foreground hover:text-primary hover:bg-primary/10
               focus:ring-primary/20 relative flex items-center gap-2 rounded-lg px-4 py-2 text-sm font-medium transition-all duration-300 ease-out hover:-translate-y-0.5 hover:scale-105 focus:ring-2 focus:outline-none">
              
                
  <svg class="h-5 w-5"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="nav.archives">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 8h14M5 8a2 2 0 110-4h14a2 2 0 110 4M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8m-9 4h4" />

</svg>
              
              <span
                >
                  아카이브
                </span
              >
            </a>
          
        </div>
      </nav>

      
      <div class="flex items-center space-x-2">
        
        
<div class="relative">
  <button id="language-toggle"
    class="dropdown-toggle border-border bg-background text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex h-10 w-10 items-center justify-center rounded-lg border transition-all duration-300 ease-out hover:scale-105 focus:ring-2 focus:outline-none active:scale-95"
    data-dropdown-type="language"
    aria-label="언어 변경"
    aria-expanded="false"
    aria-haspopup="true">
      
  <svg class="h-5 w-5 relative z-10"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="언어 변경">
	<path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="m5 8l6 6m-7 0l6-6l2-3M2 5h12M7 2h1m14 20l-5-10l-5 10m2-4h6" />
</svg></button>

  
  <div id="language-dropdown"
    class="dropdown-menu border-border bg-popover/95 absolute top-12 right-0 z-[60] hidden w-40 rounded-lg border p-1 shadow-lg backdrop-blur-sm transition-all duration-200 ease-out"
    data-dropdown-type="language"
    role="menu"
    aria-labelledby="language-toggle"><a href="/ko/" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none" role="menuitem" aria-current="true"><span class="font-medium">한국어</span></a><a href="/en/" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none" role="menuitem"><span class="font-medium">English</span></a></div>
</div>

        
        
<div class="relative">
  <button id="color-scheme-toggle"
    class="dropdown-toggle border-border bg-background text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex h-10 w-10 items-center justify-center rounded-lg border transition-all duration-300 ease-out hover:scale-105 focus:ring-2 focus:outline-none active:scale-95"
    data-dropdown-type="color-scheme"
    aria-label="테마 변경"
    aria-expanded="false"
    aria-haspopup="true">
      
  <svg class="h-5 w-5 relative z-10"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="테마 변경">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 21a4 4 0 01-4-4V5a2 2 0 012-2h4a2 2 0 012 2v12a4 4 0 01-4 4zM21 5a2 2 0 00-2-2h-4a2 2 0 00-2 2v6a2 2 0 002 2h4a2 2 0 002-2V5z" />

</svg></button>

  
  <div id="color-scheme-dropdown"
    class="dropdown-menu border-border bg-popover/95 absolute top-12 right-0 z-[60] hidden w-44 rounded-lg border p-1 shadow-lg backdrop-blur-sm transition-all duration-200 ease-out"
    data-dropdown-type="color-scheme"><button data-color-scheme="claude" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none"><span>Default</span></button><button data-color-scheme="default" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none"><span>White</span></button><button data-color-scheme="bumblebee" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none"><span>Bumblebee</span></button><button data-color-scheme="emerald" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none"><span>Emerald</span></button><button data-color-scheme="nord" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none"><span>Nord</span></button><button data-color-scheme="sunset" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none"><span>Sunset</span></button><button data-color-scheme="abyss" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none"><span>Abyss</span></button><button data-color-scheme="dracula" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none"><span>Dracula</span></button><button data-color-scheme="amethyst" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none"><span>Amethyst</span></button><button data-color-scheme="slate" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none"><span>Slate</span></button><button data-color-scheme="twitter" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none"><span>Twitter</span></button></div>
</div>

        
        
<div class="relative">
  <button id="theme-toggle"
    class="dropdown-toggle border-border bg-background text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex h-10 w-10 items-center justify-center rounded-lg border transition-all duration-300 ease-out hover:scale-105 focus:ring-2 focus:outline-none active:scale-95"
    data-dropdown-type="theme"
    aria-label="테마 변경"
    aria-expanded="false"
    aria-haspopup="true">
      
      
  <svg class="h-5 w-5 sun-icon hidden relative z-10"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="라이트">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" />

</svg>
      
      
  <svg class="h-5 w-5 moon-icon hidden relative z-10"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="다크">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" />

</svg>
      
      
  <svg class="h-5 w-5 system-icon hidden relative z-10"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="시스템">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.75 17L9 20l-1 1h8l-1-1-.75-3M3 13h18M5 17h14a2 2 0 002-2V5a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z" />

</svg></button>

  
  <div id="theme-dropdown"
    class="dropdown-menu border-border bg-popover/95 absolute top-12 right-0 z-[60] hidden w-40 rounded-lg border p-1 shadow-lg backdrop-blur-sm transition-all duration-200 ease-out"
    data-dropdown-type="theme"><button data-theme="light" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none">
  <svg class="h-5 w-5 mr-3 h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="라이트">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" />

</svg><span>라이트</span></button><button data-theme="dark" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none">
  <svg class="h-5 w-5 mr-3 h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="다크">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" />

</svg><span>다크</span></button><button data-theme="system" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none">
  <svg class="h-5 w-5 mr-3 h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="시스템">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.75 17L9 20l-1 1h8l-1-1-.75-3M3 13h18M5 17h14a2 2 0 002-2V5a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z" />

</svg><span>시스템</span></button></div>
</div>
      </div>
    </div>

    
    <div class="flex w-full items-center justify-between md:hidden">
      
      
<div class="relative">
  <button
    id="mobile-menu-toggle"
    class="dropdown-toggle border-border bg-background text-muted-foreground hover:bg-accent hover:text-foreground flex h-10 w-10 items-center justify-center rounded-lg border transition-colors duration-200"
    data-dropdown-type="mobile-menu"
    aria-label="메뉴"
    aria-expanded="false"
    aria-haspopup="true">
    
  <svg class="h-5 w-5"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="메뉴">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16" />

</svg>
  </button>

  
  <div
    id="mobile-menu"
    class="mobile-menu dropdown-menu border-border bg-popover/95 absolute top-12 left-0 z-[60] hidden w-80 max-w-[calc(100vw-2rem)] rounded-lg border p-1 shadow-lg backdrop-blur-sm transition-all duration-200 ease-out md:hidden"
    data-dropdown-type="mobile-menu"
    role="menu"
    aria-labelledby="mobile-menu-toggle">
    <nav class="flex flex-col">
      
      
        
        
        
          
            
          
        
        
        <a
          href="/posts/"
          class="nav-link 
            text-muted-foreground hover:text-primary hover:bg-primary/10
           focus:ring-primary/20 relative flex items-center gap-3 rounded-md px-4 py-3 text-sm font-medium transition-all duration-200 ease-out hover:translate-x-1 focus:ring-2 focus:outline-none"
          role="menuitem"
          >
          
            
  <svg class="h-5 w-5"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="nav.posts">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 20H5a2 2 0 01-2-2V6a2 2 0 012-2h10a2 2 0 012 2v1m2 13a2 2 0 01-2-2V7m2 13a2 2 0 002-2V9a2 2 0 00-2-2h-2m-4-3H9M7 16h6M7 8h6v4H7V8z" />

</svg>
          
          <span
            >
              게시글
            </span
          >
        </a>
      
        
        
        
          
            
          
        
        
        <a
          href="/categories/"
          class="nav-link 
            text-muted-foreground hover:text-primary hover:bg-primary/10
           focus:ring-primary/20 relative flex items-center gap-3 rounded-md px-4 py-3 text-sm font-medium transition-all duration-200 ease-out hover:translate-x-1 focus:ring-2 focus:outline-none"
          role="menuitem"
          >
          
            
  <svg class="h-5 w-5"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="nav.categories">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10" />

</svg>
          
          <span
            >
              카테고리
            </span
          >
        </a>
      
        
        
        
          
            
          
        
        
        <a
          href="/tags/"
          class="nav-link 
            text-muted-foreground hover:text-primary hover:bg-primary/10
           focus:ring-primary/20 relative flex items-center gap-3 rounded-md px-4 py-3 text-sm font-medium transition-all duration-200 ease-out hover:translate-x-1 focus:ring-2 focus:outline-none"
          role="menuitem"
          >
          
            
  <svg class="h-5 w-5"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="nav.tags">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 7h.01M7 3h5c.512 0 1.024.195 1.414.586l7 7a2 2 0 010 2.828l-7 7a2 2 0 01-2.828 0l-7-7A1.994 1.994 0 013 12V7a4 4 0 014-4z" />

</svg>
          
          <span
            >
              태그
            </span
          >
        </a>
      
        
        
        
          
            
          
        
        
        <a
          href="/archives/"
          class="nav-link 
            text-muted-foreground hover:text-primary hover:bg-primary/10
           focus:ring-primary/20 relative flex items-center gap-3 rounded-md px-4 py-3 text-sm font-medium transition-all duration-200 ease-out hover:translate-x-1 focus:ring-2 focus:outline-none"
          role="menuitem"
          >
          
            
  <svg class="h-5 w-5"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="nav.archives">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 8h14M5 8a2 2 0 110-4h14a2 2 0 110 4M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8m-9 4h4" />

</svg>
          
          <span
            >
              아카이브
            </span
          >
        </a>
      
    </nav>
  </div>
</div>


      
      <div class="flex items-center space-x-2">
        
        
<div class="relative">
  <button id="language-toggle"
    class="dropdown-toggle border-border bg-background text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex h-10 w-10 items-center justify-center rounded-lg border transition-all duration-300 ease-out hover:scale-105 focus:ring-2 focus:outline-none active:scale-95"
    data-dropdown-type="language"
    aria-label="언어 변경"
    aria-expanded="false"
    aria-haspopup="true">
      
  <svg class="h-5 w-5 relative z-10"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="언어 변경">
	<path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="m5 8l6 6m-7 0l6-6l2-3M2 5h12M7 2h1m14 20l-5-10l-5 10m2-4h6" />
</svg></button>

  
  <div id="language-dropdown"
    class="dropdown-menu border-border bg-popover/95 absolute top-12 right-0 z-[60] hidden w-40 rounded-lg border p-1 shadow-lg backdrop-blur-sm transition-all duration-200 ease-out"
    data-dropdown-type="language"
    role="menu"
    aria-labelledby="language-toggle"><a href="/ko/" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none" role="menuitem" aria-current="true"><span class="font-medium">한국어</span></a><a href="/en/" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none" role="menuitem"><span class="font-medium">English</span></a></div>
</div>

        
        
<div class="relative">
  <button id="color-scheme-toggle"
    class="dropdown-toggle border-border bg-background text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex h-10 w-10 items-center justify-center rounded-lg border transition-all duration-300 ease-out hover:scale-105 focus:ring-2 focus:outline-none active:scale-95"
    data-dropdown-type="color-scheme"
    aria-label="테마 변경"
    aria-expanded="false"
    aria-haspopup="true">
      
  <svg class="h-5 w-5 relative z-10"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="테마 변경">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 21a4 4 0 01-4-4V5a2 2 0 012-2h4a2 2 0 012 2v12a4 4 0 01-4 4zM21 5a2 2 0 00-2-2h-4a2 2 0 00-2 2v6a2 2 0 002 2h4a2 2 0 002-2V5z" />

</svg></button>

  
  <div id="color-scheme-dropdown"
    class="dropdown-menu border-border bg-popover/95 absolute top-12 right-0 z-[60] hidden w-44 rounded-lg border p-1 shadow-lg backdrop-blur-sm transition-all duration-200 ease-out"
    data-dropdown-type="color-scheme"><button data-color-scheme="claude" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none"><span>Default</span></button><button data-color-scheme="default" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none"><span>White</span></button><button data-color-scheme="bumblebee" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none"><span>Bumblebee</span></button><button data-color-scheme="emerald" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none"><span>Emerald</span></button><button data-color-scheme="nord" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none"><span>Nord</span></button><button data-color-scheme="sunset" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none"><span>Sunset</span></button><button data-color-scheme="abyss" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none"><span>Abyss</span></button><button data-color-scheme="dracula" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none"><span>Dracula</span></button><button data-color-scheme="amethyst" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none"><span>Amethyst</span></button><button data-color-scheme="slate" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none"><span>Slate</span></button><button data-color-scheme="twitter" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none"><span>Twitter</span></button></div>
</div>

        
        
<div class="relative">
  <button id="theme-toggle"
    class="dropdown-toggle border-border bg-background text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex h-10 w-10 items-center justify-center rounded-lg border transition-all duration-300 ease-out hover:scale-105 focus:ring-2 focus:outline-none active:scale-95"
    data-dropdown-type="theme"
    aria-label="테마 변경"
    aria-expanded="false"
    aria-haspopup="true">
      
      
  <svg class="h-5 w-5 sun-icon hidden relative z-10"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="라이트">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" />

</svg>
      
      
  <svg class="h-5 w-5 moon-icon hidden relative z-10"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="다크">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" />

</svg>
      
      
  <svg class="h-5 w-5 system-icon hidden relative z-10"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="시스템">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.75 17L9 20l-1 1h8l-1-1-.75-3M3 13h18M5 17h14a2 2 0 002-2V5a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z" />

</svg></button>

  
  <div id="theme-dropdown"
    class="dropdown-menu border-border bg-popover/95 absolute top-12 right-0 z-[60] hidden w-40 rounded-lg border p-1 shadow-lg backdrop-blur-sm transition-all duration-200 ease-out"
    data-dropdown-type="theme"><button data-theme="light" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none">
  <svg class="h-5 w-5 mr-3 h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="라이트">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" />

</svg><span>라이트</span></button><button data-theme="dark" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none">
  <svg class="h-5 w-5 mr-3 h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="다크">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" />

</svg><span>다크</span></button><button data-theme="system" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none">
  <svg class="h-5 w-5 mr-3 h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="시스템">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.75 17L9 20l-1 1h8l-1-1-.75-3M3 13h18M5 17h14a2 2 0 002-2V5a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z" />

</svg><span>시스템</span></button></div>
</div>
      </div>
    </div>
  </div>
</header>


    <main class="mx-auto max-w-4xl px-4 py-6">
      
  
  <nav
  class="breadcrumb mb-4 md:mb-6 py-1"
  aria-label="경로">
  <ol class="text-muted-foreground flex items-center space-x-1 md:space-x-2 text-sm overflow-x-auto whitespace-nowrap scrollbar-hide py-1">
    
    <li class="flex-shrink-0">
      <a
        href="/"
        class="text-muted-foreground hover:text-primary hover:bg-primary/10 flex items-center gap-0.5 md:gap-1 rounded-lg px-1 md:px-3 py-0.5 md:py-1.5 transition-all duration-200 ease-out hover:-translate-y-0.5 hover:scale-[1.02]">
        
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="홈">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="m3 12 2-2m0 0 7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6" />

</svg>
        <span class="max-w-[4rem] md:max-w-none truncate">홈</span>
      </a>
    </li>

    
    
      <li class="flex items-center gap-1 md:gap-2 min-w-0">
        <span class="text-muted-foreground/50 flex-shrink-0"
          >
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
</svg>
        </span>

        
          
          <div class="flex items-center gap-1 md:gap-2 min-w-0">
            
              
              <a
                href="/posts"
                class="text-muted-foreground hover:text-primary hover:bg-primary/10 flex items-center gap-0.5 md:gap-1 rounded-lg px-1 md:px-3 py-0.5 md:py-1.5 transition-all duration-200 ease-out hover:-translate-y-0.5 hover:scale-[1.02] flex-shrink-0">
                
                  
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 20H5a2 2 0 01-2-2V6a2 2 0 012-2h10a2 2 0 012 2v1m2 13a2 2 0 01-2-2V7m2 13a2 2 0 002-2V9a2 2 0 00-2-2h-2m-4-3H9M7 16h6M7 8h6v4H7V8z" />

</svg>
                  <span class="max-w-[3rem] md:max-w-none truncate">게시글</span>
                
              </a>
              <span class="text-muted-foreground/50 flex-shrink-0"
                >
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
</svg></span
              >
            
            
            <span class="text-foreground flex items-center gap-0.5 md:gap-1 font-medium min-w-0">
              
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
</svg>
              <span class="max-w-[8rem] md:max-w-[16rem] lg:max-w-none truncate">TypedThinker: Typed Thinking Improves Large Language Model Reasoning</span>
            </span>
          </div>
        
      </li>
    

  </ol>
</nav>



  


  
  <header class="mb-8">
    


<div class="post-meta">
  
  <h1 class="text-foreground mb-6 text-3xl leading-tight font-bold md:text-4xl">
    TypedThinker: Typed Thinking Improves Large Language Model Reasoning
  </h1>

  
  


  
  <div class="bg-card border-border flex flex-col gap-4 rounded-xl border p-6">
    
    <div
      class="text-muted-foreground flex flex-wrap items-center gap-4 text-sm">
      
      <div class="flex items-center gap-2">
        
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="작성일"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z" />
</svg>
        <time datetime="2025-02-24">
          2025년 02월 24일
        </time>
      </div>

      
      


      
      
        <div class="flex items-center gap-2">
          
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="읽는 시간"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
</svg>
          <span
            >41 분</span
          >
        </div>
      


      
      
        <div class="flex items-center gap-2">
          
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="단어 수"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h7" />
</svg>
          <span>20528 단어</span>
        </div>
      

    </div>

    
    
      <div class="flex flex-wrap items-center gap-4">
        
        
          <div class="flex items-center gap-2">
            
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="카테고리"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 7v10a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-6l-2-2H5a2 2 0 00-2 2z" />
</svg>
            <span class="text-muted-foreground mr-2 text-sm"
              >카테고리:</span
            >
            <div class="flex flex-wrap gap-2">
              
                <a
                  href="/categories/paper-review/"
                  class="bg-primary/10 text-primary hover:bg-primary/20 focus:ring-primary/20 inline-flex items-center rounded-full px-3 py-1 text-sm font-medium transition-all duration-200 ease-out hover:-translate-y-0.5 hover:scale-105 hover:shadow-md focus:ring-2 focus:outline-none">
                  paper-review
                </a>
              
                <a
                  href="/categories/with-gpt/"
                  class="bg-primary/10 text-primary hover:bg-primary/20 focus:ring-primary/20 inline-flex items-center rounded-full px-3 py-1 text-sm font-medium transition-all duration-200 ease-out hover:-translate-y-0.5 hover:scale-105 hover:shadow-md focus:ring-2 focus:outline-none">
                  with-gpt
                </a>
              
                <a
                  href="/categories/ICLR2025/"
                  class="bg-primary/10 text-primary hover:bg-primary/20 focus:ring-primary/20 inline-flex items-center rounded-full px-3 py-1 text-sm font-medium transition-all duration-200 ease-out hover:-translate-y-0.5 hover:scale-105 hover:shadow-md focus:ring-2 focus:outline-none">
                  ICLR2025
                </a>
              
            </div>
          </div>
        


        
        

      </div>
    


    
    

  </div>
</div>

  </header>

  
  <article class="prose prose-neutral dark:prose-invert mb-12 max-w-none">
    <p><a href="https://arxiv.org/abs/2410.01952">논문 링크</a></p>
<h1 id="q--이-논문을-아주-자세하게-읽고-논문의-강점과-독창적인-지점을-설명해주고-핵심-알고리즘을-예시-입력을-들어서-전체적인-과정을-설명해줘-추가적으로-논문의-한계점에-대해서도-알려줘">Q : 이 논문을 아주 자세하게 읽고 논문의 강점과 독창적인 지점을 설명해주고 핵심 알고리즘을 예시 입력을 들어서 전체적인 과정을 설명해줘 추가적으로 논문의 한계점에 대해서도 알려줘</h1>
<h2 id="논문의-강점과-독창적인-지점">논문의 강점과 독창적인 지점</h2>
<h3 id="1-강점">1. <strong>강점</strong></h3>
<ul>
<li>
<p><strong>다양한 추론 방식의 활용</strong><br>
기존 LLM(대형 언어 모델)의 한계를 극복하기 위해 <strong>연역(deductive), 귀납(inductive), 가설(abductive), 유추(analogical)</strong> 네 가지의 논리적 추론 방식을 적용함.<br>
각각의 추론 방식이 특정 유형의 문제에서 효과적인지를 실험적으로 분석함.</p>
</li>
<li>
<p><strong>성능 향상 확인</strong><br>
네 가지 논리적 추론을 통합한 <strong>TypedThinker 모델</strong>이 기존의 Few-shot 및 Chain-of-Thought(CoT) 기반 모델보다 성능이 뛰어남을 입증.<br>
특히, <strong>Mistral 7B와 LLaMA3 8B에서 각각 3.4%와 16.7%의 성능 향상</strong>을 보임.</p>
</li>
<li>
<p><strong>자기 학습(Self-Training) 방식 적용</strong><br>
모델이 성공적인 추론 경험을 스스로 학습하여, **메타-추론기(Meta-thinker)**와 **추론기(Reasoner)**를 점진적으로 개선함.<br>
이를 통해 효과적인 추론 방식을 선택하고, 최적화된 추론을 수행할 수 있도록 함.</p>
</li>
<li>
<p><strong>일반화 성능 우수</strong><br>
기존 벤치마크(LogiQA, BBH, GSM8K, MATH)뿐만 아니라 새로운 벤치마크(ContextHub)에서도 성능 향상을 보임.<br>
또한, <strong>GPT-4o와 같은 강력한 모델에도 적용 가능</strong>, 더 강한 모델로의 일반화 가능성을 입증.</p>
</li>
</ul>
<hr>
<h3 id="2-독창적인-지점">2. <strong>독창적인 지점</strong></h3>
<table>
  <thead>
      <tr>
          <th>기존 접근 방식</th>
          <th>TypedThinker의 차별점</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>단일한 추론 방식(COT, 증분적 학습)</td>
          <td><strong>여러 개의 추론 방식을 조합</strong></td>
      </tr>
      <tr>
          <td>높은 Temperature를 통한 다양성 확보</td>
          <td><strong>추론 유형 자체의 다양성을 증가</strong></td>
      </tr>
      <tr>
          <td>수작업 피드백을 활용한 학습</td>
          <td><strong>모델이 스스로 효과적인 추론 방식을 학습</strong></td>
      </tr>
      <tr>
          <td>특정 유형(논리/수학) 문제 해결에 집중</td>
          <td><strong>다양한 문제 유형(LogiQA, BBH, GSM8K, MATH)에서 확장 가능</strong></td>
      </tr>
  </tbody>
</table>
<hr>
<h2 id="핵심-알고리즘-설명">핵심 알고리즘 설명</h2>
<h3 id="typedthinker의-주요-구성-요소"><strong>TypedThinker의 주요 구성 요소</strong></h3>
<ol>
<li>
<p><strong>메타-추론기(Meta-thinker)</strong></p>
<ul>
<li>주어진 문제를 분석하여 <strong>어떤 유형의 논리적 추론이 가장 적합한지 선택</strong></li>
<li>선택한 추론 방식에 따라 효과 점수(effectiveness score)를 할당</li>
</ul>
</li>
<li>
<p><strong>명시적 메모리(Explicit Memory)</strong></p>
<ul>
<li>기존에 성공했던 문제-해결 과정 데이터베이스를 구축</li>
<li>유사한 문제를 해결할 때 과거의 해결 과정을 참조하여 학습</li>
</ul>
</li>
<li>
<p><strong>추론기(Reasoner)</strong></p>
<ul>
<li>메타-추론기가 선택한 방식(연역, 귀납, 가설, 유추)을 적용하여 문제를 해결</li>
</ul>
</li>
</ol>
<hr>
<h3 id="예제-입력과-전체-과정"><strong>예제 입력과 전체 과정</strong></h3>
<h4 id="입력-예제-수학-문제"><strong>입력 예제</strong> (수학 문제)</h4>
<div
  class="code-block-container border-border bg-card my-6 overflow-hidden rounded-xl border shadow-sm transition-all duration-200 ease-out hover:-translate-y-0.5 hover:shadow-md">
  
  <div
    class="code-block-header bg-muted/30 border-border flex items-center justify-between border-b px-4 py-3">
    
    <div class="flex items-center gap-2">
      <div class="text-muted-foreground flex-shrink-0">
        
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4" />
</svg>
      </div>
      <span class="text-muted-foreground text-sm font-medium">
        PLAINTEXT
      </span>
    </div>

    
    <div class="flex items-center gap-2">
      <button
          class="collapse-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
          data-code-id="code-0"
          data-default-state="expanded"
          data-collapsed="false"
          data-auto-collapse-lines="30"
          data-auto-collapse-height="400"
          data-collapsed-height="120"
          title="접기"
          aria-label="접기">
          <span class="collapse-icon">
            
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path fill="currentColor" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z"/></svg>
          </span>
          <span class="collapse-text hidden sm:inline"
            >접기</span
          >
        </button>
      <button
        class="copy-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
        data-code-id="code-0"
        title="복사"
        aria-label="복사">
        <span class="copy-icon">
          
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
</svg>
        </span>
        <span class="copy-text hidden sm:inline"
          >복사</span
        >
      </button>
    </div>
  </div>

  
  <div class="code-block-content relative" id="code-0">
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">문제: John은 아버지보다 24살 어립니다. John과 그의 아버지의 나이 합이 68살일 때, John의 나이는 몇 살인가?</span></span></code></pre></div>
    
    <div
      class="collapse-overlay to-card/90 pointer-events-none absolute inset-0 bg-gradient-to-b from-transparent via-transparent opacity-0 transition-opacity duration-300">
      <div
        class="text-muted-foreground bg-card/80 border-border/50 hover:bg-primary/10 hover:text-primary hover:border-primary/30 absolute bottom-4 left-1/2 -translate-x-1/2 cursor-pointer rounded-full border px-3 py-1.5 text-xs backdrop-blur-sm transition-all duration-200">
        클릭하여 더 보기
      </div>
    </div>
  </div>
</div>


<script>
(function() {
  const codeId = 'code-0';
  const copyBtn = document.querySelector('.copy-code-btn[data-code-id="' + codeId + '"]');
  const collapseBtn = document.querySelector('.collapse-code-btn[data-code-id="' + codeId + '"]');
  const codeContainer = document.getElementById(codeId);

  if (!codeContainer) return;

  
  if (copyBtn) {
    const copyIcon = copyBtn.querySelector('.copy-icon');
    const copyText = copyBtn.querySelector('.copy-text');

    copyBtn.addEventListener('click', async function() {
      try {
        
        let codeText = '';

        
        const codeTableCell = codeContainer.querySelector('.lntd:last-child code');
        if (codeTableCell) {
          codeText = codeTableCell.textContent || codeTableCell.innerText;
        } else {
          
          const codeElement = codeContainer.querySelector('code');
          if (codeElement) {
            
            const hasInlineLineNumbers = codeElement.querySelector('.ln');
            if (hasInlineLineNumbers) {
              
              const codeLines = codeElement.querySelectorAll('.cl');
              if (codeLines.length > 0) {
                codeText = Array.from(codeLines)
                  .map(line => {
                    const text = line.textContent || line.innerText;
                    
                    return text.replace(/\n+$/, '');
                  })
                  .join('\n')
                  .replace(/\n+$/, ''); 
              } else {
                
                const allText = codeElement.textContent || codeElement.innerText;
                codeText = allText.replace(/^\d+/gm, '').replace(/^\s+/gm, '');
              }
            } else {
              
              codeText = codeElement.textContent || codeElement.innerText;
            }
          } else {
            
            codeText = codeContainer.textContent || codeContainer.innerText;
          }
        }

        
        codeText = codeText.trim();

        
        await navigator.clipboard.writeText(codeText);

        
        copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M5 13l4 4L19 7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (copyText) {
          copyText.textContent = '복사됨';
        }
        copyBtn.classList.add('text-green-600');

        
        setTimeout(() => {
          copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z\u0022 \/\u003e\n\u003c\/svg\u003e`;
          if (copyText) {
            copyText.textContent = '복사';
          }
          copyBtn.classList.remove('text-green-600');
        }, 2000);

      } catch (err) {
        console.error('复制失败:', err);

        
        const range = document.createRange();
        const codeElement = codeContainer.querySelector('code') || codeContainer;
        range.selectNodeContents(codeElement);
        const selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);

        
        if (copyText) {
          copyText.textContent = '선택됨';
        }

        setTimeout(() => {
          if (copyText) {
            copyText.textContent = '복사';
          }
          selection.removeAllRanges();
        }, 2000);
      }
    });
  }

  
  if (collapseBtn) {
    const collapseIcon = collapseBtn.querySelector('.collapse-icon');
    const collapseText = collapseBtn.querySelector('.collapse-text');
    const collapseOverlay = codeContainer.querySelector('.collapse-overlay');

    
    let codeElement = codeContainer.querySelector('pre.chroma');
    if (!codeElement) {
      codeElement = codeContainer.querySelector('pre');
    }

    const defaultState = collapseBtn.dataset.defaultState || 'expanded';
    const isCollapsedAttr = collapseBtn.dataset.collapsed === 'true';
    const autoCollapseLines = parseInt(collapseBtn.dataset.autoCollapseLines) || 30;
    const autoCollapseHeight = parseInt(collapseBtn.dataset.autoCollapseHeight) || 400;
    const collapsedHeight = parseInt(collapseBtn.dataset.collapsedHeight) || 120;

    let isCollapsed = false;

    
    function initCollapse() {
      
      const shouldCollapse = isCollapsedAttr ||
                           defaultState === 'collapsed' ||
                           shouldAutoCollapse();

      if (shouldCollapse) {
        setCollapsed(true, false); 
      }
    }

    function shouldAutoCollapse() {
      
      if (codeElement) {
        const lines = codeElement.querySelectorAll('.line, .cl');
        const height = codeElement.offsetHeight;
        return lines.length > autoCollapseLines || height > autoCollapseHeight;
      }

      
      const containerHeight = codeContainer.offsetHeight;
      if (containerHeight > autoCollapseHeight) {
        return true;
      }

      
      const textContent = codeContainer.textContent || codeContainer.innerText || '';
      const estimatedLines = textContent.split('\n').length;
      return estimatedLines > autoCollapseLines;
    }

    function setCollapsed(collapsed, animate = true) {
      if (!collapseOverlay) return;

      isCollapsed = collapsed;

      if (collapsed) {
        
        codeContainer.style.maxHeight = collapsedHeight + 'px';
        codeContainer.style.overflow = 'hidden';
        collapseOverlay.style.opacity = '1';
        collapseOverlay.style.pointerEvents = 'auto';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M19 9l-7 7-7-7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '펼치기';
        }
        collapseBtn.title = '펼치기';

      } else {
        
        codeContainer.style.maxHeight = '';
        codeContainer.style.overflow = '';
        collapseOverlay.style.opacity = '0';
        collapseOverlay.style.pointerEvents = 'none';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath fill=\u0022currentColor\u0022 d=\u0022M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z\u0022\/\u003e\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '접기';
        }
        collapseBtn.title = '접기';
      }

      
      if (animate) {
        codeContainer.style.transition = 'max-height 0.3s ease-out';
        setTimeout(() => {
          codeContainer.style.transition = '';
        }, 300);
      }
    }

    function toggleCollapse() {
      setCollapsed(!isCollapsed, true);
    }

    
    collapseBtn.addEventListener('click', toggleCollapse);

    
    if (collapseOverlay) {
      collapseOverlay.addEventListener('click', () => {
        if (isCollapsed) {
          setCollapsed(false, true);
        }
      });
    }

    
    initCollapse();
  }
})();
</script>
<h4 id="typedthinker의-해결-과정"><strong>TypedThinker의 해결 과정</strong></h4>
<ol>
<li>
<p><strong>메타-추론기 작동</strong></p>
<ul>
<li>주어진 문제를 분석하여 **&ldquo;가설적 추론(Abductive Reasoning)&rdquo;**이 적절하다고 판단</li>
<li>효과 점수:
<div
  class="code-block-container border-border bg-card my-6 overflow-hidden rounded-xl border shadow-sm transition-all duration-200 ease-out hover:-translate-y-0.5 hover:shadow-md">
  
  <div
    class="code-block-header bg-muted/30 border-border flex items-center justify-between border-b px-4 py-3">
    
    <div class="flex items-center gap-2">
      <div class="text-muted-foreground flex-shrink-0">
        
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4" />
</svg>
      </div>
      <span class="text-muted-foreground text-sm font-medium">
        PLAINTEXT
      </span>
    </div>

    
    <div class="flex items-center gap-2">
      <button
          class="collapse-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
          data-code-id="code-1"
          data-default-state="expanded"
          data-collapsed="false"
          data-auto-collapse-lines="30"
          data-auto-collapse-height="400"
          data-collapsed-height="120"
          title="접기"
          aria-label="접기">
          <span class="collapse-icon">
            
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path fill="currentColor" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z"/></svg>
          </span>
          <span class="collapse-text hidden sm:inline"
            >접기</span
          >
        </button>
      <button
        class="copy-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
        data-code-id="code-1"
        title="복사"
        aria-label="복사">
        <span class="copy-icon">
          
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
</svg>
        </span>
        <span class="copy-text hidden sm:inline"
          >복사</span
        >
      </button>
    </div>
  </div>

  
  <div class="code-block-content relative" id="code-1">
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">Deductive: 0.4, Inductive: 0.5, Analogical: 0.4, Abductive: 0.6</span></span></code></pre></div>
    
    <div
      class="collapse-overlay to-card/90 pointer-events-none absolute inset-0 bg-gradient-to-b from-transparent via-transparent opacity-0 transition-opacity duration-300">
      <div
        class="text-muted-foreground bg-card/80 border-border/50 hover:bg-primary/10 hover:text-primary hover:border-primary/30 absolute bottom-4 left-1/2 -translate-x-1/2 cursor-pointer rounded-full border px-3 py-1.5 text-xs backdrop-blur-sm transition-all duration-200">
        클릭하여 더 보기
      </div>
    </div>
  </div>
</div>


<script>
(function() {
  const codeId = 'code-1';
  const copyBtn = document.querySelector('.copy-code-btn[data-code-id="' + codeId + '"]');
  const collapseBtn = document.querySelector('.collapse-code-btn[data-code-id="' + codeId + '"]');
  const codeContainer = document.getElementById(codeId);

  if (!codeContainer) return;

  
  if (copyBtn) {
    const copyIcon = copyBtn.querySelector('.copy-icon');
    const copyText = copyBtn.querySelector('.copy-text');

    copyBtn.addEventListener('click', async function() {
      try {
        
        let codeText = '';

        
        const codeTableCell = codeContainer.querySelector('.lntd:last-child code');
        if (codeTableCell) {
          codeText = codeTableCell.textContent || codeTableCell.innerText;
        } else {
          
          const codeElement = codeContainer.querySelector('code');
          if (codeElement) {
            
            const hasInlineLineNumbers = codeElement.querySelector('.ln');
            if (hasInlineLineNumbers) {
              
              const codeLines = codeElement.querySelectorAll('.cl');
              if (codeLines.length > 0) {
                codeText = Array.from(codeLines)
                  .map(line => {
                    const text = line.textContent || line.innerText;
                    
                    return text.replace(/\n+$/, '');
                  })
                  .join('\n')
                  .replace(/\n+$/, ''); 
              } else {
                
                const allText = codeElement.textContent || codeElement.innerText;
                codeText = allText.replace(/^\d+/gm, '').replace(/^\s+/gm, '');
              }
            } else {
              
              codeText = codeElement.textContent || codeElement.innerText;
            }
          } else {
            
            codeText = codeContainer.textContent || codeContainer.innerText;
          }
        }

        
        codeText = codeText.trim();

        
        await navigator.clipboard.writeText(codeText);

        
        copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M5 13l4 4L19 7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (copyText) {
          copyText.textContent = '복사됨';
        }
        copyBtn.classList.add('text-green-600');

        
        setTimeout(() => {
          copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z\u0022 \/\u003e\n\u003c\/svg\u003e`;
          if (copyText) {
            copyText.textContent = '복사';
          }
          copyBtn.classList.remove('text-green-600');
        }, 2000);

      } catch (err) {
        console.error('复制失败:', err);

        
        const range = document.createRange();
        const codeElement = codeContainer.querySelector('code') || codeContainer;
        range.selectNodeContents(codeElement);
        const selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);

        
        if (copyText) {
          copyText.textContent = '선택됨';
        }

        setTimeout(() => {
          if (copyText) {
            copyText.textContent = '복사';
          }
          selection.removeAllRanges();
        }, 2000);
      }
    });
  }

  
  if (collapseBtn) {
    const collapseIcon = collapseBtn.querySelector('.collapse-icon');
    const collapseText = collapseBtn.querySelector('.collapse-text');
    const collapseOverlay = codeContainer.querySelector('.collapse-overlay');

    
    let codeElement = codeContainer.querySelector('pre.chroma');
    if (!codeElement) {
      codeElement = codeContainer.querySelector('pre');
    }

    const defaultState = collapseBtn.dataset.defaultState || 'expanded';
    const isCollapsedAttr = collapseBtn.dataset.collapsed === 'true';
    const autoCollapseLines = parseInt(collapseBtn.dataset.autoCollapseLines) || 30;
    const autoCollapseHeight = parseInt(collapseBtn.dataset.autoCollapseHeight) || 400;
    const collapsedHeight = parseInt(collapseBtn.dataset.collapsedHeight) || 120;

    let isCollapsed = false;

    
    function initCollapse() {
      
      const shouldCollapse = isCollapsedAttr ||
                           defaultState === 'collapsed' ||
                           shouldAutoCollapse();

      if (shouldCollapse) {
        setCollapsed(true, false); 
      }
    }

    function shouldAutoCollapse() {
      
      if (codeElement) {
        const lines = codeElement.querySelectorAll('.line, .cl');
        const height = codeElement.offsetHeight;
        return lines.length > autoCollapseLines || height > autoCollapseHeight;
      }

      
      const containerHeight = codeContainer.offsetHeight;
      if (containerHeight > autoCollapseHeight) {
        return true;
      }

      
      const textContent = codeContainer.textContent || codeContainer.innerText || '';
      const estimatedLines = textContent.split('\n').length;
      return estimatedLines > autoCollapseLines;
    }

    function setCollapsed(collapsed, animate = true) {
      if (!collapseOverlay) return;

      isCollapsed = collapsed;

      if (collapsed) {
        
        codeContainer.style.maxHeight = collapsedHeight + 'px';
        codeContainer.style.overflow = 'hidden';
        collapseOverlay.style.opacity = '1';
        collapseOverlay.style.pointerEvents = 'auto';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M19 9l-7 7-7-7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '펼치기';
        }
        collapseBtn.title = '펼치기';

      } else {
        
        codeContainer.style.maxHeight = '';
        codeContainer.style.overflow = '';
        collapseOverlay.style.opacity = '0';
        collapseOverlay.style.pointerEvents = 'none';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath fill=\u0022currentColor\u0022 d=\u0022M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z\u0022\/\u003e\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '접기';
        }
        collapseBtn.title = '접기';
      }

      
      if (animate) {
        codeContainer.style.transition = 'max-height 0.3s ease-out';
        setTimeout(() => {
          codeContainer.style.transition = '';
        }, 300);
      }
    }

    function toggleCollapse() {
      setCollapsed(!isCollapsed, true);
    }

    
    collapseBtn.addEventListener('click', toggleCollapse);

    
    if (collapseOverlay) {
      collapseOverlay.addEventListener('click', () => {
        if (isCollapsed) {
          setCollapsed(false, true);
        }
      });
    }

    
    initCollapse();
  }
})();
</script>
</li>
</ul>
</li>
<li>
<p><strong>명시적 메모리 검색</strong></p>
<ul>
<li>기존의 유사한 문제 검색</li>
<li>예제:
<div
  class="code-block-container border-border bg-card my-6 overflow-hidden rounded-xl border shadow-sm transition-all duration-200 ease-out hover:-translate-y-0.5 hover:shadow-md">
  
  <div
    class="code-block-header bg-muted/30 border-border flex items-center justify-between border-b px-4 py-3">
    
    <div class="flex items-center gap-2">
      <div class="text-muted-foreground flex-shrink-0">
        
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4" />
</svg>
      </div>
      <span class="text-muted-foreground text-sm font-medium">
        PLAINTEXT
      </span>
    </div>

    
    <div class="flex items-center gap-2">
      <button
          class="collapse-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
          data-code-id="code-2"
          data-default-state="expanded"
          data-collapsed="false"
          data-auto-collapse-lines="30"
          data-auto-collapse-height="400"
          data-collapsed-height="120"
          title="접기"
          aria-label="접기">
          <span class="collapse-icon">
            
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path fill="currentColor" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z"/></svg>
          </span>
          <span class="collapse-text hidden sm:inline"
            >접기</span
          >
        </button>
      <button
        class="copy-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
        data-code-id="code-2"
        title="복사"
        aria-label="복사">
        <span class="copy-icon">
          
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
</svg>
        </span>
        <span class="copy-text hidden sm:inline"
          >복사</span
        >
      </button>
    </div>
  </div>

  
  <div class="code-block-content relative" id="code-2">
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">문제: Lisa는 어머니보다 10살 어립니다. 두 사람의 나이 합이 70살일 때, Lisa의 나이는 몇 살인가?
</span></span><span class="line"><span class="ln">2</span><span class="cl">해결 방법: Lisa = (70 - 10) / 2 = 30살</span></span></code></pre></div>
    
    <div
      class="collapse-overlay to-card/90 pointer-events-none absolute inset-0 bg-gradient-to-b from-transparent via-transparent opacity-0 transition-opacity duration-300">
      <div
        class="text-muted-foreground bg-card/80 border-border/50 hover:bg-primary/10 hover:text-primary hover:border-primary/30 absolute bottom-4 left-1/2 -translate-x-1/2 cursor-pointer rounded-full border px-3 py-1.5 text-xs backdrop-blur-sm transition-all duration-200">
        클릭하여 더 보기
      </div>
    </div>
  </div>
</div>


<script>
(function() {
  const codeId = 'code-2';
  const copyBtn = document.querySelector('.copy-code-btn[data-code-id="' + codeId + '"]');
  const collapseBtn = document.querySelector('.collapse-code-btn[data-code-id="' + codeId + '"]');
  const codeContainer = document.getElementById(codeId);

  if (!codeContainer) return;

  
  if (copyBtn) {
    const copyIcon = copyBtn.querySelector('.copy-icon');
    const copyText = copyBtn.querySelector('.copy-text');

    copyBtn.addEventListener('click', async function() {
      try {
        
        let codeText = '';

        
        const codeTableCell = codeContainer.querySelector('.lntd:last-child code');
        if (codeTableCell) {
          codeText = codeTableCell.textContent || codeTableCell.innerText;
        } else {
          
          const codeElement = codeContainer.querySelector('code');
          if (codeElement) {
            
            const hasInlineLineNumbers = codeElement.querySelector('.ln');
            if (hasInlineLineNumbers) {
              
              const codeLines = codeElement.querySelectorAll('.cl');
              if (codeLines.length > 0) {
                codeText = Array.from(codeLines)
                  .map(line => {
                    const text = line.textContent || line.innerText;
                    
                    return text.replace(/\n+$/, '');
                  })
                  .join('\n')
                  .replace(/\n+$/, ''); 
              } else {
                
                const allText = codeElement.textContent || codeElement.innerText;
                codeText = allText.replace(/^\d+/gm, '').replace(/^\s+/gm, '');
              }
            } else {
              
              codeText = codeElement.textContent || codeElement.innerText;
            }
          } else {
            
            codeText = codeContainer.textContent || codeContainer.innerText;
          }
        }

        
        codeText = codeText.trim();

        
        await navigator.clipboard.writeText(codeText);

        
        copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M5 13l4 4L19 7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (copyText) {
          copyText.textContent = '복사됨';
        }
        copyBtn.classList.add('text-green-600');

        
        setTimeout(() => {
          copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z\u0022 \/\u003e\n\u003c\/svg\u003e`;
          if (copyText) {
            copyText.textContent = '복사';
          }
          copyBtn.classList.remove('text-green-600');
        }, 2000);

      } catch (err) {
        console.error('复制失败:', err);

        
        const range = document.createRange();
        const codeElement = codeContainer.querySelector('code') || codeContainer;
        range.selectNodeContents(codeElement);
        const selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);

        
        if (copyText) {
          copyText.textContent = '선택됨';
        }

        setTimeout(() => {
          if (copyText) {
            copyText.textContent = '복사';
          }
          selection.removeAllRanges();
        }, 2000);
      }
    });
  }

  
  if (collapseBtn) {
    const collapseIcon = collapseBtn.querySelector('.collapse-icon');
    const collapseText = collapseBtn.querySelector('.collapse-text');
    const collapseOverlay = codeContainer.querySelector('.collapse-overlay');

    
    let codeElement = codeContainer.querySelector('pre.chroma');
    if (!codeElement) {
      codeElement = codeContainer.querySelector('pre');
    }

    const defaultState = collapseBtn.dataset.defaultState || 'expanded';
    const isCollapsedAttr = collapseBtn.dataset.collapsed === 'true';
    const autoCollapseLines = parseInt(collapseBtn.dataset.autoCollapseLines) || 30;
    const autoCollapseHeight = parseInt(collapseBtn.dataset.autoCollapseHeight) || 400;
    const collapsedHeight = parseInt(collapseBtn.dataset.collapsedHeight) || 120;

    let isCollapsed = false;

    
    function initCollapse() {
      
      const shouldCollapse = isCollapsedAttr ||
                           defaultState === 'collapsed' ||
                           shouldAutoCollapse();

      if (shouldCollapse) {
        setCollapsed(true, false); 
      }
    }

    function shouldAutoCollapse() {
      
      if (codeElement) {
        const lines = codeElement.querySelectorAll('.line, .cl');
        const height = codeElement.offsetHeight;
        return lines.length > autoCollapseLines || height > autoCollapseHeight;
      }

      
      const containerHeight = codeContainer.offsetHeight;
      if (containerHeight > autoCollapseHeight) {
        return true;
      }

      
      const textContent = codeContainer.textContent || codeContainer.innerText || '';
      const estimatedLines = textContent.split('\n').length;
      return estimatedLines > autoCollapseLines;
    }

    function setCollapsed(collapsed, animate = true) {
      if (!collapseOverlay) return;

      isCollapsed = collapsed;

      if (collapsed) {
        
        codeContainer.style.maxHeight = collapsedHeight + 'px';
        codeContainer.style.overflow = 'hidden';
        collapseOverlay.style.opacity = '1';
        collapseOverlay.style.pointerEvents = 'auto';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M19 9l-7 7-7-7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '펼치기';
        }
        collapseBtn.title = '펼치기';

      } else {
        
        codeContainer.style.maxHeight = '';
        codeContainer.style.overflow = '';
        collapseOverlay.style.opacity = '0';
        collapseOverlay.style.pointerEvents = 'none';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath fill=\u0022currentColor\u0022 d=\u0022M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z\u0022\/\u003e\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '접기';
        }
        collapseBtn.title = '접기';
      }

      
      if (animate) {
        codeContainer.style.transition = 'max-height 0.3s ease-out';
        setTimeout(() => {
          codeContainer.style.transition = '';
        }, 300);
      }
    }

    function toggleCollapse() {
      setCollapsed(!isCollapsed, true);
    }

    
    collapseBtn.addEventListener('click', toggleCollapse);

    
    if (collapseOverlay) {
      collapseOverlay.addEventListener('click', () => {
        if (isCollapsed) {
          setCollapsed(false, true);
        }
      });
    }

    
    initCollapse();
  }
})();
</script>
</li>
</ul>
</li>
<li>
<p><strong>추론기 적용</strong></p>
<ul>
<li>선택된 가설적 추론을 적용</li>
<li><code>x + (x + 24) = 68</code>을 풀이</li>
<li><code>2x + 24 = 68</code> → <code>2x = 44</code> → <code>x = 22</code></li>
<li>정답: <strong>John은 22살이다.</strong></li>
</ul>
</li>
</ol>
<hr>
<h2 id="논문의-한계점">논문의 한계점</h2>
<ol>
<li>
<p><strong>단일한 추론 유형 적용의 한계</strong></p>
<ul>
<li>특정 문제에서는 하나의 논리적 추론 방식만으로는 해결이 어렵고, <strong>복합적인 논리적 추론 과정이 필요</strong></li>
<li>예를 들어, 수학 문제에서는 귀납적 접근 후 연역적 추론이 필요할 수 있음.</li>
</ul>
</li>
<li>
<p><strong>특정 도메인에 대한 확장 필요</strong></p>
<ul>
<li>논리 및 수학 문제 외에 <strong>상식적 추론(common sense reasoning)이나 창의적 문제 해결(creative problem-solving)에도 적용 가능할지 추가 연구 필요</strong></li>
</ul>
</li>
<li>
<p><strong>메모리 검색 방식의 한계</strong></p>
<ul>
<li>문제 유사성을 판단하는 방법으로 <strong>코사인 유사도</strong>를 사용하지만, 이는 복잡한 문제에서는 비효율적일 가능성 있음.</li>
<li>좀 더 정교한 검색 방식이나 강화 학습을 활용한 최적화 가능성 존재.</li>
</ul>
</li>
</ol>
<hr>
<h2 id="결론">결론</h2>
<p>TypedThinker는 기존 LLM이 단일한 추론 방식에 의존하는 문제를 해결하기 위해 <strong>다양한 논리적 추론 유형을 조합</strong>하는 접근 방식을 제안함.<br>
이를 통해 <strong>모델이 보다 유연하게 다양한 문제를 해결할 수 있도록 설계</strong>되었으며, <strong>다양한 벤치마크에서의 성능 향상을 입증</strong>함.<br>
그러나 <strong>복합적인 추론 방식의 조합, 새로운 도메인 확장, 더 정교한 메모리 검색 방식</strong> 등의 개선이 필요함.</p>
<h1 id="q--논문의-핵심알고리즘을-예시를-들어-아주-자세하게-설명해주고-정리해-줘">Q : 논문의 핵심알고리즘을 예시를 들어 아주 자세하게 설명해주고 정리해 줘</h1>
<h2 id="논문의-핵심-알고리즘-typedthinker-상세-설명"><strong>논문의 핵심 알고리즘 (TypedThinker) 상세 설명</strong></h2>
<p>논문의 핵심 알고리즘인 <strong>TypedThinker</strong>는 대형 언어 모델(LLM)이 다양한 추론 방식을 적용하여 문제 해결을 할 수 있도록 설계된 프레임워크입니다.<br>
이 알고리즘의 목표는 <strong>LLM이 연역(deductive), 귀납(inductive), 가설(abductive), 유추(analogical)라는 4가지 유형의 논리적 추론을 활용하여 더 정확하고 다각적인 사고를 수행하도록 하는 것</strong>입니다.</p>
<h3 id="1-typedthinker의-주요-구성-요소"><strong>1. TypedThinker의 주요 구성 요소</strong></h3>
<p>TypedThinker는 크게 **메타-추론기(Meta-thinker), 명시적 메모리(Explicit Memory), 추론기(Reasoner)**라는 3가지 요소로 구성됩니다.</p>
<table>
  <thead>
      <tr>
          <th>구성 요소</th>
          <th>역할</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>메타-추론기 (Meta-thinker)</strong></td>
          <td>문제를 분석하여 적절한 추론 유형을 선택</td>
      </tr>
      <tr>
          <td><strong>명시적 메모리 (Explicit Memory)</strong></td>
          <td>과거 성공적인 해결 경험을 저장하고 검색</td>
      </tr>
      <tr>
          <td><strong>추론기 (Reasoner)</strong></td>
          <td>선택된 추론 유형을 활용하여 문제를 해결</td>
      </tr>
  </tbody>
</table>
<hr>
<h2 id="2-typedthinker의-전체-알고리즘-과정"><strong>2. TypedThinker의 전체 알고리즘 과정</strong></h2>
<h3 id="step-1-문제-입력"><strong>Step 1: 문제 입력</strong></h3>
<p>사용자로부터 문제가 주어짐.</p>
<p><strong>예제 문제 (수학 문제)</strong></p>
<div
  class="code-block-container border-border bg-card my-6 overflow-hidden rounded-xl border shadow-sm transition-all duration-200 ease-out hover:-translate-y-0.5 hover:shadow-md">
  
  <div
    class="code-block-header bg-muted/30 border-border flex items-center justify-between border-b px-4 py-3">
    
    <div class="flex items-center gap-2">
      <div class="text-muted-foreground flex-shrink-0">
        
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4" />
</svg>
      </div>
      <span class="text-muted-foreground text-sm font-medium">
        PLAINTEXT
      </span>
    </div>

    
    <div class="flex items-center gap-2">
      <button
          class="collapse-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
          data-code-id="code-3"
          data-default-state="expanded"
          data-collapsed="false"
          data-auto-collapse-lines="30"
          data-auto-collapse-height="400"
          data-collapsed-height="120"
          title="접기"
          aria-label="접기">
          <span class="collapse-icon">
            
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path fill="currentColor" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z"/></svg>
          </span>
          <span class="collapse-text hidden sm:inline"
            >접기</span
          >
        </button>
      <button
        class="copy-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
        data-code-id="code-3"
        title="복사"
        aria-label="복사">
        <span class="copy-icon">
          
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
</svg>
        </span>
        <span class="copy-text hidden sm:inline"
          >복사</span
        >
      </button>
    </div>
  </div>

  
  <div class="code-block-content relative" id="code-3">
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">문제: John은 아버지보다 24살 어립니다. John과 그의 아버지의 나이 합이 68살일 때, John의 나이는 몇 살인가?</span></span></code></pre></div>
    
    <div
      class="collapse-overlay to-card/90 pointer-events-none absolute inset-0 bg-gradient-to-b from-transparent via-transparent opacity-0 transition-opacity duration-300">
      <div
        class="text-muted-foreground bg-card/80 border-border/50 hover:bg-primary/10 hover:text-primary hover:border-primary/30 absolute bottom-4 left-1/2 -translate-x-1/2 cursor-pointer rounded-full border px-3 py-1.5 text-xs backdrop-blur-sm transition-all duration-200">
        클릭하여 더 보기
      </div>
    </div>
  </div>
</div>


<script>
(function() {
  const codeId = 'code-3';
  const copyBtn = document.querySelector('.copy-code-btn[data-code-id="' + codeId + '"]');
  const collapseBtn = document.querySelector('.collapse-code-btn[data-code-id="' + codeId + '"]');
  const codeContainer = document.getElementById(codeId);

  if (!codeContainer) return;

  
  if (copyBtn) {
    const copyIcon = copyBtn.querySelector('.copy-icon');
    const copyText = copyBtn.querySelector('.copy-text');

    copyBtn.addEventListener('click', async function() {
      try {
        
        let codeText = '';

        
        const codeTableCell = codeContainer.querySelector('.lntd:last-child code');
        if (codeTableCell) {
          codeText = codeTableCell.textContent || codeTableCell.innerText;
        } else {
          
          const codeElement = codeContainer.querySelector('code');
          if (codeElement) {
            
            const hasInlineLineNumbers = codeElement.querySelector('.ln');
            if (hasInlineLineNumbers) {
              
              const codeLines = codeElement.querySelectorAll('.cl');
              if (codeLines.length > 0) {
                codeText = Array.from(codeLines)
                  .map(line => {
                    const text = line.textContent || line.innerText;
                    
                    return text.replace(/\n+$/, '');
                  })
                  .join('\n')
                  .replace(/\n+$/, ''); 
              } else {
                
                const allText = codeElement.textContent || codeElement.innerText;
                codeText = allText.replace(/^\d+/gm, '').replace(/^\s+/gm, '');
              }
            } else {
              
              codeText = codeElement.textContent || codeElement.innerText;
            }
          } else {
            
            codeText = codeContainer.textContent || codeContainer.innerText;
          }
        }

        
        codeText = codeText.trim();

        
        await navigator.clipboard.writeText(codeText);

        
        copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M5 13l4 4L19 7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (copyText) {
          copyText.textContent = '복사됨';
        }
        copyBtn.classList.add('text-green-600');

        
        setTimeout(() => {
          copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z\u0022 \/\u003e\n\u003c\/svg\u003e`;
          if (copyText) {
            copyText.textContent = '복사';
          }
          copyBtn.classList.remove('text-green-600');
        }, 2000);

      } catch (err) {
        console.error('复制失败:', err);

        
        const range = document.createRange();
        const codeElement = codeContainer.querySelector('code') || codeContainer;
        range.selectNodeContents(codeElement);
        const selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);

        
        if (copyText) {
          copyText.textContent = '선택됨';
        }

        setTimeout(() => {
          if (copyText) {
            copyText.textContent = '복사';
          }
          selection.removeAllRanges();
        }, 2000);
      }
    });
  }

  
  if (collapseBtn) {
    const collapseIcon = collapseBtn.querySelector('.collapse-icon');
    const collapseText = collapseBtn.querySelector('.collapse-text');
    const collapseOverlay = codeContainer.querySelector('.collapse-overlay');

    
    let codeElement = codeContainer.querySelector('pre.chroma');
    if (!codeElement) {
      codeElement = codeContainer.querySelector('pre');
    }

    const defaultState = collapseBtn.dataset.defaultState || 'expanded';
    const isCollapsedAttr = collapseBtn.dataset.collapsed === 'true';
    const autoCollapseLines = parseInt(collapseBtn.dataset.autoCollapseLines) || 30;
    const autoCollapseHeight = parseInt(collapseBtn.dataset.autoCollapseHeight) || 400;
    const collapsedHeight = parseInt(collapseBtn.dataset.collapsedHeight) || 120;

    let isCollapsed = false;

    
    function initCollapse() {
      
      const shouldCollapse = isCollapsedAttr ||
                           defaultState === 'collapsed' ||
                           shouldAutoCollapse();

      if (shouldCollapse) {
        setCollapsed(true, false); 
      }
    }

    function shouldAutoCollapse() {
      
      if (codeElement) {
        const lines = codeElement.querySelectorAll('.line, .cl');
        const height = codeElement.offsetHeight;
        return lines.length > autoCollapseLines || height > autoCollapseHeight;
      }

      
      const containerHeight = codeContainer.offsetHeight;
      if (containerHeight > autoCollapseHeight) {
        return true;
      }

      
      const textContent = codeContainer.textContent || codeContainer.innerText || '';
      const estimatedLines = textContent.split('\n').length;
      return estimatedLines > autoCollapseLines;
    }

    function setCollapsed(collapsed, animate = true) {
      if (!collapseOverlay) return;

      isCollapsed = collapsed;

      if (collapsed) {
        
        codeContainer.style.maxHeight = collapsedHeight + 'px';
        codeContainer.style.overflow = 'hidden';
        collapseOverlay.style.opacity = '1';
        collapseOverlay.style.pointerEvents = 'auto';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M19 9l-7 7-7-7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '펼치기';
        }
        collapseBtn.title = '펼치기';

      } else {
        
        codeContainer.style.maxHeight = '';
        codeContainer.style.overflow = '';
        collapseOverlay.style.opacity = '0';
        collapseOverlay.style.pointerEvents = 'none';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath fill=\u0022currentColor\u0022 d=\u0022M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z\u0022\/\u003e\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '접기';
        }
        collapseBtn.title = '접기';
      }

      
      if (animate) {
        codeContainer.style.transition = 'max-height 0.3s ease-out';
        setTimeout(() => {
          codeContainer.style.transition = '';
        }, 300);
      }
    }

    function toggleCollapse() {
      setCollapsed(!isCollapsed, true);
    }

    
    collapseBtn.addEventListener('click', toggleCollapse);

    
    if (collapseOverlay) {
      collapseOverlay.addEventListener('click', () => {
        if (isCollapsed) {
          setCollapsed(false, true);
        }
      });
    }

    
    initCollapse();
  }
})();
</script>
<hr>
<h3 id="step-2-메타-추론기meta-thinker가-적절한-추론-방식-선택"><strong>Step 2: 메타-추론기(Meta-thinker)가 적절한 추론 방식 선택</strong></h3>
<p>메타-추론기는 주어진 문제를 분석하고, <strong>어떤 논리적 추론 방식이 가장 적합한지 판단</strong>함.<br>
이때, 각각의 추론 방식에 대해 **효과 점수(effectiveness score)**를 계산함.</p>
<p>📌 <strong>추론 방식별 점수 예시</strong></p>
<div
  class="code-block-container border-border bg-card my-6 overflow-hidden rounded-xl border shadow-sm transition-all duration-200 ease-out hover:-translate-y-0.5 hover:shadow-md">
  
  <div
    class="code-block-header bg-muted/30 border-border flex items-center justify-between border-b px-4 py-3">
    
    <div class="flex items-center gap-2">
      <div class="text-muted-foreground flex-shrink-0">
        
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4" />
</svg>
      </div>
      <span class="text-muted-foreground text-sm font-medium">
        PLAINTEXT
      </span>
    </div>

    
    <div class="flex items-center gap-2">
      <button
          class="collapse-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
          data-code-id="code-4"
          data-default-state="expanded"
          data-collapsed="false"
          data-auto-collapse-lines="30"
          data-auto-collapse-height="400"
          data-collapsed-height="120"
          title="접기"
          aria-label="접기">
          <span class="collapse-icon">
            
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path fill="currentColor" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z"/></svg>
          </span>
          <span class="collapse-text hidden sm:inline"
            >접기</span
          >
        </button>
      <button
        class="copy-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
        data-code-id="code-4"
        title="복사"
        aria-label="복사">
        <span class="copy-icon">
          
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
</svg>
        </span>
        <span class="copy-text hidden sm:inline"
          >복사</span
        >
      </button>
    </div>
  </div>

  
  <div class="code-block-content relative" id="code-4">
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">Deductive: 0.4, Inductive: 0.5, Analogical: 0.4, Abductive: 0.6</span></span></code></pre></div>
    
    <div
      class="collapse-overlay to-card/90 pointer-events-none absolute inset-0 bg-gradient-to-b from-transparent via-transparent opacity-0 transition-opacity duration-300">
      <div
        class="text-muted-foreground bg-card/80 border-border/50 hover:bg-primary/10 hover:text-primary hover:border-primary/30 absolute bottom-4 left-1/2 -translate-x-1/2 cursor-pointer rounded-full border px-3 py-1.5 text-xs backdrop-blur-sm transition-all duration-200">
        클릭하여 더 보기
      </div>
    </div>
  </div>
</div>


<script>
(function() {
  const codeId = 'code-4';
  const copyBtn = document.querySelector('.copy-code-btn[data-code-id="' + codeId + '"]');
  const collapseBtn = document.querySelector('.collapse-code-btn[data-code-id="' + codeId + '"]');
  const codeContainer = document.getElementById(codeId);

  if (!codeContainer) return;

  
  if (copyBtn) {
    const copyIcon = copyBtn.querySelector('.copy-icon');
    const copyText = copyBtn.querySelector('.copy-text');

    copyBtn.addEventListener('click', async function() {
      try {
        
        let codeText = '';

        
        const codeTableCell = codeContainer.querySelector('.lntd:last-child code');
        if (codeTableCell) {
          codeText = codeTableCell.textContent || codeTableCell.innerText;
        } else {
          
          const codeElement = codeContainer.querySelector('code');
          if (codeElement) {
            
            const hasInlineLineNumbers = codeElement.querySelector('.ln');
            if (hasInlineLineNumbers) {
              
              const codeLines = codeElement.querySelectorAll('.cl');
              if (codeLines.length > 0) {
                codeText = Array.from(codeLines)
                  .map(line => {
                    const text = line.textContent || line.innerText;
                    
                    return text.replace(/\n+$/, '');
                  })
                  .join('\n')
                  .replace(/\n+$/, ''); 
              } else {
                
                const allText = codeElement.textContent || codeElement.innerText;
                codeText = allText.replace(/^\d+/gm, '').replace(/^\s+/gm, '');
              }
            } else {
              
              codeText = codeElement.textContent || codeElement.innerText;
            }
          } else {
            
            codeText = codeContainer.textContent || codeContainer.innerText;
          }
        }

        
        codeText = codeText.trim();

        
        await navigator.clipboard.writeText(codeText);

        
        copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M5 13l4 4L19 7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (copyText) {
          copyText.textContent = '복사됨';
        }
        copyBtn.classList.add('text-green-600');

        
        setTimeout(() => {
          copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z\u0022 \/\u003e\n\u003c\/svg\u003e`;
          if (copyText) {
            copyText.textContent = '복사';
          }
          copyBtn.classList.remove('text-green-600');
        }, 2000);

      } catch (err) {
        console.error('复制失败:', err);

        
        const range = document.createRange();
        const codeElement = codeContainer.querySelector('code') || codeContainer;
        range.selectNodeContents(codeElement);
        const selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);

        
        if (copyText) {
          copyText.textContent = '선택됨';
        }

        setTimeout(() => {
          if (copyText) {
            copyText.textContent = '복사';
          }
          selection.removeAllRanges();
        }, 2000);
      }
    });
  }

  
  if (collapseBtn) {
    const collapseIcon = collapseBtn.querySelector('.collapse-icon');
    const collapseText = collapseBtn.querySelector('.collapse-text');
    const collapseOverlay = codeContainer.querySelector('.collapse-overlay');

    
    let codeElement = codeContainer.querySelector('pre.chroma');
    if (!codeElement) {
      codeElement = codeContainer.querySelector('pre');
    }

    const defaultState = collapseBtn.dataset.defaultState || 'expanded';
    const isCollapsedAttr = collapseBtn.dataset.collapsed === 'true';
    const autoCollapseLines = parseInt(collapseBtn.dataset.autoCollapseLines) || 30;
    const autoCollapseHeight = parseInt(collapseBtn.dataset.autoCollapseHeight) || 400;
    const collapsedHeight = parseInt(collapseBtn.dataset.collapsedHeight) || 120;

    let isCollapsed = false;

    
    function initCollapse() {
      
      const shouldCollapse = isCollapsedAttr ||
                           defaultState === 'collapsed' ||
                           shouldAutoCollapse();

      if (shouldCollapse) {
        setCollapsed(true, false); 
      }
    }

    function shouldAutoCollapse() {
      
      if (codeElement) {
        const lines = codeElement.querySelectorAll('.line, .cl');
        const height = codeElement.offsetHeight;
        return lines.length > autoCollapseLines || height > autoCollapseHeight;
      }

      
      const containerHeight = codeContainer.offsetHeight;
      if (containerHeight > autoCollapseHeight) {
        return true;
      }

      
      const textContent = codeContainer.textContent || codeContainer.innerText || '';
      const estimatedLines = textContent.split('\n').length;
      return estimatedLines > autoCollapseLines;
    }

    function setCollapsed(collapsed, animate = true) {
      if (!collapseOverlay) return;

      isCollapsed = collapsed;

      if (collapsed) {
        
        codeContainer.style.maxHeight = collapsedHeight + 'px';
        codeContainer.style.overflow = 'hidden';
        collapseOverlay.style.opacity = '1';
        collapseOverlay.style.pointerEvents = 'auto';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M19 9l-7 7-7-7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '펼치기';
        }
        collapseBtn.title = '펼치기';

      } else {
        
        codeContainer.style.maxHeight = '';
        codeContainer.style.overflow = '';
        collapseOverlay.style.opacity = '0';
        collapseOverlay.style.pointerEvents = 'none';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath fill=\u0022currentColor\u0022 d=\u0022M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z\u0022\/\u003e\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '접기';
        }
        collapseBtn.title = '접기';
      }

      
      if (animate) {
        codeContainer.style.transition = 'max-height 0.3s ease-out';
        setTimeout(() => {
          codeContainer.style.transition = '';
        }, 300);
      }
    }

    function toggleCollapse() {
      setCollapsed(!isCollapsed, true);
    }

    
    collapseBtn.addEventListener('click', toggleCollapse);

    
    if (collapseOverlay) {
      collapseOverlay.addEventListener('click', () => {
        if (isCollapsed) {
          setCollapsed(false, true);
        }
      });
    }

    
    initCollapse();
  }
})();
</script>
<p>➡ 가장 높은 점수를 가진 **가설적 추론(Abductive Reasoning)**이 선택됨.</p>
<hr>
<h3 id="step-3-명시적-메모리explicit-memory에서-유사한-문제-검색"><strong>Step 3: 명시적 메모리(Explicit Memory)에서 유사한 문제 검색</strong></h3>
<p>메타-추론기가 선택한 추론 유형을 기준으로 <strong>과거의 유사한 문제와 해결 방법을 검색</strong>함.</p>
<p>✅ <strong>유사한 문제 예시 (메모리에서 검색된 문제)</strong></p>
<div
  class="code-block-container border-border bg-card my-6 overflow-hidden rounded-xl border shadow-sm transition-all duration-200 ease-out hover:-translate-y-0.5 hover:shadow-md">
  
  <div
    class="code-block-header bg-muted/30 border-border flex items-center justify-between border-b px-4 py-3">
    
    <div class="flex items-center gap-2">
      <div class="text-muted-foreground flex-shrink-0">
        
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4" />
</svg>
      </div>
      <span class="text-muted-foreground text-sm font-medium">
        PLAINTEXT
      </span>
    </div>

    
    <div class="flex items-center gap-2">
      <button
          class="collapse-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
          data-code-id="code-5"
          data-default-state="expanded"
          data-collapsed="false"
          data-auto-collapse-lines="30"
          data-auto-collapse-height="400"
          data-collapsed-height="120"
          title="접기"
          aria-label="접기">
          <span class="collapse-icon">
            
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path fill="currentColor" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z"/></svg>
          </span>
          <span class="collapse-text hidden sm:inline"
            >접기</span
          >
        </button>
      <button
        class="copy-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
        data-code-id="code-5"
        title="복사"
        aria-label="복사">
        <span class="copy-icon">
          
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
</svg>
        </span>
        <span class="copy-text hidden sm:inline"
          >복사</span
        >
      </button>
    </div>
  </div>

  
  <div class="code-block-content relative" id="code-5">
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">문제: Lisa는 어머니보다 10살 어립니다. 두 사람의 나이 합이 70살일 때, Lisa의 나이는 몇 살인가?
</span></span><span class="line"><span class="ln">2</span><span class="cl">해결 방법: Lisa = (70 - 10) / 2 = 30살</span></span></code></pre></div>
    
    <div
      class="collapse-overlay to-card/90 pointer-events-none absolute inset-0 bg-gradient-to-b from-transparent via-transparent opacity-0 transition-opacity duration-300">
      <div
        class="text-muted-foreground bg-card/80 border-border/50 hover:bg-primary/10 hover:text-primary hover:border-primary/30 absolute bottom-4 left-1/2 -translate-x-1/2 cursor-pointer rounded-full border px-3 py-1.5 text-xs backdrop-blur-sm transition-all duration-200">
        클릭하여 더 보기
      </div>
    </div>
  </div>
</div>


<script>
(function() {
  const codeId = 'code-5';
  const copyBtn = document.querySelector('.copy-code-btn[data-code-id="' + codeId + '"]');
  const collapseBtn = document.querySelector('.collapse-code-btn[data-code-id="' + codeId + '"]');
  const codeContainer = document.getElementById(codeId);

  if (!codeContainer) return;

  
  if (copyBtn) {
    const copyIcon = copyBtn.querySelector('.copy-icon');
    const copyText = copyBtn.querySelector('.copy-text');

    copyBtn.addEventListener('click', async function() {
      try {
        
        let codeText = '';

        
        const codeTableCell = codeContainer.querySelector('.lntd:last-child code');
        if (codeTableCell) {
          codeText = codeTableCell.textContent || codeTableCell.innerText;
        } else {
          
          const codeElement = codeContainer.querySelector('code');
          if (codeElement) {
            
            const hasInlineLineNumbers = codeElement.querySelector('.ln');
            if (hasInlineLineNumbers) {
              
              const codeLines = codeElement.querySelectorAll('.cl');
              if (codeLines.length > 0) {
                codeText = Array.from(codeLines)
                  .map(line => {
                    const text = line.textContent || line.innerText;
                    
                    return text.replace(/\n+$/, '');
                  })
                  .join('\n')
                  .replace(/\n+$/, ''); 
              } else {
                
                const allText = codeElement.textContent || codeElement.innerText;
                codeText = allText.replace(/^\d+/gm, '').replace(/^\s+/gm, '');
              }
            } else {
              
              codeText = codeElement.textContent || codeElement.innerText;
            }
          } else {
            
            codeText = codeContainer.textContent || codeContainer.innerText;
          }
        }

        
        codeText = codeText.trim();

        
        await navigator.clipboard.writeText(codeText);

        
        copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M5 13l4 4L19 7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (copyText) {
          copyText.textContent = '복사됨';
        }
        copyBtn.classList.add('text-green-600');

        
        setTimeout(() => {
          copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z\u0022 \/\u003e\n\u003c\/svg\u003e`;
          if (copyText) {
            copyText.textContent = '복사';
          }
          copyBtn.classList.remove('text-green-600');
        }, 2000);

      } catch (err) {
        console.error('复制失败:', err);

        
        const range = document.createRange();
        const codeElement = codeContainer.querySelector('code') || codeContainer;
        range.selectNodeContents(codeElement);
        const selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);

        
        if (copyText) {
          copyText.textContent = '선택됨';
        }

        setTimeout(() => {
          if (copyText) {
            copyText.textContent = '복사';
          }
          selection.removeAllRanges();
        }, 2000);
      }
    });
  }

  
  if (collapseBtn) {
    const collapseIcon = collapseBtn.querySelector('.collapse-icon');
    const collapseText = collapseBtn.querySelector('.collapse-text');
    const collapseOverlay = codeContainer.querySelector('.collapse-overlay');

    
    let codeElement = codeContainer.querySelector('pre.chroma');
    if (!codeElement) {
      codeElement = codeContainer.querySelector('pre');
    }

    const defaultState = collapseBtn.dataset.defaultState || 'expanded';
    const isCollapsedAttr = collapseBtn.dataset.collapsed === 'true';
    const autoCollapseLines = parseInt(collapseBtn.dataset.autoCollapseLines) || 30;
    const autoCollapseHeight = parseInt(collapseBtn.dataset.autoCollapseHeight) || 400;
    const collapsedHeight = parseInt(collapseBtn.dataset.collapsedHeight) || 120;

    let isCollapsed = false;

    
    function initCollapse() {
      
      const shouldCollapse = isCollapsedAttr ||
                           defaultState === 'collapsed' ||
                           shouldAutoCollapse();

      if (shouldCollapse) {
        setCollapsed(true, false); 
      }
    }

    function shouldAutoCollapse() {
      
      if (codeElement) {
        const lines = codeElement.querySelectorAll('.line, .cl');
        const height = codeElement.offsetHeight;
        return lines.length > autoCollapseLines || height > autoCollapseHeight;
      }

      
      const containerHeight = codeContainer.offsetHeight;
      if (containerHeight > autoCollapseHeight) {
        return true;
      }

      
      const textContent = codeContainer.textContent || codeContainer.innerText || '';
      const estimatedLines = textContent.split('\n').length;
      return estimatedLines > autoCollapseLines;
    }

    function setCollapsed(collapsed, animate = true) {
      if (!collapseOverlay) return;

      isCollapsed = collapsed;

      if (collapsed) {
        
        codeContainer.style.maxHeight = collapsedHeight + 'px';
        codeContainer.style.overflow = 'hidden';
        collapseOverlay.style.opacity = '1';
        collapseOverlay.style.pointerEvents = 'auto';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M19 9l-7 7-7-7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '펼치기';
        }
        collapseBtn.title = '펼치기';

      } else {
        
        codeContainer.style.maxHeight = '';
        codeContainer.style.overflow = '';
        collapseOverlay.style.opacity = '0';
        collapseOverlay.style.pointerEvents = 'none';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath fill=\u0022currentColor\u0022 d=\u0022M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z\u0022\/\u003e\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '접기';
        }
        collapseBtn.title = '접기';
      }

      
      if (animate) {
        codeContainer.style.transition = 'max-height 0.3s ease-out';
        setTimeout(() => {
          codeContainer.style.transition = '';
        }, 300);
      }
    }

    function toggleCollapse() {
      setCollapsed(!isCollapsed, true);
    }

    
    collapseBtn.addEventListener('click', toggleCollapse);

    
    if (collapseOverlay) {
      collapseOverlay.addEventListener('click', () => {
        if (isCollapsed) {
          setCollapsed(false, true);
        }
      });
    }

    
    initCollapse();
  }
})();
</script>
<p>➡ 이와 비슷한 방식으로 현재 문제를 해결 가능함.</p>
<hr>
<h3 id="step-4-추론기reasoner가-문제-해결-수행"><strong>Step 4: 추론기(Reasoner)가 문제 해결 수행</strong></h3>
<p>메타-추론기가 선택한 **가설적 추론(Abductive Reasoning)**을 적용하여 문제를 해결함.</p>
<p>📌 <strong>가설적 추론(Abductive Reasoning) 적용</strong></p>
<div
  class="code-block-container border-border bg-card my-6 overflow-hidden rounded-xl border shadow-sm transition-all duration-200 ease-out hover:-translate-y-0.5 hover:shadow-md">
  
  <div
    class="code-block-header bg-muted/30 border-border flex items-center justify-between border-b px-4 py-3">
    
    <div class="flex items-center gap-2">
      <div class="text-muted-foreground flex-shrink-0">
        
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4" />
</svg>
      </div>
      <span class="text-muted-foreground text-sm font-medium">
        PLAINTEXT
      </span>
    </div>

    
    <div class="flex items-center gap-2">
      <button
          class="collapse-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
          data-code-id="code-6"
          data-default-state="expanded"
          data-collapsed="false"
          data-auto-collapse-lines="30"
          data-auto-collapse-height="400"
          data-collapsed-height="120"
          title="접기"
          aria-label="접기">
          <span class="collapse-icon">
            
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path fill="currentColor" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z"/></svg>
          </span>
          <span class="collapse-text hidden sm:inline"
            >접기</span
          >
        </button>
      <button
        class="copy-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
        data-code-id="code-6"
        title="복사"
        aria-label="복사">
        <span class="copy-icon">
          
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
</svg>
        </span>
        <span class="copy-text hidden sm:inline"
          >복사</span
        >
      </button>
    </div>
  </div>

  
  <div class="code-block-content relative" id="code-6">
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">1. John의 나이를 x라고 가정
</span></span><span class="line"><span class="ln">2</span><span class="cl">2. 그의 아버지의 나이는 (x + 24)
</span></span><span class="line"><span class="ln">3</span><span class="cl">3. 두 사람의 나이 합은 68이므로, 식을 세움:
</span></span><span class="line"><span class="ln">4</span><span class="cl">   x + (x + 24) = 68
</span></span><span class="line"><span class="ln">5</span><span class="cl">4. 계산 수행:
</span></span><span class="line"><span class="ln">6</span><span class="cl">   2x + 24 = 68
</span></span><span class="line"><span class="ln">7</span><span class="cl">   2x = 44
</span></span><span class="line"><span class="ln">8</span><span class="cl">   x = 22
</span></span><span class="line"><span class="ln">9</span><span class="cl">5. 최종 정답: John은 **22살**이다.</span></span></code></pre></div>
    
    <div
      class="collapse-overlay to-card/90 pointer-events-none absolute inset-0 bg-gradient-to-b from-transparent via-transparent opacity-0 transition-opacity duration-300">
      <div
        class="text-muted-foreground bg-card/80 border-border/50 hover:bg-primary/10 hover:text-primary hover:border-primary/30 absolute bottom-4 left-1/2 -translate-x-1/2 cursor-pointer rounded-full border px-3 py-1.5 text-xs backdrop-blur-sm transition-all duration-200">
        클릭하여 더 보기
      </div>
    </div>
  </div>
</div>


<script>
(function() {
  const codeId = 'code-6';
  const copyBtn = document.querySelector('.copy-code-btn[data-code-id="' + codeId + '"]');
  const collapseBtn = document.querySelector('.collapse-code-btn[data-code-id="' + codeId + '"]');
  const codeContainer = document.getElementById(codeId);

  if (!codeContainer) return;

  
  if (copyBtn) {
    const copyIcon = copyBtn.querySelector('.copy-icon');
    const copyText = copyBtn.querySelector('.copy-text');

    copyBtn.addEventListener('click', async function() {
      try {
        
        let codeText = '';

        
        const codeTableCell = codeContainer.querySelector('.lntd:last-child code');
        if (codeTableCell) {
          codeText = codeTableCell.textContent || codeTableCell.innerText;
        } else {
          
          const codeElement = codeContainer.querySelector('code');
          if (codeElement) {
            
            const hasInlineLineNumbers = codeElement.querySelector('.ln');
            if (hasInlineLineNumbers) {
              
              const codeLines = codeElement.querySelectorAll('.cl');
              if (codeLines.length > 0) {
                codeText = Array.from(codeLines)
                  .map(line => {
                    const text = line.textContent || line.innerText;
                    
                    return text.replace(/\n+$/, '');
                  })
                  .join('\n')
                  .replace(/\n+$/, ''); 
              } else {
                
                const allText = codeElement.textContent || codeElement.innerText;
                codeText = allText.replace(/^\d+/gm, '').replace(/^\s+/gm, '');
              }
            } else {
              
              codeText = codeElement.textContent || codeElement.innerText;
            }
          } else {
            
            codeText = codeContainer.textContent || codeContainer.innerText;
          }
        }

        
        codeText = codeText.trim();

        
        await navigator.clipboard.writeText(codeText);

        
        copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M5 13l4 4L19 7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (copyText) {
          copyText.textContent = '복사됨';
        }
        copyBtn.classList.add('text-green-600');

        
        setTimeout(() => {
          copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z\u0022 \/\u003e\n\u003c\/svg\u003e`;
          if (copyText) {
            copyText.textContent = '복사';
          }
          copyBtn.classList.remove('text-green-600');
        }, 2000);

      } catch (err) {
        console.error('复制失败:', err);

        
        const range = document.createRange();
        const codeElement = codeContainer.querySelector('code') || codeContainer;
        range.selectNodeContents(codeElement);
        const selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);

        
        if (copyText) {
          copyText.textContent = '선택됨';
        }

        setTimeout(() => {
          if (copyText) {
            copyText.textContent = '복사';
          }
          selection.removeAllRanges();
        }, 2000);
      }
    });
  }

  
  if (collapseBtn) {
    const collapseIcon = collapseBtn.querySelector('.collapse-icon');
    const collapseText = collapseBtn.querySelector('.collapse-text');
    const collapseOverlay = codeContainer.querySelector('.collapse-overlay');

    
    let codeElement = codeContainer.querySelector('pre.chroma');
    if (!codeElement) {
      codeElement = codeContainer.querySelector('pre');
    }

    const defaultState = collapseBtn.dataset.defaultState || 'expanded';
    const isCollapsedAttr = collapseBtn.dataset.collapsed === 'true';
    const autoCollapseLines = parseInt(collapseBtn.dataset.autoCollapseLines) || 30;
    const autoCollapseHeight = parseInt(collapseBtn.dataset.autoCollapseHeight) || 400;
    const collapsedHeight = parseInt(collapseBtn.dataset.collapsedHeight) || 120;

    let isCollapsed = false;

    
    function initCollapse() {
      
      const shouldCollapse = isCollapsedAttr ||
                           defaultState === 'collapsed' ||
                           shouldAutoCollapse();

      if (shouldCollapse) {
        setCollapsed(true, false); 
      }
    }

    function shouldAutoCollapse() {
      
      if (codeElement) {
        const lines = codeElement.querySelectorAll('.line, .cl');
        const height = codeElement.offsetHeight;
        return lines.length > autoCollapseLines || height > autoCollapseHeight;
      }

      
      const containerHeight = codeContainer.offsetHeight;
      if (containerHeight > autoCollapseHeight) {
        return true;
      }

      
      const textContent = codeContainer.textContent || codeContainer.innerText || '';
      const estimatedLines = textContent.split('\n').length;
      return estimatedLines > autoCollapseLines;
    }

    function setCollapsed(collapsed, animate = true) {
      if (!collapseOverlay) return;

      isCollapsed = collapsed;

      if (collapsed) {
        
        codeContainer.style.maxHeight = collapsedHeight + 'px';
        codeContainer.style.overflow = 'hidden';
        collapseOverlay.style.opacity = '1';
        collapseOverlay.style.pointerEvents = 'auto';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M19 9l-7 7-7-7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '펼치기';
        }
        collapseBtn.title = '펼치기';

      } else {
        
        codeContainer.style.maxHeight = '';
        codeContainer.style.overflow = '';
        collapseOverlay.style.opacity = '0';
        collapseOverlay.style.pointerEvents = 'none';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath fill=\u0022currentColor\u0022 d=\u0022M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z\u0022\/\u003e\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '접기';
        }
        collapseBtn.title = '접기';
      }

      
      if (animate) {
        codeContainer.style.transition = 'max-height 0.3s ease-out';
        setTimeout(() => {
          codeContainer.style.transition = '';
        }, 300);
      }
    }

    function toggleCollapse() {
      setCollapsed(!isCollapsed, true);
    }

    
    collapseBtn.addEventListener('click', toggleCollapse);

    
    if (collapseOverlay) {
      collapseOverlay.addEventListener('click', () => {
        if (isCollapsed) {
          setCollapsed(false, true);
        }
      });
    }

    
    initCollapse();
  }
})();
</script>
<p>✅ <strong>정답: 22</strong></p>
<hr>
<h3 id="step-5-결과-저장-및-자기-학습self-training"><strong>Step 5: 결과 저장 및 자기 학습(Self-Training)</strong></h3>
<p>TypedThinker는 성공적으로 문제를 해결한 후, <strong>이 과정을 메모리에 저장</strong>하여 향후 비슷한 문제가 등장했을 때 더 효과적으로 해결할 수 있도록 학습함.</p>
<p>📌 <strong>새로운 경험이 메모리에 추가됨</strong></p>
<div
  class="code-block-container border-border bg-card my-6 overflow-hidden rounded-xl border shadow-sm transition-all duration-200 ease-out hover:-translate-y-0.5 hover:shadow-md">
  
  <div
    class="code-block-header bg-muted/30 border-border flex items-center justify-between border-b px-4 py-3">
    
    <div class="flex items-center gap-2">
      <div class="text-muted-foreground flex-shrink-0">
        
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4" />
</svg>
      </div>
      <span class="text-muted-foreground text-sm font-medium">
        PLAINTEXT
      </span>
    </div>

    
    <div class="flex items-center gap-2">
      <button
          class="collapse-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
          data-code-id="code-7"
          data-default-state="expanded"
          data-collapsed="false"
          data-auto-collapse-lines="30"
          data-auto-collapse-height="400"
          data-collapsed-height="120"
          title="접기"
          aria-label="접기">
          <span class="collapse-icon">
            
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path fill="currentColor" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z"/></svg>
          </span>
          <span class="collapse-text hidden sm:inline"
            >접기</span
          >
        </button>
      <button
        class="copy-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
        data-code-id="code-7"
        title="복사"
        aria-label="복사">
        <span class="copy-icon">
          
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
</svg>
        </span>
        <span class="copy-text hidden sm:inline"
          >복사</span
        >
      </button>
    </div>
  </div>

  
  <div class="code-block-content relative" id="code-7">
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">문제: John은 아버지보다 24살 어립니다. John과 그의 아버지의 나이 합이 68살일 때, John의 나이는 몇 살인가?
</span></span><span class="line"><span class="ln">2</span><span class="cl">해결 방법: x + (x + 24) = 68 → x = 22
</span></span><span class="line"><span class="ln">3</span><span class="cl">추론 유형: 가설적 추론(Abductive Reasoning)</span></span></code></pre></div>
    
    <div
      class="collapse-overlay to-card/90 pointer-events-none absolute inset-0 bg-gradient-to-b from-transparent via-transparent opacity-0 transition-opacity duration-300">
      <div
        class="text-muted-foreground bg-card/80 border-border/50 hover:bg-primary/10 hover:text-primary hover:border-primary/30 absolute bottom-4 left-1/2 -translate-x-1/2 cursor-pointer rounded-full border px-3 py-1.5 text-xs backdrop-blur-sm transition-all duration-200">
        클릭하여 더 보기
      </div>
    </div>
  </div>
</div>


<script>
(function() {
  const codeId = 'code-7';
  const copyBtn = document.querySelector('.copy-code-btn[data-code-id="' + codeId + '"]');
  const collapseBtn = document.querySelector('.collapse-code-btn[data-code-id="' + codeId + '"]');
  const codeContainer = document.getElementById(codeId);

  if (!codeContainer) return;

  
  if (copyBtn) {
    const copyIcon = copyBtn.querySelector('.copy-icon');
    const copyText = copyBtn.querySelector('.copy-text');

    copyBtn.addEventListener('click', async function() {
      try {
        
        let codeText = '';

        
        const codeTableCell = codeContainer.querySelector('.lntd:last-child code');
        if (codeTableCell) {
          codeText = codeTableCell.textContent || codeTableCell.innerText;
        } else {
          
          const codeElement = codeContainer.querySelector('code');
          if (codeElement) {
            
            const hasInlineLineNumbers = codeElement.querySelector('.ln');
            if (hasInlineLineNumbers) {
              
              const codeLines = codeElement.querySelectorAll('.cl');
              if (codeLines.length > 0) {
                codeText = Array.from(codeLines)
                  .map(line => {
                    const text = line.textContent || line.innerText;
                    
                    return text.replace(/\n+$/, '');
                  })
                  .join('\n')
                  .replace(/\n+$/, ''); 
              } else {
                
                const allText = codeElement.textContent || codeElement.innerText;
                codeText = allText.replace(/^\d+/gm, '').replace(/^\s+/gm, '');
              }
            } else {
              
              codeText = codeElement.textContent || codeElement.innerText;
            }
          } else {
            
            codeText = codeContainer.textContent || codeContainer.innerText;
          }
        }

        
        codeText = codeText.trim();

        
        await navigator.clipboard.writeText(codeText);

        
        copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M5 13l4 4L19 7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (copyText) {
          copyText.textContent = '복사됨';
        }
        copyBtn.classList.add('text-green-600');

        
        setTimeout(() => {
          copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z\u0022 \/\u003e\n\u003c\/svg\u003e`;
          if (copyText) {
            copyText.textContent = '복사';
          }
          copyBtn.classList.remove('text-green-600');
        }, 2000);

      } catch (err) {
        console.error('复制失败:', err);

        
        const range = document.createRange();
        const codeElement = codeContainer.querySelector('code') || codeContainer;
        range.selectNodeContents(codeElement);
        const selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);

        
        if (copyText) {
          copyText.textContent = '선택됨';
        }

        setTimeout(() => {
          if (copyText) {
            copyText.textContent = '복사';
          }
          selection.removeAllRanges();
        }, 2000);
      }
    });
  }

  
  if (collapseBtn) {
    const collapseIcon = collapseBtn.querySelector('.collapse-icon');
    const collapseText = collapseBtn.querySelector('.collapse-text');
    const collapseOverlay = codeContainer.querySelector('.collapse-overlay');

    
    let codeElement = codeContainer.querySelector('pre.chroma');
    if (!codeElement) {
      codeElement = codeContainer.querySelector('pre');
    }

    const defaultState = collapseBtn.dataset.defaultState || 'expanded';
    const isCollapsedAttr = collapseBtn.dataset.collapsed === 'true';
    const autoCollapseLines = parseInt(collapseBtn.dataset.autoCollapseLines) || 30;
    const autoCollapseHeight = parseInt(collapseBtn.dataset.autoCollapseHeight) || 400;
    const collapsedHeight = parseInt(collapseBtn.dataset.collapsedHeight) || 120;

    let isCollapsed = false;

    
    function initCollapse() {
      
      const shouldCollapse = isCollapsedAttr ||
                           defaultState === 'collapsed' ||
                           shouldAutoCollapse();

      if (shouldCollapse) {
        setCollapsed(true, false); 
      }
    }

    function shouldAutoCollapse() {
      
      if (codeElement) {
        const lines = codeElement.querySelectorAll('.line, .cl');
        const height = codeElement.offsetHeight;
        return lines.length > autoCollapseLines || height > autoCollapseHeight;
      }

      
      const containerHeight = codeContainer.offsetHeight;
      if (containerHeight > autoCollapseHeight) {
        return true;
      }

      
      const textContent = codeContainer.textContent || codeContainer.innerText || '';
      const estimatedLines = textContent.split('\n').length;
      return estimatedLines > autoCollapseLines;
    }

    function setCollapsed(collapsed, animate = true) {
      if (!collapseOverlay) return;

      isCollapsed = collapsed;

      if (collapsed) {
        
        codeContainer.style.maxHeight = collapsedHeight + 'px';
        codeContainer.style.overflow = 'hidden';
        collapseOverlay.style.opacity = '1';
        collapseOverlay.style.pointerEvents = 'auto';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M19 9l-7 7-7-7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '펼치기';
        }
        collapseBtn.title = '펼치기';

      } else {
        
        codeContainer.style.maxHeight = '';
        codeContainer.style.overflow = '';
        collapseOverlay.style.opacity = '0';
        collapseOverlay.style.pointerEvents = 'none';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath fill=\u0022currentColor\u0022 d=\u0022M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z\u0022\/\u003e\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '접기';
        }
        collapseBtn.title = '접기';
      }

      
      if (animate) {
        codeContainer.style.transition = 'max-height 0.3s ease-out';
        setTimeout(() => {
          codeContainer.style.transition = '';
        }, 300);
      }
    }

    function toggleCollapse() {
      setCollapsed(!isCollapsed, true);
    }

    
    collapseBtn.addEventListener('click', toggleCollapse);

    
    if (collapseOverlay) {
      collapseOverlay.addEventListener('click', () => {
        if (isCollapsed) {
          setCollapsed(false, true);
        }
      });
    }

    
    initCollapse();
  }
})();
</script>
<p>➡ 이 과정을 통해 모델은 점점 더 많은 패턴을 학습하고, <strong>더 정교한 문제 해결 능력을 갖추게 됨</strong>.</p>
<hr>
<h2 id="3-핵심-개념-요약"><strong>3. 핵심 개념 요약</strong></h2>
<table>
  <thead>
      <tr>
          <th>단계</th>
          <th>상세 내용</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>Step 1</strong></td>
          <td>문제 입력</td>
      </tr>
      <tr>
          <td><strong>Step 2</strong></td>
          <td>**메타-추론기(Meta-thinker)**가 가장 적절한 논리적 추론 유형을 선택</td>
      </tr>
      <tr>
          <td><strong>Step 3</strong></td>
          <td>**명시적 메모리(Explicit Memory)**에서 유사한 문제와 해결 방법 검색</td>
      </tr>
      <tr>
          <td><strong>Step 4</strong></td>
          <td>**추론기(Reasoner)**가 선택된 추론 유형을 활용하여 문제 해결 수행</td>
      </tr>
      <tr>
          <td><strong>Step 5</strong></td>
          <td>해결 과정을 메모리에 저장하여 <strong>자기 학습(Self-Training) 수행</strong></td>
      </tr>
  </tbody>
</table>
<hr>
<h2 id="4-typedthinker의-적용-사례-추론-방식별-예제"><strong>4. TypedThinker의 적용 사례 (추론 방식별 예제)</strong></h2>
<table>
  <thead>
      <tr>
          <th>추론 방식</th>
          <th>설명</th>
          <th>예제 문제</th>
          <th>해결 방법</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>연역(Deductive)</strong></td>
          <td>일반적인 원칙에서 특정 결론을 도출</td>
          <td>&ldquo;모든 개는 포유류이다. Fido는 개이다. Fido는 포유류인가?&rdquo;</td>
          <td><strong>예, Fido는 포유류이다.</strong> (일반 원칙을 활용하여 결론 도출)</td>
      </tr>
      <tr>
          <td><strong>귀납(Inductive)</strong></td>
          <td>여러 개별 사례를 통해 일반적인 법칙을 도출</td>
          <td>&ldquo;이전에 본 모든 백조는 흰색이었다. 모든 백조는 흰색일까?&rdquo;</td>
          <td><strong>일반적으로 그렇다고 추론 가능.</strong> (귀납적으로 결론 도출)</td>
      </tr>
      <tr>
          <td><strong>가설(Abductive)</strong></td>
          <td>가능한 원인을 추론하여 가장 그럴듯한 결론 도출</td>
          <td>&ldquo;거리에 물이 고여 있다. 비가 왔을까?&rdquo;</td>
          <td><strong>비가 왔을 가능성이 높다.</strong> (가능한 원인 추론)</td>
      </tr>
      <tr>
          <td><strong>유추(Analogical)</strong></td>
          <td>유사한 사례를 비교하여 해결</td>
          <td>&ldquo;A 회사가 광고를 늘린 후 매출 증가. B 회사도 광고를 늘리면 매출 증가할까?&rdquo;</td>
          <td><strong>가능성이 높다.</strong> (유사한 사례 비교 후 결론 도출)</td>
      </tr>
  </tbody>
</table>
<hr>
<h2 id="5-typedthinker의-장점-및-차별점"><strong>5. TypedThinker의 장점 및 차별점</strong></h2>
<h3 id="-장점">✅ <strong>장점</strong></h3>
<ul>
<li>다양한 추론 방식을 자동으로 선택하여 적용 (메타-추론기)</li>
<li>과거 해결 경험을 재활용하여 문제 해결 효율성 증가 (명시적 메모리)</li>
<li>자기 학습을 통해 점점 더 정교한 해결 능력 향상 (Self-Training)</li>
<li>기존 CoT(Chain of Thought) 방식보다 <strong>더 깊고 다양한 사고 과정 반영</strong></li>
</ul>
<h3 id="-한계점">❌ <strong>한계점</strong></h3>
<ul>
<li>한 문제에서 여러 추론 방식을 복합적으로 적용할 필요가 있음 (현재는 단일 추론 방식 선택)</li>
<li>논리적 및 수학적 문제에 초점이 맞춰져 있음 → 일반적인 문제 해결로 확장 필요</li>
<li>명시적 메모리 검색의 정확도를 더 향상시킬 필요 있음</li>
</ul>
<hr>
<h2 id="6-결론"><strong>6. 결론</strong></h2>
<p><strong>TypedThinker는 기존 LLM이 단일한 논리적 사고 방식에 의존하는 한계를 극복하고, 다양한 추론 방식을 활용하여 문제를 해결하는 강력한 알고리즘이다.</strong><br>
연역, 귀납, 가설, 유추라는 4가지 논리적 추론을 적용하고, 자기 학습을 통해 점점 더 정교한 추론 능력을 갖추도록 설계되었다.<br>
앞으로 한 문제에 복합적인 논리적 추론을 적용하는 연구가 추가된다면 더욱 강력한 문제 해결 능력을 갖출 수 있을 것이다. 🚀</p>
<h1 id="q--이-논문에서-사용하는-방법을-학습하기-위하여-어떤-데이터셋이-필요할까-그리고-어떻게-학습을-진행하면-될지-예시를-들어서-아주-자세하게-설명해줘">Q : 이 논문에서 사용하는 방법을 학습하기 위하여 어떤 데이터셋이 필요할까? 그리고 어떻게 학습을 진행하면 될지 예시를 들어서 아주 자세하게 설명해줘</h1>
<h2 id="typedthinker-학습을-위한-데이터셋-및-학습-방법"><strong>TypedThinker 학습을 위한 데이터셋 및 학습 방법</strong></h2>
<h3 id="1-학습을-위한-필수-데이터셋"><strong>1. 학습을 위한 필수 데이터셋</strong></h3>
<p>TypedThinker는 다양한 논리적 추론 방식을 적용하는 모델이므로, 이를 효과적으로 학습하려면 **각각의 추론 방식(연역, 귀납, 가설, 유추)**이 포함된 데이터셋이 필요합니다.</p>
<p>논문에서는 <strong>4개의 주요 데이터셋</strong>을 사용하여 모델을 학습 및 평가합니다.</p>
<table>
  <thead>
      <tr>
          <th><strong>데이터셋</strong></th>
          <th><strong>설명</strong></th>
          <th><strong>포함된 문제 유형</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>LogiQA</strong></td>
          <td>논리적 추론을 평가하는 벤치마크</td>
          <td>논리 퍼즐, 연역적 추론, 조건부 논리</td>
      </tr>
      <tr>
          <td><strong>BBH (Big Bench Hard)</strong></td>
          <td>LLM의 어려운 논리 문제 해결 능력을 평가</td>
          <td>다단계 논리, 귀납적 패턴 분석, 연역</td>
      </tr>
      <tr>
          <td><strong>GSM8K</strong></td>
          <td>수학 문제 해결 데이터셋</td>
          <td>수학적 추론, 연산 과정, 문제 해결 능력</td>
      </tr>
      <tr>
          <td><strong>MATH</strong></td>
          <td>고급 수학 문제 벤치마크</td>
          <td>고급 대수학, 논리적 수리 추론</td>
      </tr>
  </tbody>
</table>
<p>✅ <strong>추가로 고려할 수 있는 데이터셋</strong></p>
<ul>
<li><strong>ARC (AI2 Reasoning Challenge)</strong> → 상식 추론, 논리적 문제 해결을 평가</li>
<li><strong>CommonsenseQA</strong> → 일반적인 상식 기반 문제 해결</li>
<li><strong>MetaMath</strong> → 수학 문제 해결을 위한 사전 학습 데이터</li>
</ul>
<hr>
<h3 id="2-데이터셋-구축-방법"><strong>2. 데이터셋 구축 방법</strong></h3>
<p>TypedThinker를 학습하려면 <strong>각 문제를 특정 논리적 추론 방식(연역, 귀납, 가설, 유추)과 연결하는 데이터셋이 필요</strong>합니다.<br>
이를 위해 <strong>각 데이터셋을 전처리하여, 문제 유형에 따라 적절한 추론 방식과 해결 경로를 명확하게 라벨링</strong>해야 합니다.</p>
<h4 id="-예제-데이터셋-구축-문제-추론-방식-매핑"><strong>📌 예제: 데이터셋 구축 (문제-추론 방식 매핑)</strong></h4>
<table>
  <thead>
      <tr>
          <th>문제 유형</th>
          <th>예제 문제</th>
          <th>정답</th>
          <th>적절한 추론 방식</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>연역(Deductive)</strong></td>
          <td>&ldquo;모든 개는 포유류이다. Fido는 개이다. Fido는 포유류인가?&rdquo;</td>
          <td>Yes</td>
          <td><strong>연역적 추론</strong></td>
      </tr>
      <tr>
          <td><strong>귀납(Inductive)</strong></td>
          <td>&ldquo;지난 10년간, 매년 여름에는 폭염이 발생했다. 올해 여름에도 폭염이 올까?&rdquo;</td>
          <td>High Probability</td>
          <td><strong>귀납적 추론</strong></td>
      </tr>
      <tr>
          <td><strong>가설(Abductive)</strong></td>
          <td>&ldquo;거리에 물이 고여 있다. 비가 왔을까?&rdquo;</td>
          <td>비가 왔을 가능성이 높다</td>
          <td><strong>가설적 추론</strong></td>
      </tr>
      <tr>
          <td><strong>유추(Analogical)</strong></td>
          <td>&ldquo;A 회사가 광고를 늘린 후 매출이 증가했다. B 회사도 광고를 늘리면 매출이 증가할까?&rdquo;</td>
          <td>Probably Yes</td>
          <td><strong>유추적 추론</strong></td>
      </tr>
  </tbody>
</table>
<p>➡ <strong>데이터셋 구축 프로세스</strong></p>
<ol>
<li>기존 데이터셋(LogiQA, BBH, GSM8K, MATH)에서 각 문제 유형에 맞는 <strong>추론 방식 라벨링</strong></li>
<li>메타-추론기(Meta-thinker)가 올바른 추론 방식을 학습할 수 있도록 <strong>라벨이 있는 데이터셋 구축</strong></li>
<li>문제 + 정답 + 올바른 추론 방식 + 해결 과정(Chain-of-Thought) 데이터를 포함하여 학습 데이터 생성</li>
</ol>
<hr>
<h3 id="3-학습-과정"><strong>3. 학습 과정</strong></h3>
<p>TypedThinker는 크게 두 가지 학습 과정이 필요합니다.</p>
<h3 id="1-메타-추론기meta-thinker-학습"><strong>(1) 메타-추론기(Meta-thinker) 학습</strong></h3>
<p>🔹 <strong>목표:</strong> 주어진 문제를 보고 가장 적절한 논리적 추론 방식을 선택하도록 학습<br>
🔹 <strong>입력 데이터:</strong> (문제, 정답, 올바른 추론 방식)<br>
🔹 <strong>출력:</strong> 적절한 추론 방식을 예측하는 확률값</p>
<p>✅ <strong>메타-추론기 학습을 위한 예제 데이터</strong> (JSON 형식)</p>
<div
  class="code-block-container border-border bg-card my-6 overflow-hidden rounded-xl border shadow-sm transition-all duration-200 ease-out hover:-translate-y-0.5 hover:shadow-md">
  
  <div
    class="code-block-header bg-muted/30 border-border flex items-center justify-between border-b px-4 py-3">
    
    <div class="flex items-center gap-2">
      <div class="text-muted-foreground flex-shrink-0">
        
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4" />
</svg>
      </div>
      <span class="text-muted-foreground text-sm font-medium">
        JSON
      </span>
    </div>

    
    <div class="flex items-center gap-2">
      <button
          class="collapse-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
          data-code-id="code-8"
          data-default-state="expanded"
          data-collapsed="false"
          data-auto-collapse-lines="30"
          data-auto-collapse-height="400"
          data-collapsed-height="120"
          title="접기"
          aria-label="접기">
          <span class="collapse-icon">
            
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path fill="currentColor" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z"/></svg>
          </span>
          <span class="collapse-text hidden sm:inline"
            >접기</span
          >
        </button>
      <button
        class="copy-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
        data-code-id="code-8"
        title="복사"
        aria-label="복사">
        <span class="copy-icon">
          
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
</svg>
        </span>
        <span class="copy-text hidden sm:inline"
          >복사</span
        >
      </button>
    </div>
  </div>

  
  <div class="code-block-content relative" id="code-8">
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">  <span class="nt">&#34;problem&#34;</span><span class="p">:</span> <span class="s2">&#34;거리에 물이 고여 있다. 비가 왔을까?&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">  <span class="nt">&#34;options&#34;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&#34;비가 왔다&#34;</span><span class="p">,</span> <span class="s2">&#34;누군가 물을 뿌렸다&#34;</span><span class="p">,</span> <span class="s2">&#34;파이프가 터졌다&#34;</span><span class="p">],</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">  <span class="nt">&#34;correct_answer&#34;</span><span class="p">:</span> <span class="s2">&#34;비가 왔다&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">  <span class="nt">&#34;reasoning_type&#34;</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="nt">&#34;Deductive&#34;</span><span class="p">:</span> <span class="mf">0.2</span><span class="p">,</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="nt">&#34;Inductive&#34;</span><span class="p">:</span> <span class="mf">0.3</span><span class="p">,</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="nt">&#34;Abductive&#34;</span><span class="p">:</span> <span class="mf">0.9</span><span class="p">,</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="nt">&#34;Analogical&#34;</span><span class="p">:</span> <span class="mf">0.1</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="p">}</span></span></span></code></pre></div>
    
    <div
      class="collapse-overlay to-card/90 pointer-events-none absolute inset-0 bg-gradient-to-b from-transparent via-transparent opacity-0 transition-opacity duration-300">
      <div
        class="text-muted-foreground bg-card/80 border-border/50 hover:bg-primary/10 hover:text-primary hover:border-primary/30 absolute bottom-4 left-1/2 -translate-x-1/2 cursor-pointer rounded-full border px-3 py-1.5 text-xs backdrop-blur-sm transition-all duration-200">
        클릭하여 더 보기
      </div>
    </div>
  </div>
</div>


<script>
(function() {
  const codeId = 'code-8';
  const copyBtn = document.querySelector('.copy-code-btn[data-code-id="' + codeId + '"]');
  const collapseBtn = document.querySelector('.collapse-code-btn[data-code-id="' + codeId + '"]');
  const codeContainer = document.getElementById(codeId);

  if (!codeContainer) return;

  
  if (copyBtn) {
    const copyIcon = copyBtn.querySelector('.copy-icon');
    const copyText = copyBtn.querySelector('.copy-text');

    copyBtn.addEventListener('click', async function() {
      try {
        
        let codeText = '';

        
        const codeTableCell = codeContainer.querySelector('.lntd:last-child code');
        if (codeTableCell) {
          codeText = codeTableCell.textContent || codeTableCell.innerText;
        } else {
          
          const codeElement = codeContainer.querySelector('code');
          if (codeElement) {
            
            const hasInlineLineNumbers = codeElement.querySelector('.ln');
            if (hasInlineLineNumbers) {
              
              const codeLines = codeElement.querySelectorAll('.cl');
              if (codeLines.length > 0) {
                codeText = Array.from(codeLines)
                  .map(line => {
                    const text = line.textContent || line.innerText;
                    
                    return text.replace(/\n+$/, '');
                  })
                  .join('\n')
                  .replace(/\n+$/, ''); 
              } else {
                
                const allText = codeElement.textContent || codeElement.innerText;
                codeText = allText.replace(/^\d+/gm, '').replace(/^\s+/gm, '');
              }
            } else {
              
              codeText = codeElement.textContent || codeElement.innerText;
            }
          } else {
            
            codeText = codeContainer.textContent || codeContainer.innerText;
          }
        }

        
        codeText = codeText.trim();

        
        await navigator.clipboard.writeText(codeText);

        
        copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M5 13l4 4L19 7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (copyText) {
          copyText.textContent = '복사됨';
        }
        copyBtn.classList.add('text-green-600');

        
        setTimeout(() => {
          copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z\u0022 \/\u003e\n\u003c\/svg\u003e`;
          if (copyText) {
            copyText.textContent = '복사';
          }
          copyBtn.classList.remove('text-green-600');
        }, 2000);

      } catch (err) {
        console.error('复制失败:', err);

        
        const range = document.createRange();
        const codeElement = codeContainer.querySelector('code') || codeContainer;
        range.selectNodeContents(codeElement);
        const selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);

        
        if (copyText) {
          copyText.textContent = '선택됨';
        }

        setTimeout(() => {
          if (copyText) {
            copyText.textContent = '복사';
          }
          selection.removeAllRanges();
        }, 2000);
      }
    });
  }

  
  if (collapseBtn) {
    const collapseIcon = collapseBtn.querySelector('.collapse-icon');
    const collapseText = collapseBtn.querySelector('.collapse-text');
    const collapseOverlay = codeContainer.querySelector('.collapse-overlay');

    
    let codeElement = codeContainer.querySelector('pre.chroma');
    if (!codeElement) {
      codeElement = codeContainer.querySelector('pre');
    }

    const defaultState = collapseBtn.dataset.defaultState || 'expanded';
    const isCollapsedAttr = collapseBtn.dataset.collapsed === 'true';
    const autoCollapseLines = parseInt(collapseBtn.dataset.autoCollapseLines) || 30;
    const autoCollapseHeight = parseInt(collapseBtn.dataset.autoCollapseHeight) || 400;
    const collapsedHeight = parseInt(collapseBtn.dataset.collapsedHeight) || 120;

    let isCollapsed = false;

    
    function initCollapse() {
      
      const shouldCollapse = isCollapsedAttr ||
                           defaultState === 'collapsed' ||
                           shouldAutoCollapse();

      if (shouldCollapse) {
        setCollapsed(true, false); 
      }
    }

    function shouldAutoCollapse() {
      
      if (codeElement) {
        const lines = codeElement.querySelectorAll('.line, .cl');
        const height = codeElement.offsetHeight;
        return lines.length > autoCollapseLines || height > autoCollapseHeight;
      }

      
      const containerHeight = codeContainer.offsetHeight;
      if (containerHeight > autoCollapseHeight) {
        return true;
      }

      
      const textContent = codeContainer.textContent || codeContainer.innerText || '';
      const estimatedLines = textContent.split('\n').length;
      return estimatedLines > autoCollapseLines;
    }

    function setCollapsed(collapsed, animate = true) {
      if (!collapseOverlay) return;

      isCollapsed = collapsed;

      if (collapsed) {
        
        codeContainer.style.maxHeight = collapsedHeight + 'px';
        codeContainer.style.overflow = 'hidden';
        collapseOverlay.style.opacity = '1';
        collapseOverlay.style.pointerEvents = 'auto';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M19 9l-7 7-7-7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '펼치기';
        }
        collapseBtn.title = '펼치기';

      } else {
        
        codeContainer.style.maxHeight = '';
        codeContainer.style.overflow = '';
        collapseOverlay.style.opacity = '0';
        collapseOverlay.style.pointerEvents = 'none';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath fill=\u0022currentColor\u0022 d=\u0022M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z\u0022\/\u003e\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '접기';
        }
        collapseBtn.title = '접기';
      }

      
      if (animate) {
        codeContainer.style.transition = 'max-height 0.3s ease-out';
        setTimeout(() => {
          codeContainer.style.transition = '';
        }, 300);
      }
    }

    function toggleCollapse() {
      setCollapsed(!isCollapsed, true);
    }

    
    collapseBtn.addEventListener('click', toggleCollapse);

    
    if (collapseOverlay) {
      collapseOverlay.addEventListener('click', () => {
        if (isCollapsed) {
          setCollapsed(false, true);
        }
      });
    }

    
    initCollapse();
  }
})();
</script>
<p>✅ <strong>학습 과정</strong></p>
<ol>
<li>입력 데이터에서 문제를 읽고, 다양한 추론 방식에 대한 확률값을 출력하는 모델을 구축</li>
<li>Cross-Entropy Loss를 활용하여 정답에 가까운 추론 방식을 선택하도록 모델 최적화</li>
<li>메타-추론기가 &ldquo;이 문제는 가설적 추론(Abductive Reasoning)이 가장 적절하다&quot;와 같은 결정을 내릴 수 있도록 훈련</li>
</ol>
<hr>
<h3 id="2-추론기reasoner-학습"><strong>(2) 추론기(Reasoner) 학습</strong></h3>
<p>🔹 <strong>목표:</strong> 메타-추론기가 선택한 논리적 추론 방식을 바탕으로 문제를 해결하는 모델 학습<br>
🔹 <strong>입력 데이터:</strong> (문제, 선택된 추론 방식, 해결 과정 예제)<br>
🔹 <strong>출력:</strong> 문제 해결을 위한 단계적 과정 (Chain-of-Thought)</p>
<p>✅ <strong>추론기 학습을 위한 예제 데이터</strong> (JSON 형식)</p>
<div
  class="code-block-container border-border bg-card my-6 overflow-hidden rounded-xl border shadow-sm transition-all duration-200 ease-out hover:-translate-y-0.5 hover:shadow-md">
  
  <div
    class="code-block-header bg-muted/30 border-border flex items-center justify-between border-b px-4 py-3">
    
    <div class="flex items-center gap-2">
      <div class="text-muted-foreground flex-shrink-0">
        
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4" />
</svg>
      </div>
      <span class="text-muted-foreground text-sm font-medium">
        JSON
      </span>
    </div>

    
    <div class="flex items-center gap-2">
      <button
          class="collapse-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
          data-code-id="code-9"
          data-default-state="expanded"
          data-collapsed="false"
          data-auto-collapse-lines="30"
          data-auto-collapse-height="400"
          data-collapsed-height="120"
          title="접기"
          aria-label="접기">
          <span class="collapse-icon">
            
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path fill="currentColor" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z"/></svg>
          </span>
          <span class="collapse-text hidden sm:inline"
            >접기</span
          >
        </button>
      <button
        class="copy-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
        data-code-id="code-9"
        title="복사"
        aria-label="복사">
        <span class="copy-icon">
          
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
</svg>
        </span>
        <span class="copy-text hidden sm:inline"
          >복사</span
        >
      </button>
    </div>
  </div>

  
  <div class="code-block-content relative" id="code-9">
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">  <span class="nt">&#34;problem&#34;</span><span class="p">:</span> <span class="s2">&#34;John은 아버지보다 24살 어리다. 두 사람의 나이 합이 68살이다. John의 나이는?&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">  <span class="nt">&#34;selected_reasoning&#34;</span><span class="p">:</span> <span class="s2">&#34;Abductive&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">  <span class="nt">&#34;solution&#34;</span><span class="p">:</span> <span class="p">[</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="s2">&#34;John의 나이를 x라고 가정&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="s2">&#34;아버지의 나이는 (x + 24)&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="s2">&#34;x + (x + 24) = 68&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="s2">&#34;2x + 24 = 68&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="s2">&#34;2x = 44&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="s2">&#34;x = 22&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="s2">&#34;정답: John은 22살이다.&#34;</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">  <span class="p">]</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="p">}</span></span></span></code></pre></div>
    
    <div
      class="collapse-overlay to-card/90 pointer-events-none absolute inset-0 bg-gradient-to-b from-transparent via-transparent opacity-0 transition-opacity duration-300">
      <div
        class="text-muted-foreground bg-card/80 border-border/50 hover:bg-primary/10 hover:text-primary hover:border-primary/30 absolute bottom-4 left-1/2 -translate-x-1/2 cursor-pointer rounded-full border px-3 py-1.5 text-xs backdrop-blur-sm transition-all duration-200">
        클릭하여 더 보기
      </div>
    </div>
  </div>
</div>


<script>
(function() {
  const codeId = 'code-9';
  const copyBtn = document.querySelector('.copy-code-btn[data-code-id="' + codeId + '"]');
  const collapseBtn = document.querySelector('.collapse-code-btn[data-code-id="' + codeId + '"]');
  const codeContainer = document.getElementById(codeId);

  if (!codeContainer) return;

  
  if (copyBtn) {
    const copyIcon = copyBtn.querySelector('.copy-icon');
    const copyText = copyBtn.querySelector('.copy-text');

    copyBtn.addEventListener('click', async function() {
      try {
        
        let codeText = '';

        
        const codeTableCell = codeContainer.querySelector('.lntd:last-child code');
        if (codeTableCell) {
          codeText = codeTableCell.textContent || codeTableCell.innerText;
        } else {
          
          const codeElement = codeContainer.querySelector('code');
          if (codeElement) {
            
            const hasInlineLineNumbers = codeElement.querySelector('.ln');
            if (hasInlineLineNumbers) {
              
              const codeLines = codeElement.querySelectorAll('.cl');
              if (codeLines.length > 0) {
                codeText = Array.from(codeLines)
                  .map(line => {
                    const text = line.textContent || line.innerText;
                    
                    return text.replace(/\n+$/, '');
                  })
                  .join('\n')
                  .replace(/\n+$/, ''); 
              } else {
                
                const allText = codeElement.textContent || codeElement.innerText;
                codeText = allText.replace(/^\d+/gm, '').replace(/^\s+/gm, '');
              }
            } else {
              
              codeText = codeElement.textContent || codeElement.innerText;
            }
          } else {
            
            codeText = codeContainer.textContent || codeContainer.innerText;
          }
        }

        
        codeText = codeText.trim();

        
        await navigator.clipboard.writeText(codeText);

        
        copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M5 13l4 4L19 7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (copyText) {
          copyText.textContent = '복사됨';
        }
        copyBtn.classList.add('text-green-600');

        
        setTimeout(() => {
          copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z\u0022 \/\u003e\n\u003c\/svg\u003e`;
          if (copyText) {
            copyText.textContent = '복사';
          }
          copyBtn.classList.remove('text-green-600');
        }, 2000);

      } catch (err) {
        console.error('复制失败:', err);

        
        const range = document.createRange();
        const codeElement = codeContainer.querySelector('code') || codeContainer;
        range.selectNodeContents(codeElement);
        const selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);

        
        if (copyText) {
          copyText.textContent = '선택됨';
        }

        setTimeout(() => {
          if (copyText) {
            copyText.textContent = '복사';
          }
          selection.removeAllRanges();
        }, 2000);
      }
    });
  }

  
  if (collapseBtn) {
    const collapseIcon = collapseBtn.querySelector('.collapse-icon');
    const collapseText = collapseBtn.querySelector('.collapse-text');
    const collapseOverlay = codeContainer.querySelector('.collapse-overlay');

    
    let codeElement = codeContainer.querySelector('pre.chroma');
    if (!codeElement) {
      codeElement = codeContainer.querySelector('pre');
    }

    const defaultState = collapseBtn.dataset.defaultState || 'expanded';
    const isCollapsedAttr = collapseBtn.dataset.collapsed === 'true';
    const autoCollapseLines = parseInt(collapseBtn.dataset.autoCollapseLines) || 30;
    const autoCollapseHeight = parseInt(collapseBtn.dataset.autoCollapseHeight) || 400;
    const collapsedHeight = parseInt(collapseBtn.dataset.collapsedHeight) || 120;

    let isCollapsed = false;

    
    function initCollapse() {
      
      const shouldCollapse = isCollapsedAttr ||
                           defaultState === 'collapsed' ||
                           shouldAutoCollapse();

      if (shouldCollapse) {
        setCollapsed(true, false); 
      }
    }

    function shouldAutoCollapse() {
      
      if (codeElement) {
        const lines = codeElement.querySelectorAll('.line, .cl');
        const height = codeElement.offsetHeight;
        return lines.length > autoCollapseLines || height > autoCollapseHeight;
      }

      
      const containerHeight = codeContainer.offsetHeight;
      if (containerHeight > autoCollapseHeight) {
        return true;
      }

      
      const textContent = codeContainer.textContent || codeContainer.innerText || '';
      const estimatedLines = textContent.split('\n').length;
      return estimatedLines > autoCollapseLines;
    }

    function setCollapsed(collapsed, animate = true) {
      if (!collapseOverlay) return;

      isCollapsed = collapsed;

      if (collapsed) {
        
        codeContainer.style.maxHeight = collapsedHeight + 'px';
        codeContainer.style.overflow = 'hidden';
        collapseOverlay.style.opacity = '1';
        collapseOverlay.style.pointerEvents = 'auto';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M19 9l-7 7-7-7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '펼치기';
        }
        collapseBtn.title = '펼치기';

      } else {
        
        codeContainer.style.maxHeight = '';
        codeContainer.style.overflow = '';
        collapseOverlay.style.opacity = '0';
        collapseOverlay.style.pointerEvents = 'none';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath fill=\u0022currentColor\u0022 d=\u0022M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z\u0022\/\u003e\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '접기';
        }
        collapseBtn.title = '접기';
      }

      
      if (animate) {
        codeContainer.style.transition = 'max-height 0.3s ease-out';
        setTimeout(() => {
          codeContainer.style.transition = '';
        }, 300);
      }
    }

    function toggleCollapse() {
      setCollapsed(!isCollapsed, true);
    }

    
    collapseBtn.addEventListener('click', toggleCollapse);

    
    if (collapseOverlay) {
      collapseOverlay.addEventListener('click', () => {
        if (isCollapsed) {
          setCollapsed(false, true);
        }
      });
    }

    
    initCollapse();
  }
})();
</script>
<p>✅ <strong>학습 과정</strong></p>
<ol>
<li>입력된 문제와 메타-추론기가 선택한 논리적 추론 방식을 조합하여 학습</li>
<li>Chain-of-Thought (CoT) 방식을 사용하여 단계별 추론 경로를 학습</li>
<li><code>LLM(prompt=&quot;Abductive 추론을 사용하여 문제를 해결하세요.&quot;)</code>와 같은 방식으로 훈련</li>
<li>다양한 논리적 추론 방식(연역, 귀납, 가설, 유추)에 대한 해결 능력을 갖추도록 학습</li>
</ol>
<hr>
<h3 id="4-학습-과정-요약"><strong>4. 학습 과정 요약</strong></h3>
<table>
  <thead>
      <tr>
          <th>단계</th>
          <th>설명</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>Step 1</strong></td>
          <td>데이터셋 구축: 문제 유형별 적절한 추론 방식 라벨링</td>
      </tr>
      <tr>
          <td><strong>Step 2</strong></td>
          <td>메타-추론기(Meta-thinker) 학습: 문제를 분석하여 최적의 논리적 추론 방식 선택</td>
      </tr>
      <tr>
          <td><strong>Step 3</strong></td>
          <td>명시적 메모리(Explicit Memory) 구축: 과거 해결 경험을 저장</td>
      </tr>
      <tr>
          <td><strong>Step 4</strong></td>
          <td>추론기(Reasoner) 학습: 선택된 논리적 추론 방식에 따라 문제 해결 학습</td>
      </tr>
      <tr>
          <td><strong>Step 5</strong></td>
          <td>자기 학습(Self-Training): 새로운 경험을 추가 학습하여 성능 향상</td>
      </tr>
  </tbody>
</table>
<hr>
<h3 id="5-결론"><strong>5. 결론</strong></h3>
<p><strong>TypedThinker를 효과적으로 학습하려면 논리적 추론 방식을 명확하게 라벨링한 데이터셋이 필요하며, 두 단계의 학습 과정(메타-추론기 학습, 추론기 학습)이 진행되어야 한다.</strong><br>
이 과정이 잘 진행되면 모델은 다양한 문제 유형에 대해 <strong>가장 적절한 논리적 추론 방식을 선택</strong>하고, <strong>해당 방식을 적용하여 정확한 문제 해결을 수행</strong>할 수 있다. 🚀</p>
<h1 id="q--이-논문에서-제시한-결과를-자세하게-보고-다른-방법론에-비하여-특출난-점과-논문에서-제기하는-어떠한-방법이-이러한-결과를-도출하게-되었는지-논문에서-제시하는-이유와-너의-생각을-알려줘">Q : 이 논문에서 제시한 결과를 자세하게 보고 다른 방법론에 비하여 특출난 점과 논문에서 제기하는 어떠한 방법이 이러한 결과를 도출하게 되었는지 논문에서 제시하는 이유와 너의 생각을 알려줘</h1>
<h2 id="typedthinker의-실험-결과-분석-및-다른-방법론과의-비교"><strong>TypedThinker의 실험 결과 분석 및 다른 방법론과의 비교</strong></h2>
<h3 id="1-논문의-주요-실험-결과"><strong>1. 논문의 주요 실험 결과</strong></h3>
<p>TypedThinker는 <strong>Mistral 7B</strong>와 <strong>LLaMA3 8B</strong> 두 개의 LLM(대형 언어 모델)을 사용하여 <strong>논리적 추론(LogiQA, BBH) 및 수학적 추론(GSM8K, MATH) 문제 해결 성능</strong>을 평가함.<br>
기존 방법들과 비교하여 성능이 <strong>3.4%~16.7% 향상</strong>됨.</p>
<table>
  <thead>
      <tr>
          <th>모델 및 방법</th>
          <th>LogiQA</th>
          <th>BBH</th>
          <th>GSM8K</th>
          <th>MATH</th>
          <th>평균</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Few-shot</td>
          <td>48.5%</td>
          <td>34.6%</td>
          <td>36.9%</td>
          <td>7.4%</td>
          <td>31.8%</td>
      </tr>
      <tr>
          <td>Few-shot + SC</td>
          <td>53.2%</td>
          <td>44.1%</td>
          <td>44.4%</td>
          <td>13.6%</td>
          <td>38.8%</td>
      </tr>
      <tr>
          <td>CoT Selection</td>
          <td>47.4%</td>
          <td>36.1%</td>
          <td>37.2%</td>
          <td>9.5%</td>
          <td>32.5%</td>
      </tr>
      <tr>
          <td>Few-shot MoR</td>
          <td>50.9%</td>
          <td>45.6%</td>
          <td>46.0%</td>
          <td>12.7%</td>
          <td>38.8%</td>
      </tr>
      <tr>
          <td><strong>TypedThinker</strong></td>
          <td><strong>55.4%</strong></td>
          <td><strong>42.3%</strong></td>
          <td><strong>38.6%</strong></td>
          <td><strong>9.2%</strong></td>
          <td><strong>36.4%</strong></td>
      </tr>
      <tr>
          <td><strong>TypedThinker + SC</strong></td>
          <td><strong>57.0%</strong></td>
          <td><strong>46.9%</strong></td>
          <td><strong>50.0%</strong></td>
          <td><strong>14.9%</strong></td>
          <td><strong>42.2%</strong></td>
      </tr>
  </tbody>
</table>
<p>➡ <strong>특징적인 결과:</strong></p>
<ul>
<li><strong>LLaMA3 8B 모델에서 TypedThinker는 기존 방법보다 16.7% 성능 향상</strong></li>
<li><strong>특히 수학적 문제(GSM8K, MATH)에서는 성능 차이가 더욱 두드러짐</strong></li>
<li><strong>추론 방법을 정확하게 선택하는 것이 중요하며, 무작위적인 추론 방식 적용(MoR)은 성능을 저하시킬 수 있음</strong></li>
</ul>
<hr>
<h3 id="2-다른-방법론과-비교하여-typedthinker가-특출난-점"><strong>2. 다른 방법론과 비교하여 TypedThinker가 특출난 점</strong></h3>
<table>
  <thead>
      <tr>
          <th>방법론</th>
          <th>설명</th>
          <th>한계점</th>
          <th>TypedThinker와의 차별점</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>Few-shot</strong></td>
          <td>기존 LLM이 3~5개의 예제와 함께 문제를 해결</td>
          <td>추론의 다양성이 부족</td>
          <td>다양한 추론 방식을 학습하여 적용 가능</td>
      </tr>
      <tr>
          <td><strong>Few-shot + SC(Self-Consistency)</strong></td>
          <td>동일한 문제를 여러 번 샘플링 후 다수결 방식으로 정답 선택</td>
          <td>정답 선택 과정에서 비효율 발생</td>
          <td>SC를 적용하면서도 올바른 추론 방식을 선택하는 능력 추가</td>
      </tr>
      <tr>
          <td><strong>CoT Selection</strong></td>
          <td>LLM이 스스로 적절한 추론 방식을 선택하도록 유도</td>
          <td>비효율적인 선택이 많음 (60% 이상 비효과적인 선택)</td>
          <td>메타-추론기를 활용해 자동으로 효과적인 추론 방식 선택</td>
      </tr>
      <tr>
          <td><strong>Mixture of Reasoning (MoR)</strong></td>
          <td>모든 추론 방식을 사용하고 다수결을 통해 정답 선택</td>
          <td>잘못된 방식이 다수일 경우 성능 저하</td>
          <td>효과적인 추론 방식만을 선택하여 최적화</td>
      </tr>
  </tbody>
</table>
<p>➡ TypedThinker는 <strong>단순한 CoT(Chain-of-Thought) 방식이나 Mixture of Reasoning(MoR)보다 효과적인 이유</strong>는 다음과 같음.</p>
<hr>
<h3 id="3-typedthinker의-핵심-기법이-실험-결과를-도출한-이유"><strong>3. TypedThinker의 핵심 기법이 실험 결과를 도출한 이유</strong></h3>
<p>논문에서는 TypedThinker의 성능 향상을 다음 3가지 핵심 기법 때문이라고 설명함.</p>
<h4 id="1-메타-추론기meta-thinker의-효과적인-추론-방식-선택"><strong>(1) 메타-추론기(Meta-thinker)의 효과적인 추론 방식 선택</strong></h4>
<p>🔹 <strong>기존 문제점:</strong></p>
<ul>
<li>일반적인 LLM은 적절한 추론 방식을 스스로 선택하는 능력이 부족함.</li>
<li>예를 들어, CoT Selection 방식에서는 연역적 추론(Deductive)이 가장 적절한 상황에서도 귀납적 추론(Inductive)을 선택하는 경우가 많음.</li>
</ul>
<p>🔹 <strong>TypedThinker에서의 해결 방식:</strong></p>
<ul>
<li>**메타-추론기(Meta-thinker)**는 특정 문제 유형에 대해 가장 적절한 추론 방식을 선택하는 역할 수행.</li>
<li>실험 결과, 메타-추론기가 선택한 방식이 <strong>68.3% 확률로 최적의 선택</strong>이었음.</li>
<li>잘못된 추론 방식을 선택하는 확률이 낮아지면서, 결과적으로 성능이 향상됨.</li>
</ul>
<hr>
<h4 id="2-명시적-메모리explicit-memory의-학습-및-검색-최적화"><strong>(2) 명시적 메모리(Explicit Memory)의 학습 및 검색 최적화</strong></h4>
<p>🔹 <strong>기존 문제점:</strong></p>
<ul>
<li>기존 LLM은 특정 문제 유형을 학습한 후에도 유사한 문제를 해결할 때 일관된 방식으로 적용하지 못함.</li>
<li>특히 수학적 문제(MATH)에서 성능이 낮았던 이유는, LLM이 과거 문제 해결 경험을 충분히 활용하지 못했기 때문임.</li>
</ul>
<p>🔹 <strong>TypedThinker에서의 해결 방식:</strong></p>
<ul>
<li>**과거 해결 경험을 저장하는 명시적 메모리(Explicit Memory)**를 활용.</li>
<li>새로운 문제를 해결할 때, 유사한 과거 문제의 해결 방식을 검색하여 참조.</li>
<li>실험 결과, <strong>논리 문제(LogiQA, BBH)에서 Explicit Memory 사용 시 5% 이상 성능 향상</strong>.</li>
</ul>
<hr>
<h4 id="3-자기-학습self-training을-통한-지속적인-최적화"><strong>(3) 자기 학습(Self-Training)을 통한 지속적인 최적화</strong></h4>
<p>🔹 <strong>기존 문제점:</strong></p>
<ul>
<li>LLM이 문제를 해결할 때, 이전에 해결했던 문제에서 배운 경험을 지속적으로 적용하는 능력이 부족함.</li>
<li>즉, 모델이 같은 유형의 문제를 만나더라도 처음 해결하는 것처럼 다시 계산해야 하는 비효율 발생.</li>
</ul>
<p>🔹 <strong>TypedThinker에서의 해결 방식:</strong></p>
<ul>
<li>자기 학습(Self-Training) 기법을 적용하여, <strong>성공적으로 해결한 문제의 해결 과정을 지속적으로 학습</strong>.</li>
<li>이를 통해 <strong>자신이 선택한 추론 방식이 얼마나 효과적인지를 피드백</strong>받아 점진적으로 성능 향상.</li>
<li>실험 결과, 자기 학습을 적용한 후 <strong>LLaMA3 8B에서 최대 16.7% 성능 향상</strong>.</li>
</ul>
<hr>
<h3 id="4-내-생각-추가적인-분석"><strong>4. 내 생각 (추가적인 분석)</strong></h3>
<h4 id="typedthinker의-강점"><strong>TypedThinker의 강점</strong></h4>
<ol>
<li>
<p><strong>추론 방식의 자동 선택이 핵심</strong></p>
<ul>
<li>LLM이 문제를 해결할 때 단순히 &lsquo;추론을 한다&rsquo;가 아니라, <strong>어떤 논리적 사고 과정이 필요한지를 먼저 고려하는 방식</strong>이 매우 혁신적임.</li>
<li>이는 인간의 사고 방식과도 유사하며, <strong>문제를 먼저 분류한 후 해결 방식을 결정하는 과정이 중요</strong>하다는 점을 반영함.</li>
</ul>
</li>
<li>
<p><strong>기존 CoT(Chain-of-Thought)보다 효과적</strong></p>
<ul>
<li>일반적인 CoT 방식에서는 항상 연역적 사고를 기반으로 문제를 해결하려 하지만, 실제로 귀납이나 가설적 사고가 더 효과적인 경우가 많음.</li>
<li>TypedThinker는 <strong>필요한 추론 방식을 선택한 후 적용</strong>하기 때문에 <strong>불필요한 연산을 줄이고, 더욱 효과적인 문제 해결이 가능</strong>.</li>
</ul>
</li>
<li>
<p><strong>강력한 일반화 성능</strong></p>
<ul>
<li><strong>새로운 데이터셋(ContextHub)에서도 기존 모델보다 더 나은 성능을 보임</strong>.</li>
<li>즉, 특정 데이터에 과적합되지 않고, 다양한 유형의 문제를 해결할 수 있도록 설계됨.</li>
</ul>
</li>
</ol>
<h4 id="typedthinker의-한계점-및-개선-방향"><strong>TypedThinker의 한계점 및 개선 방향</strong></h4>
<ol>
<li>
<p><strong>복합적인 추론 방식 조합이 부족</strong></p>
<ul>
<li>현재 한 문제에 대해 <strong>하나의 추론 방식만을 선택</strong>하지만, 실제로는 <strong>여러 개의 추론 방식이 함께 필요할 수도 있음</strong>.</li>
<li>예를 들어, 수학 문제에서 귀납적으로 패턴을 찾은 후, 연역적으로 풀어야 하는 경우가 있음.</li>
</ul>
</li>
<li>
<p><strong>메모리 검색의 정확도 향상 필요</strong></p>
<ul>
<li>명시적 메모리가 과거 데이터를 활용한다고 하지만, 검색 방식(코사인 유사도)이 단순할 가능성이 있음.</li>
<li>보다 <strong>정교한 검색 기법(강화 학습 기반 메모리 검색)을 적용하면 더욱 향상된 성능이 기대됨</strong>.</li>
</ul>
</li>
</ol>
<hr>
<h3 id="5-결론-1"><strong>5. 결론</strong></h3>
<p><strong>TypedThinker는 기존 LLM의 문제 해결 방식을 크게 개선하는 혁신적인 접근 방식으로, 추론 방식 선택, 메모리 활용, 자기 학습을 결합하여 성능을 크게 향상시킨다.</strong> 🚀</p>
<h1 id="q--이-논문에서-제시된-방법을-실제로-사용하려면-기존-방법에서-어떠한-구현이-추가적으로-필요하고-이러한-구현에-소모되는-공수-및-연산에-필요한-컴퓨팅-자원의-크기에-대해서-계산해줄-수-있겠니">Q : 이 논문에서 제시된 방법을 실제로 사용하려면 기존 방법에서 어떠한 구현이 추가적으로 필요하고 이러한 구현에 소모되는 공수 및 연산에 필요한 컴퓨팅 자원의 크기에 대해서 계산해줄 수 있겠니?</h1>
<h2 id="typedthinker의-실험-결과-분석-및-다른-방법론과의-비교-1"><strong>TypedThinker의 실험 결과 분석 및 다른 방법론과의 비교</strong></h2>
<h3 id="1-논문의-주요-실험-결과-1"><strong>1. 논문의 주요 실험 결과</strong></h3>
<p>TypedThinker는 <strong>Mistral 7B</strong>와 <strong>LLaMA3 8B</strong> 두 개의 LLM(대형 언어 모델)을 사용하여 <strong>논리적 추론(LogiQA, BBH) 및 수학적 추론(GSM8K, MATH) 문제 해결 성능</strong>을 평가함.<br>
기존 방법들과 비교하여 성능이 <strong>3.4%~16.7% 향상</strong>됨.</p>
<table>
  <thead>
      <tr>
          <th>모델 및 방법</th>
          <th>LogiQA</th>
          <th>BBH</th>
          <th>GSM8K</th>
          <th>MATH</th>
          <th>평균</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Few-shot</td>
          <td>48.5%</td>
          <td>34.6%</td>
          <td>36.9%</td>
          <td>7.4%</td>
          <td>31.8%</td>
      </tr>
      <tr>
          <td>Few-shot + SC</td>
          <td>53.2%</td>
          <td>44.1%</td>
          <td>44.4%</td>
          <td>13.6%</td>
          <td>38.8%</td>
      </tr>
      <tr>
          <td>CoT Selection</td>
          <td>47.4%</td>
          <td>36.1%</td>
          <td>37.2%</td>
          <td>9.5%</td>
          <td>32.5%</td>
      </tr>
      <tr>
          <td>Few-shot MoR</td>
          <td>50.9%</td>
          <td>45.6%</td>
          <td>46.0%</td>
          <td>12.7%</td>
          <td>38.8%</td>
      </tr>
      <tr>
          <td><strong>TypedThinker</strong></td>
          <td><strong>55.4%</strong></td>
          <td><strong>42.3%</strong></td>
          <td><strong>38.6%</strong></td>
          <td><strong>9.2%</strong></td>
          <td><strong>36.4%</strong></td>
      </tr>
      <tr>
          <td><strong>TypedThinker + SC</strong></td>
          <td><strong>57.0%</strong></td>
          <td><strong>46.9%</strong></td>
          <td><strong>50.0%</strong></td>
          <td><strong>14.9%</strong></td>
          <td><strong>42.2%</strong></td>
      </tr>
  </tbody>
</table>
<p>➡ <strong>특징적인 결과:</strong></p>
<ul>
<li><strong>LLaMA3 8B 모델에서 TypedThinker는 기존 방법보다 16.7% 성능 향상</strong></li>
<li><strong>특히 수학적 문제(GSM8K, MATH)에서는 성능 차이가 더욱 두드러짐</strong></li>
<li><strong>추론 방법을 정확하게 선택하는 것이 중요하며, 무작위적인 추론 방식 적용(MoR)은 성능을 저하시킬 수 있음</strong></li>
</ul>
<hr>
<h3 id="2-다른-방법론과-비교하여-typedthinker가-특출난-점-1"><strong>2. 다른 방법론과 비교하여 TypedThinker가 특출난 점</strong></h3>
<table>
  <thead>
      <tr>
          <th>방법론</th>
          <th>설명</th>
          <th>한계점</th>
          <th>TypedThinker와의 차별점</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>Few-shot</strong></td>
          <td>기존 LLM이 3~5개의 예제와 함께 문제를 해결</td>
          <td>추론의 다양성이 부족</td>
          <td>다양한 추론 방식을 학습하여 적용 가능</td>
      </tr>
      <tr>
          <td><strong>Few-shot + SC(Self-Consistency)</strong></td>
          <td>동일한 문제를 여러 번 샘플링 후 다수결 방식으로 정답 선택</td>
          <td>정답 선택 과정에서 비효율 발생</td>
          <td>SC를 적용하면서도 올바른 추론 방식을 선택하는 능력 추가</td>
      </tr>
      <tr>
          <td><strong>CoT Selection</strong></td>
          <td>LLM이 스스로 적절한 추론 방식을 선택하도록 유도</td>
          <td>비효율적인 선택이 많음 (60% 이상 비효과적인 선택)</td>
          <td>메타-추론기를 활용해 자동으로 효과적인 추론 방식 선택</td>
      </tr>
      <tr>
          <td><strong>Mixture of Reasoning (MoR)</strong></td>
          <td>모든 추론 방식을 사용하고 다수결을 통해 정답 선택</td>
          <td>잘못된 방식이 다수일 경우 성능 저하</td>
          <td>효과적인 추론 방식만을 선택하여 최적화</td>
      </tr>
  </tbody>
</table>
<p>➡ TypedThinker는 <strong>단순한 CoT(Chain-of-Thought) 방식이나 Mixture of Reasoning(MoR)보다 효과적인 이유</strong>는 다음과 같음.</p>
<hr>
<h3 id="3-typedthinker의-핵심-기법이-실험-결과를-도출한-이유-1"><strong>3. TypedThinker의 핵심 기법이 실험 결과를 도출한 이유</strong></h3>
<p>논문에서는 TypedThinker의 성능 향상을 다음 3가지 핵심 기법 때문이라고 설명함.</p>
<h4 id="1-메타-추론기meta-thinker의-효과적인-추론-방식-선택-1"><strong>(1) 메타-추론기(Meta-thinker)의 효과적인 추론 방식 선택</strong></h4>
<p>🔹 <strong>기존 문제점:</strong></p>
<ul>
<li>일반적인 LLM은 적절한 추론 방식을 스스로 선택하는 능력이 부족함.</li>
<li>예를 들어, CoT Selection 방식에서는 연역적 추론(Deductive)이 가장 적절한 상황에서도 귀납적 추론(Inductive)을 선택하는 경우가 많음.</li>
</ul>
<p>🔹 <strong>TypedThinker에서의 해결 방식:</strong></p>
<ul>
<li>**메타-추론기(Meta-thinker)**는 특정 문제 유형에 대해 가장 적절한 추론 방식을 선택하는 역할 수행.</li>
<li>실험 결과, 메타-추론기가 선택한 방식이 <strong>68.3% 확률로 최적의 선택</strong>이었음.</li>
<li>잘못된 추론 방식을 선택하는 확률이 낮아지면서, 결과적으로 성능이 향상됨.</li>
</ul>
<hr>
<h4 id="2-명시적-메모리explicit-memory의-학습-및-검색-최적화-1"><strong>(2) 명시적 메모리(Explicit Memory)의 학습 및 검색 최적화</strong></h4>
<p>🔹 <strong>기존 문제점:</strong></p>
<ul>
<li>기존 LLM은 특정 문제 유형을 학습한 후에도 유사한 문제를 해결할 때 일관된 방식으로 적용하지 못함.</li>
<li>특히 수학적 문제(MATH)에서 성능이 낮았던 이유는, LLM이 과거 문제 해결 경험을 충분히 활용하지 못했기 때문임.</li>
</ul>
<p>🔹 <strong>TypedThinker에서의 해결 방식:</strong></p>
<ul>
<li>**과거 해결 경험을 저장하는 명시적 메모리(Explicit Memory)**를 활용.</li>
<li>새로운 문제를 해결할 때, 유사한 과거 문제의 해결 방식을 검색하여 참조.</li>
<li>실험 결과, <strong>논리 문제(LogiQA, BBH)에서 Explicit Memory 사용 시 5% 이상 성능 향상</strong>.</li>
</ul>
<hr>
<h4 id="3-자기-학습self-training을-통한-지속적인-최적화-1"><strong>(3) 자기 학습(Self-Training)을 통한 지속적인 최적화</strong></h4>
<p>🔹 <strong>기존 문제점:</strong></p>
<ul>
<li>LLM이 문제를 해결할 때, 이전에 해결했던 문제에서 배운 경험을 지속적으로 적용하는 능력이 부족함.</li>
<li>즉, 모델이 같은 유형의 문제를 만나더라도 처음 해결하는 것처럼 다시 계산해야 하는 비효율 발생.</li>
</ul>
<p>🔹 <strong>TypedThinker에서의 해결 방식:</strong></p>
<ul>
<li>자기 학습(Self-Training) 기법을 적용하여, <strong>성공적으로 해결한 문제의 해결 과정을 지속적으로 학습</strong>.</li>
<li>이를 통해 <strong>자신이 선택한 추론 방식이 얼마나 효과적인지를 피드백</strong>받아 점진적으로 성능 향상.</li>
<li>실험 결과, 자기 학습을 적용한 후 <strong>LLaMA3 8B에서 최대 16.7% 성능 향상</strong>.</li>
</ul>
<hr>
<h3 id="4-내-생각-추가적인-분석-1"><strong>4. 내 생각 (추가적인 분석)</strong></h3>
<h4 id="typedthinker의-강점-1"><strong>TypedThinker의 강점</strong></h4>
<ol>
<li>
<p><strong>추론 방식의 자동 선택이 핵심</strong></p>
<ul>
<li>LLM이 문제를 해결할 때 단순히 &lsquo;추론을 한다&rsquo;가 아니라, <strong>어떤 논리적 사고 과정이 필요한지를 먼저 고려하는 방식</strong>이 매우 혁신적임.</li>
<li>이는 인간의 사고 방식과도 유사하며, <strong>문제를 먼저 분류한 후 해결 방식을 결정하는 과정이 중요</strong>하다는 점을 반영함.</li>
</ul>
</li>
<li>
<p><strong>기존 CoT(Chain-of-Thought)보다 효과적</strong></p>
<ul>
<li>일반적인 CoT 방식에서는 항상 연역적 사고를 기반으로 문제를 해결하려 하지만, 실제로 귀납이나 가설적 사고가 더 효과적인 경우가 많음.</li>
<li>TypedThinker는 <strong>필요한 추론 방식을 선택한 후 적용</strong>하기 때문에 <strong>불필요한 연산을 줄이고, 더욱 효과적인 문제 해결이 가능</strong>.</li>
</ul>
</li>
<li>
<p><strong>강력한 일반화 성능</strong></p>
<ul>
<li><strong>새로운 데이터셋(ContextHub)에서도 기존 모델보다 더 나은 성능을 보임</strong>.</li>
<li>즉, 특정 데이터에 과적합되지 않고, 다양한 유형의 문제를 해결할 수 있도록 설계됨.</li>
</ul>
</li>
</ol>
<h4 id="typedthinker의-한계점-및-개선-방향-1"><strong>TypedThinker의 한계점 및 개선 방향</strong></h4>
<ol>
<li>
<p><strong>복합적인 추론 방식 조합이 부족</strong></p>
<ul>
<li>현재 한 문제에 대해 <strong>하나의 추론 방식만을 선택</strong>하지만, 실제로는 <strong>여러 개의 추론 방식이 함께 필요할 수도 있음</strong>.</li>
<li>예를 들어, 수학 문제에서 귀납적으로 패턴을 찾은 후, 연역적으로 풀어야 하는 경우가 있음.</li>
</ul>
</li>
<li>
<p><strong>메모리 검색의 정확도 향상 필요</strong></p>
<ul>
<li>명시적 메모리가 과거 데이터를 활용한다고 하지만, 검색 방식(코사인 유사도)이 단순할 가능성이 있음.</li>
<li>보다 <strong>정교한 검색 기법(강화 학습 기반 메모리 검색)을 적용하면 더욱 향상된 성능이 기대됨</strong>.</li>
</ul>
</li>
</ol>
<hr>
<h3 id="5-결론-2"><strong>5. 결론</strong></h3>
<p><strong>TypedThinker는 기존 LLM의 문제 해결 방식을 크게 개선하는 혁신적인 접근 방식으로, 추론 방식 선택, 메모리 활용, 자기 학습을 결합하여 성능을 크게 향상시킨다.</strong> 🚀</p>
<h1 id="q--이-논문의-입력데이터와-추론-과정에-대해서-예시를-들어-아주-자세하게-설명해-주겠니-추가적으로-모델아키텍처의-구성-및-모델을-구성하는-연산과-메모리-요구량-컴퓨팅-요구량-대해서도-설명해줘">Q : 이 논문의 입력데이터와 추론 과정에 대해서 예시를 들어 아주 자세하게 설명해 주겠니? 추가적으로 모델아키텍처의 구성 및 모델을 구성하는 연산과 메모리 요구량 컴퓨팅 요구량 대해서도 설명해줘</h1>
<h2 id="논문의-입력-데이터-및-추론-과정-상세-설명"><strong>논문의 입력 데이터 및 추론 과정 상세 설명</strong></h2>
<h3 id="1-입력-데이터-구조"><strong>1. 입력 데이터 구조</strong></h3>
<p>TypedThinker의 입력 데이터는 일반적인 LLM과 차별화된 **추론 방식(reasoning type)**과 **문제 유형(problem type)**을 포함하는 것이 특징이다.</p>
<p>입력 데이터는 다음과 같은 구조를 가진다:</p>
<table>
  <thead>
      <tr>
          <th><strong>필드</strong></th>
          <th><strong>설명</strong></th>
          <th><strong>예제</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>문제(problem)</strong></td>
          <td>해결해야 할 문제</td>
          <td>&ldquo;John은 아버지보다 24살 어리다. 두 사람의 나이 합이 68살이다. John의 나이는?&rdquo;</td>
      </tr>
      <tr>
          <td><strong>문제 유형(problem type)</strong></td>
          <td>논리 문제인지, 수학 문제인지</td>
          <td>&ldquo;수학 문제&rdquo;</td>
      </tr>
      <tr>
          <td><strong>선택 가능한 추론 방식(reasoning types)</strong></td>
          <td>연역, 귀납, 가설, 유추</td>
          <td>[&ldquo;Deductive&rdquo;, &ldquo;Inductive&rdquo;, &ldquo;Abductive&rdquo;, &ldquo;Analogical&rdquo;]</td>
      </tr>
      <tr>
          <td><strong>메타-추론기 예측(meta-thinker output)</strong></td>
          <td>문제에 적절한 추론 방식 선택</td>
          <td>{&ldquo;Abductive&rdquo;: 0.6, &ldquo;Deductive&rdquo;: 0.4, &ldquo;Inductive&rdquo;: 0.5, &ldquo;Analogical&rdquo;: 0.4}</td>
      </tr>
      <tr>
          <td><strong>명시적 메모리 검색(explicit memory retrieval)</strong></td>
          <td>과거 유사한 문제 및 해결 과정</td>
          <td>&ldquo;Lisa는 어머니보다 10살 어리다. 두 사람의 나이 합이 70살이다. Lisa는 몇 살인가? 정답: 30살&rdquo;</td>
      </tr>
  </tbody>
</table>
<hr>
<h3 id="2-예제-입력-데이터"><strong>2. 예제 입력 데이터</strong></h3>
<div
  class="code-block-container border-border bg-card my-6 overflow-hidden rounded-xl border shadow-sm transition-all duration-200 ease-out hover:-translate-y-0.5 hover:shadow-md">
  
  <div
    class="code-block-header bg-muted/30 border-border flex items-center justify-between border-b px-4 py-3">
    
    <div class="flex items-center gap-2">
      <div class="text-muted-foreground flex-shrink-0">
        
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4" />
</svg>
      </div>
      <span class="text-muted-foreground text-sm font-medium">
        JSON
      </span>
    </div>

    
    <div class="flex items-center gap-2">
      <button
          class="collapse-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
          data-code-id="code-10"
          data-default-state="expanded"
          data-collapsed="false"
          data-auto-collapse-lines="30"
          data-auto-collapse-height="400"
          data-collapsed-height="120"
          title="접기"
          aria-label="접기">
          <span class="collapse-icon">
            
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path fill="currentColor" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z"/></svg>
          </span>
          <span class="collapse-text hidden sm:inline"
            >접기</span
          >
        </button>
      <button
        class="copy-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
        data-code-id="code-10"
        title="복사"
        aria-label="복사">
        <span class="copy-icon">
          
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
</svg>
        </span>
        <span class="copy-text hidden sm:inline"
          >복사</span
        >
      </button>
    </div>
  </div>

  
  <div class="code-block-content relative" id="code-10">
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">  <span class="nt">&#34;problem&#34;</span><span class="p">:</span> <span class="s2">&#34;John은 아버지보다 24살 어리다. 두 사람의 나이 합이 68살이다. John의 나이는?&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">  <span class="nt">&#34;problem_type&#34;</span><span class="p">:</span> <span class="s2">&#34;수학 문제&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">  <span class="nt">&#34;reasoning_types&#34;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&#34;Deductive&#34;</span><span class="p">,</span> <span class="s2">&#34;Inductive&#34;</span><span class="p">,</span> <span class="s2">&#34;Abductive&#34;</span><span class="p">,</span> <span class="s2">&#34;Analogical&#34;</span><span class="p">],</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">  <span class="nt">&#34;meta_thinker_output&#34;</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="nt">&#34;Abductive&#34;</span><span class="p">:</span> <span class="mf">0.6</span><span class="p">,</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="nt">&#34;Deductive&#34;</span><span class="p">:</span> <span class="mf">0.4</span><span class="p">,</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="nt">&#34;Inductive&#34;</span><span class="p">:</span> <span class="mf">0.5</span><span class="p">,</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="nt">&#34;Analogical&#34;</span><span class="p">:</span> <span class="mf">0.4</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">  <span class="p">},</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">  <span class="nt">&#34;explicit_memory&#34;</span><span class="p">:</span> <span class="p">[</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">      <span class="nt">&#34;problem&#34;</span><span class="p">:</span> <span class="s2">&#34;Lisa는 어머니보다 10살 어리다. 두 사람의 나이 합이 70살이다. Lisa는 몇 살인가?&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">      <span class="nt">&#34;solution&#34;</span><span class="p">:</span> <span class="s2">&#34;x + (x + 10) = 70 → x = 30&#34;</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">  <span class="p">]</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="p">}</span></span></span></code></pre></div>
    
    <div
      class="collapse-overlay to-card/90 pointer-events-none absolute inset-0 bg-gradient-to-b from-transparent via-transparent opacity-0 transition-opacity duration-300">
      <div
        class="text-muted-foreground bg-card/80 border-border/50 hover:bg-primary/10 hover:text-primary hover:border-primary/30 absolute bottom-4 left-1/2 -translate-x-1/2 cursor-pointer rounded-full border px-3 py-1.5 text-xs backdrop-blur-sm transition-all duration-200">
        클릭하여 더 보기
      </div>
    </div>
  </div>
</div>


<script>
(function() {
  const codeId = 'code-10';
  const copyBtn = document.querySelector('.copy-code-btn[data-code-id="' + codeId + '"]');
  const collapseBtn = document.querySelector('.collapse-code-btn[data-code-id="' + codeId + '"]');
  const codeContainer = document.getElementById(codeId);

  if (!codeContainer) return;

  
  if (copyBtn) {
    const copyIcon = copyBtn.querySelector('.copy-icon');
    const copyText = copyBtn.querySelector('.copy-text');

    copyBtn.addEventListener('click', async function() {
      try {
        
        let codeText = '';

        
        const codeTableCell = codeContainer.querySelector('.lntd:last-child code');
        if (codeTableCell) {
          codeText = codeTableCell.textContent || codeTableCell.innerText;
        } else {
          
          const codeElement = codeContainer.querySelector('code');
          if (codeElement) {
            
            const hasInlineLineNumbers = codeElement.querySelector('.ln');
            if (hasInlineLineNumbers) {
              
              const codeLines = codeElement.querySelectorAll('.cl');
              if (codeLines.length > 0) {
                codeText = Array.from(codeLines)
                  .map(line => {
                    const text = line.textContent || line.innerText;
                    
                    return text.replace(/\n+$/, '');
                  })
                  .join('\n')
                  .replace(/\n+$/, ''); 
              } else {
                
                const allText = codeElement.textContent || codeElement.innerText;
                codeText = allText.replace(/^\d+/gm, '').replace(/^\s+/gm, '');
              }
            } else {
              
              codeText = codeElement.textContent || codeElement.innerText;
            }
          } else {
            
            codeText = codeContainer.textContent || codeContainer.innerText;
          }
        }

        
        codeText = codeText.trim();

        
        await navigator.clipboard.writeText(codeText);

        
        copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M5 13l4 4L19 7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (copyText) {
          copyText.textContent = '복사됨';
        }
        copyBtn.classList.add('text-green-600');

        
        setTimeout(() => {
          copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z\u0022 \/\u003e\n\u003c\/svg\u003e`;
          if (copyText) {
            copyText.textContent = '복사';
          }
          copyBtn.classList.remove('text-green-600');
        }, 2000);

      } catch (err) {
        console.error('复制失败:', err);

        
        const range = document.createRange();
        const codeElement = codeContainer.querySelector('code') || codeContainer;
        range.selectNodeContents(codeElement);
        const selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);

        
        if (copyText) {
          copyText.textContent = '선택됨';
        }

        setTimeout(() => {
          if (copyText) {
            copyText.textContent = '복사';
          }
          selection.removeAllRanges();
        }, 2000);
      }
    });
  }

  
  if (collapseBtn) {
    const collapseIcon = collapseBtn.querySelector('.collapse-icon');
    const collapseText = collapseBtn.querySelector('.collapse-text');
    const collapseOverlay = codeContainer.querySelector('.collapse-overlay');

    
    let codeElement = codeContainer.querySelector('pre.chroma');
    if (!codeElement) {
      codeElement = codeContainer.querySelector('pre');
    }

    const defaultState = collapseBtn.dataset.defaultState || 'expanded';
    const isCollapsedAttr = collapseBtn.dataset.collapsed === 'true';
    const autoCollapseLines = parseInt(collapseBtn.dataset.autoCollapseLines) || 30;
    const autoCollapseHeight = parseInt(collapseBtn.dataset.autoCollapseHeight) || 400;
    const collapsedHeight = parseInt(collapseBtn.dataset.collapsedHeight) || 120;

    let isCollapsed = false;

    
    function initCollapse() {
      
      const shouldCollapse = isCollapsedAttr ||
                           defaultState === 'collapsed' ||
                           shouldAutoCollapse();

      if (shouldCollapse) {
        setCollapsed(true, false); 
      }
    }

    function shouldAutoCollapse() {
      
      if (codeElement) {
        const lines = codeElement.querySelectorAll('.line, .cl');
        const height = codeElement.offsetHeight;
        return lines.length > autoCollapseLines || height > autoCollapseHeight;
      }

      
      const containerHeight = codeContainer.offsetHeight;
      if (containerHeight > autoCollapseHeight) {
        return true;
      }

      
      const textContent = codeContainer.textContent || codeContainer.innerText || '';
      const estimatedLines = textContent.split('\n').length;
      return estimatedLines > autoCollapseLines;
    }

    function setCollapsed(collapsed, animate = true) {
      if (!collapseOverlay) return;

      isCollapsed = collapsed;

      if (collapsed) {
        
        codeContainer.style.maxHeight = collapsedHeight + 'px';
        codeContainer.style.overflow = 'hidden';
        collapseOverlay.style.opacity = '1';
        collapseOverlay.style.pointerEvents = 'auto';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M19 9l-7 7-7-7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '펼치기';
        }
        collapseBtn.title = '펼치기';

      } else {
        
        codeContainer.style.maxHeight = '';
        codeContainer.style.overflow = '';
        collapseOverlay.style.opacity = '0';
        collapseOverlay.style.pointerEvents = 'none';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath fill=\u0022currentColor\u0022 d=\u0022M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z\u0022\/\u003e\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '접기';
        }
        collapseBtn.title = '접기';
      }

      
      if (animate) {
        codeContainer.style.transition = 'max-height 0.3s ease-out';
        setTimeout(() => {
          codeContainer.style.transition = '';
        }, 300);
      }
    }

    function toggleCollapse() {
      setCollapsed(!isCollapsed, true);
    }

    
    collapseBtn.addEventListener('click', toggleCollapse);

    
    if (collapseOverlay) {
      collapseOverlay.addEventListener('click', () => {
        if (isCollapsed) {
          setCollapsed(false, true);
        }
      });
    }

    
    initCollapse();
  }
})();
</script>
<hr>
<h3 id="3-추론-과정-step-by-step"><strong>3. 추론 과정 (Step-by-Step)</strong></h3>
<p>TypedThinker의 추론 과정은 크게 **메타-추론기(Meta-thinker), 명시적 메모리(Explicit Memory), 추론기(Reasoner)**로 나뉜다.</p>
<hr>
<h4 id="-step-1-메타-추론기meta-thinker---가장-적절한-추론-방식-선택"><strong>🔹 Step 1: 메타-추론기(Meta-thinker) - 가장 적절한 추론 방식 선택</strong></h4>
<ul>
<li>모델이 입력 문제를 분석한 후, 어떤 추론 방식을 적용할지 확률적으로 결정</li>
<li>위 예제에서는 **Abductive(가설적 추론)**이 가장 높은 점수를 받음 (0.6)</li>
</ul>
<p>✅ <strong>출력 예시</strong>:</p>
<div
  class="code-block-container border-border bg-card my-6 overflow-hidden rounded-xl border shadow-sm transition-all duration-200 ease-out hover:-translate-y-0.5 hover:shadow-md">
  
  <div
    class="code-block-header bg-muted/30 border-border flex items-center justify-between border-b px-4 py-3">
    
    <div class="flex items-center gap-2">
      <div class="text-muted-foreground flex-shrink-0">
        
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4" />
</svg>
      </div>
      <span class="text-muted-foreground text-sm font-medium">
        JSON
      </span>
    </div>

    
    <div class="flex items-center gap-2">
      <button
          class="collapse-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
          data-code-id="code-11"
          data-default-state="expanded"
          data-collapsed="false"
          data-auto-collapse-lines="30"
          data-auto-collapse-height="400"
          data-collapsed-height="120"
          title="접기"
          aria-label="접기">
          <span class="collapse-icon">
            
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path fill="currentColor" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z"/></svg>
          </span>
          <span class="collapse-text hidden sm:inline"
            >접기</span
          >
        </button>
      <button
        class="copy-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
        data-code-id="code-11"
        title="복사"
        aria-label="복사">
        <span class="copy-icon">
          
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
</svg>
        </span>
        <span class="copy-text hidden sm:inline"
          >복사</span
        >
      </button>
    </div>
  </div>

  
  <div class="code-block-content relative" id="code-11">
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="line"><span class="ln">1</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl">  <span class="nt">&#34;selected_reasoning_type&#34;</span><span class="p">:</span> <span class="s2">&#34;Abductive&#34;</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="p">}</span></span></span></code></pre></div>
    
    <div
      class="collapse-overlay to-card/90 pointer-events-none absolute inset-0 bg-gradient-to-b from-transparent via-transparent opacity-0 transition-opacity duration-300">
      <div
        class="text-muted-foreground bg-card/80 border-border/50 hover:bg-primary/10 hover:text-primary hover:border-primary/30 absolute bottom-4 left-1/2 -translate-x-1/2 cursor-pointer rounded-full border px-3 py-1.5 text-xs backdrop-blur-sm transition-all duration-200">
        클릭하여 더 보기
      </div>
    </div>
  </div>
</div>


<script>
(function() {
  const codeId = 'code-11';
  const copyBtn = document.querySelector('.copy-code-btn[data-code-id="' + codeId + '"]');
  const collapseBtn = document.querySelector('.collapse-code-btn[data-code-id="' + codeId + '"]');
  const codeContainer = document.getElementById(codeId);

  if (!codeContainer) return;

  
  if (copyBtn) {
    const copyIcon = copyBtn.querySelector('.copy-icon');
    const copyText = copyBtn.querySelector('.copy-text');

    copyBtn.addEventListener('click', async function() {
      try {
        
        let codeText = '';

        
        const codeTableCell = codeContainer.querySelector('.lntd:last-child code');
        if (codeTableCell) {
          codeText = codeTableCell.textContent || codeTableCell.innerText;
        } else {
          
          const codeElement = codeContainer.querySelector('code');
          if (codeElement) {
            
            const hasInlineLineNumbers = codeElement.querySelector('.ln');
            if (hasInlineLineNumbers) {
              
              const codeLines = codeElement.querySelectorAll('.cl');
              if (codeLines.length > 0) {
                codeText = Array.from(codeLines)
                  .map(line => {
                    const text = line.textContent || line.innerText;
                    
                    return text.replace(/\n+$/, '');
                  })
                  .join('\n')
                  .replace(/\n+$/, ''); 
              } else {
                
                const allText = codeElement.textContent || codeElement.innerText;
                codeText = allText.replace(/^\d+/gm, '').replace(/^\s+/gm, '');
              }
            } else {
              
              codeText = codeElement.textContent || codeElement.innerText;
            }
          } else {
            
            codeText = codeContainer.textContent || codeContainer.innerText;
          }
        }

        
        codeText = codeText.trim();

        
        await navigator.clipboard.writeText(codeText);

        
        copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M5 13l4 4L19 7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (copyText) {
          copyText.textContent = '복사됨';
        }
        copyBtn.classList.add('text-green-600');

        
        setTimeout(() => {
          copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z\u0022 \/\u003e\n\u003c\/svg\u003e`;
          if (copyText) {
            copyText.textContent = '복사';
          }
          copyBtn.classList.remove('text-green-600');
        }, 2000);

      } catch (err) {
        console.error('复制失败:', err);

        
        const range = document.createRange();
        const codeElement = codeContainer.querySelector('code') || codeContainer;
        range.selectNodeContents(codeElement);
        const selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);

        
        if (copyText) {
          copyText.textContent = '선택됨';
        }

        setTimeout(() => {
          if (copyText) {
            copyText.textContent = '복사';
          }
          selection.removeAllRanges();
        }, 2000);
      }
    });
  }

  
  if (collapseBtn) {
    const collapseIcon = collapseBtn.querySelector('.collapse-icon');
    const collapseText = collapseBtn.querySelector('.collapse-text');
    const collapseOverlay = codeContainer.querySelector('.collapse-overlay');

    
    let codeElement = codeContainer.querySelector('pre.chroma');
    if (!codeElement) {
      codeElement = codeContainer.querySelector('pre');
    }

    const defaultState = collapseBtn.dataset.defaultState || 'expanded';
    const isCollapsedAttr = collapseBtn.dataset.collapsed === 'true';
    const autoCollapseLines = parseInt(collapseBtn.dataset.autoCollapseLines) || 30;
    const autoCollapseHeight = parseInt(collapseBtn.dataset.autoCollapseHeight) || 400;
    const collapsedHeight = parseInt(collapseBtn.dataset.collapsedHeight) || 120;

    let isCollapsed = false;

    
    function initCollapse() {
      
      const shouldCollapse = isCollapsedAttr ||
                           defaultState === 'collapsed' ||
                           shouldAutoCollapse();

      if (shouldCollapse) {
        setCollapsed(true, false); 
      }
    }

    function shouldAutoCollapse() {
      
      if (codeElement) {
        const lines = codeElement.querySelectorAll('.line, .cl');
        const height = codeElement.offsetHeight;
        return lines.length > autoCollapseLines || height > autoCollapseHeight;
      }

      
      const containerHeight = codeContainer.offsetHeight;
      if (containerHeight > autoCollapseHeight) {
        return true;
      }

      
      const textContent = codeContainer.textContent || codeContainer.innerText || '';
      const estimatedLines = textContent.split('\n').length;
      return estimatedLines > autoCollapseLines;
    }

    function setCollapsed(collapsed, animate = true) {
      if (!collapseOverlay) return;

      isCollapsed = collapsed;

      if (collapsed) {
        
        codeContainer.style.maxHeight = collapsedHeight + 'px';
        codeContainer.style.overflow = 'hidden';
        collapseOverlay.style.opacity = '1';
        collapseOverlay.style.pointerEvents = 'auto';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M19 9l-7 7-7-7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '펼치기';
        }
        collapseBtn.title = '펼치기';

      } else {
        
        codeContainer.style.maxHeight = '';
        codeContainer.style.overflow = '';
        collapseOverlay.style.opacity = '0';
        collapseOverlay.style.pointerEvents = 'none';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath fill=\u0022currentColor\u0022 d=\u0022M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z\u0022\/\u003e\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '접기';
        }
        collapseBtn.title = '접기';
      }

      
      if (animate) {
        codeContainer.style.transition = 'max-height 0.3s ease-out';
        setTimeout(() => {
          codeContainer.style.transition = '';
        }, 300);
      }
    }

    function toggleCollapse() {
      setCollapsed(!isCollapsed, true);
    }

    
    collapseBtn.addEventListener('click', toggleCollapse);

    
    if (collapseOverlay) {
      collapseOverlay.addEventListener('click', () => {
        if (isCollapsed) {
          setCollapsed(false, true);
        }
      });
    }

    
    initCollapse();
  }
})();
</script>
<hr>
<h4 id="-step-2-명시적-메모리-검색explicit-memory-retrieval"><strong>🔹 Step 2: 명시적 메모리 검색(Explicit Memory Retrieval)</strong></h4>
<ul>
<li>선택된 추론 방식(Abductive)을 기준으로, 과거의 유사한 문제를 검색</li>
<li>유사한 문제 **(&ldquo;Lisa의 나이 문제&rdquo;)**가 검색되어, 해당 해결 방법을 참조</li>
</ul>
<p>✅ <strong>출력 예시</strong>:</p>
<div
  class="code-block-container border-border bg-card my-6 overflow-hidden rounded-xl border shadow-sm transition-all duration-200 ease-out hover:-translate-y-0.5 hover:shadow-md">
  
  <div
    class="code-block-header bg-muted/30 border-border flex items-center justify-between border-b px-4 py-3">
    
    <div class="flex items-center gap-2">
      <div class="text-muted-foreground flex-shrink-0">
        
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4" />
</svg>
      </div>
      <span class="text-muted-foreground text-sm font-medium">
        JSON
      </span>
    </div>

    
    <div class="flex items-center gap-2">
      <button
          class="collapse-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
          data-code-id="code-12"
          data-default-state="expanded"
          data-collapsed="false"
          data-auto-collapse-lines="30"
          data-auto-collapse-height="400"
          data-collapsed-height="120"
          title="접기"
          aria-label="접기">
          <span class="collapse-icon">
            
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path fill="currentColor" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z"/></svg>
          </span>
          <span class="collapse-text hidden sm:inline"
            >접기</span
          >
        </button>
      <button
        class="copy-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
        data-code-id="code-12"
        title="복사"
        aria-label="복사">
        <span class="copy-icon">
          
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
</svg>
        </span>
        <span class="copy-text hidden sm:inline"
          >복사</span
        >
      </button>
    </div>
  </div>

  
  <div class="code-block-content relative" id="code-12">
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="line"><span class="ln">1</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl">  <span class="nt">&#34;retrieved_example&#34;</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="nt">&#34;problem&#34;</span><span class="p">:</span> <span class="s2">&#34;Lisa는 어머니보다 10살 어리다. 두 사람의 나이 합이 70살이다. Lisa는 몇 살인가?&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">    <span class="nt">&#34;solution&#34;</span><span class="p">:</span> <span class="s2">&#34;x + (x + 10) = 70 → x = 30&#34;</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="p">}</span></span></span></code></pre></div>
    
    <div
      class="collapse-overlay to-card/90 pointer-events-none absolute inset-0 bg-gradient-to-b from-transparent via-transparent opacity-0 transition-opacity duration-300">
      <div
        class="text-muted-foreground bg-card/80 border-border/50 hover:bg-primary/10 hover:text-primary hover:border-primary/30 absolute bottom-4 left-1/2 -translate-x-1/2 cursor-pointer rounded-full border px-3 py-1.5 text-xs backdrop-blur-sm transition-all duration-200">
        클릭하여 더 보기
      </div>
    </div>
  </div>
</div>


<script>
(function() {
  const codeId = 'code-12';
  const copyBtn = document.querySelector('.copy-code-btn[data-code-id="' + codeId + '"]');
  const collapseBtn = document.querySelector('.collapse-code-btn[data-code-id="' + codeId + '"]');
  const codeContainer = document.getElementById(codeId);

  if (!codeContainer) return;

  
  if (copyBtn) {
    const copyIcon = copyBtn.querySelector('.copy-icon');
    const copyText = copyBtn.querySelector('.copy-text');

    copyBtn.addEventListener('click', async function() {
      try {
        
        let codeText = '';

        
        const codeTableCell = codeContainer.querySelector('.lntd:last-child code');
        if (codeTableCell) {
          codeText = codeTableCell.textContent || codeTableCell.innerText;
        } else {
          
          const codeElement = codeContainer.querySelector('code');
          if (codeElement) {
            
            const hasInlineLineNumbers = codeElement.querySelector('.ln');
            if (hasInlineLineNumbers) {
              
              const codeLines = codeElement.querySelectorAll('.cl');
              if (codeLines.length > 0) {
                codeText = Array.from(codeLines)
                  .map(line => {
                    const text = line.textContent || line.innerText;
                    
                    return text.replace(/\n+$/, '');
                  })
                  .join('\n')
                  .replace(/\n+$/, ''); 
              } else {
                
                const allText = codeElement.textContent || codeElement.innerText;
                codeText = allText.replace(/^\d+/gm, '').replace(/^\s+/gm, '');
              }
            } else {
              
              codeText = codeElement.textContent || codeElement.innerText;
            }
          } else {
            
            codeText = codeContainer.textContent || codeContainer.innerText;
          }
        }

        
        codeText = codeText.trim();

        
        await navigator.clipboard.writeText(codeText);

        
        copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M5 13l4 4L19 7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (copyText) {
          copyText.textContent = '복사됨';
        }
        copyBtn.classList.add('text-green-600');

        
        setTimeout(() => {
          copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z\u0022 \/\u003e\n\u003c\/svg\u003e`;
          if (copyText) {
            copyText.textContent = '복사';
          }
          copyBtn.classList.remove('text-green-600');
        }, 2000);

      } catch (err) {
        console.error('复制失败:', err);

        
        const range = document.createRange();
        const codeElement = codeContainer.querySelector('code') || codeContainer;
        range.selectNodeContents(codeElement);
        const selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);

        
        if (copyText) {
          copyText.textContent = '선택됨';
        }

        setTimeout(() => {
          if (copyText) {
            copyText.textContent = '복사';
          }
          selection.removeAllRanges();
        }, 2000);
      }
    });
  }

  
  if (collapseBtn) {
    const collapseIcon = collapseBtn.querySelector('.collapse-icon');
    const collapseText = collapseBtn.querySelector('.collapse-text');
    const collapseOverlay = codeContainer.querySelector('.collapse-overlay');

    
    let codeElement = codeContainer.querySelector('pre.chroma');
    if (!codeElement) {
      codeElement = codeContainer.querySelector('pre');
    }

    const defaultState = collapseBtn.dataset.defaultState || 'expanded';
    const isCollapsedAttr = collapseBtn.dataset.collapsed === 'true';
    const autoCollapseLines = parseInt(collapseBtn.dataset.autoCollapseLines) || 30;
    const autoCollapseHeight = parseInt(collapseBtn.dataset.autoCollapseHeight) || 400;
    const collapsedHeight = parseInt(collapseBtn.dataset.collapsedHeight) || 120;

    let isCollapsed = false;

    
    function initCollapse() {
      
      const shouldCollapse = isCollapsedAttr ||
                           defaultState === 'collapsed' ||
                           shouldAutoCollapse();

      if (shouldCollapse) {
        setCollapsed(true, false); 
      }
    }

    function shouldAutoCollapse() {
      
      if (codeElement) {
        const lines = codeElement.querySelectorAll('.line, .cl');
        const height = codeElement.offsetHeight;
        return lines.length > autoCollapseLines || height > autoCollapseHeight;
      }

      
      const containerHeight = codeContainer.offsetHeight;
      if (containerHeight > autoCollapseHeight) {
        return true;
      }

      
      const textContent = codeContainer.textContent || codeContainer.innerText || '';
      const estimatedLines = textContent.split('\n').length;
      return estimatedLines > autoCollapseLines;
    }

    function setCollapsed(collapsed, animate = true) {
      if (!collapseOverlay) return;

      isCollapsed = collapsed;

      if (collapsed) {
        
        codeContainer.style.maxHeight = collapsedHeight + 'px';
        codeContainer.style.overflow = 'hidden';
        collapseOverlay.style.opacity = '1';
        collapseOverlay.style.pointerEvents = 'auto';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M19 9l-7 7-7-7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '펼치기';
        }
        collapseBtn.title = '펼치기';

      } else {
        
        codeContainer.style.maxHeight = '';
        codeContainer.style.overflow = '';
        collapseOverlay.style.opacity = '0';
        collapseOverlay.style.pointerEvents = 'none';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath fill=\u0022currentColor\u0022 d=\u0022M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z\u0022\/\u003e\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '접기';
        }
        collapseBtn.title = '접기';
      }

      
      if (animate) {
        codeContainer.style.transition = 'max-height 0.3s ease-out';
        setTimeout(() => {
          codeContainer.style.transition = '';
        }, 300);
      }
    }

    function toggleCollapse() {
      setCollapsed(!isCollapsed, true);
    }

    
    collapseBtn.addEventListener('click', toggleCollapse);

    
    if (collapseOverlay) {
      collapseOverlay.addEventListener('click', () => {
        if (isCollapsed) {
          setCollapsed(false, true);
        }
      });
    }

    
    initCollapse();
  }
})();
</script>
<hr>
<h4 id="-step-3-추론기reasoner---문제-해결-수행"><strong>🔹 Step 3: 추론기(Reasoner) - 문제 해결 수행</strong></h4>
<ul>
<li>가설적 추론(Abductive)을 적용하여 문제 해결 수행</li>
<li>유사한 해결 방법을 참고하여, **&ldquo;x + (x + 24) = 68&rdquo;**이라는 방정식을 구성하여 풀이 진행</li>
</ul>
<p>✅ <strong>출력 예시 (문제 해결 과정)</strong></p>
<div
  class="code-block-container border-border bg-card my-6 overflow-hidden rounded-xl border shadow-sm transition-all duration-200 ease-out hover:-translate-y-0.5 hover:shadow-md">
  
  <div
    class="code-block-header bg-muted/30 border-border flex items-center justify-between border-b px-4 py-3">
    
    <div class="flex items-center gap-2">
      <div class="text-muted-foreground flex-shrink-0">
        
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4" />
</svg>
      </div>
      <span class="text-muted-foreground text-sm font-medium">
        JSON
      </span>
    </div>

    
    <div class="flex items-center gap-2">
      <button
          class="collapse-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
          data-code-id="code-13"
          data-default-state="expanded"
          data-collapsed="false"
          data-auto-collapse-lines="30"
          data-auto-collapse-height="400"
          data-collapsed-height="120"
          title="접기"
          aria-label="접기">
          <span class="collapse-icon">
            
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path fill="currentColor" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z"/></svg>
          </span>
          <span class="collapse-text hidden sm:inline"
            >접기</span
          >
        </button>
      <button
        class="copy-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
        data-code-id="code-13"
        title="복사"
        aria-label="복사">
        <span class="copy-icon">
          
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
</svg>
        </span>
        <span class="copy-text hidden sm:inline"
          >복사</span
        >
      </button>
    </div>
  </div>

  
  <div class="code-block-content relative" id="code-13">
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">  <span class="nt">&#34;solution_steps&#34;</span><span class="p">:</span> <span class="p">[</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="s2">&#34;John의 나이를 x라고 가정&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="s2">&#34;아버지의 나이는 (x + 24)&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="s2">&#34;x + (x + 24) = 68&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="s2">&#34;2x + 24 = 68&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="s2">&#34;2x = 44&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="s2">&#34;x = 22&#34;</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">  <span class="p">],</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">  <span class="nt">&#34;final_answer&#34;</span><span class="p">:</span> <span class="mi">22</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="p">}</span></span></span></code></pre></div>
    
    <div
      class="collapse-overlay to-card/90 pointer-events-none absolute inset-0 bg-gradient-to-b from-transparent via-transparent opacity-0 transition-opacity duration-300">
      <div
        class="text-muted-foreground bg-card/80 border-border/50 hover:bg-primary/10 hover:text-primary hover:border-primary/30 absolute bottom-4 left-1/2 -translate-x-1/2 cursor-pointer rounded-full border px-3 py-1.5 text-xs backdrop-blur-sm transition-all duration-200">
        클릭하여 더 보기
      </div>
    </div>
  </div>
</div>


<script>
(function() {
  const codeId = 'code-13';
  const copyBtn = document.querySelector('.copy-code-btn[data-code-id="' + codeId + '"]');
  const collapseBtn = document.querySelector('.collapse-code-btn[data-code-id="' + codeId + '"]');
  const codeContainer = document.getElementById(codeId);

  if (!codeContainer) return;

  
  if (copyBtn) {
    const copyIcon = copyBtn.querySelector('.copy-icon');
    const copyText = copyBtn.querySelector('.copy-text');

    copyBtn.addEventListener('click', async function() {
      try {
        
        let codeText = '';

        
        const codeTableCell = codeContainer.querySelector('.lntd:last-child code');
        if (codeTableCell) {
          codeText = codeTableCell.textContent || codeTableCell.innerText;
        } else {
          
          const codeElement = codeContainer.querySelector('code');
          if (codeElement) {
            
            const hasInlineLineNumbers = codeElement.querySelector('.ln');
            if (hasInlineLineNumbers) {
              
              const codeLines = codeElement.querySelectorAll('.cl');
              if (codeLines.length > 0) {
                codeText = Array.from(codeLines)
                  .map(line => {
                    const text = line.textContent || line.innerText;
                    
                    return text.replace(/\n+$/, '');
                  })
                  .join('\n')
                  .replace(/\n+$/, ''); 
              } else {
                
                const allText = codeElement.textContent || codeElement.innerText;
                codeText = allText.replace(/^\d+/gm, '').replace(/^\s+/gm, '');
              }
            } else {
              
              codeText = codeElement.textContent || codeElement.innerText;
            }
          } else {
            
            codeText = codeContainer.textContent || codeContainer.innerText;
          }
        }

        
        codeText = codeText.trim();

        
        await navigator.clipboard.writeText(codeText);

        
        copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M5 13l4 4L19 7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (copyText) {
          copyText.textContent = '복사됨';
        }
        copyBtn.classList.add('text-green-600');

        
        setTimeout(() => {
          copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z\u0022 \/\u003e\n\u003c\/svg\u003e`;
          if (copyText) {
            copyText.textContent = '복사';
          }
          copyBtn.classList.remove('text-green-600');
        }, 2000);

      } catch (err) {
        console.error('复制失败:', err);

        
        const range = document.createRange();
        const codeElement = codeContainer.querySelector('code') || codeContainer;
        range.selectNodeContents(codeElement);
        const selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);

        
        if (copyText) {
          copyText.textContent = '선택됨';
        }

        setTimeout(() => {
          if (copyText) {
            copyText.textContent = '복사';
          }
          selection.removeAllRanges();
        }, 2000);
      }
    });
  }

  
  if (collapseBtn) {
    const collapseIcon = collapseBtn.querySelector('.collapse-icon');
    const collapseText = collapseBtn.querySelector('.collapse-text');
    const collapseOverlay = codeContainer.querySelector('.collapse-overlay');

    
    let codeElement = codeContainer.querySelector('pre.chroma');
    if (!codeElement) {
      codeElement = codeContainer.querySelector('pre');
    }

    const defaultState = collapseBtn.dataset.defaultState || 'expanded';
    const isCollapsedAttr = collapseBtn.dataset.collapsed === 'true';
    const autoCollapseLines = parseInt(collapseBtn.dataset.autoCollapseLines) || 30;
    const autoCollapseHeight = parseInt(collapseBtn.dataset.autoCollapseHeight) || 400;
    const collapsedHeight = parseInt(collapseBtn.dataset.collapsedHeight) || 120;

    let isCollapsed = false;

    
    function initCollapse() {
      
      const shouldCollapse = isCollapsedAttr ||
                           defaultState === 'collapsed' ||
                           shouldAutoCollapse();

      if (shouldCollapse) {
        setCollapsed(true, false); 
      }
    }

    function shouldAutoCollapse() {
      
      if (codeElement) {
        const lines = codeElement.querySelectorAll('.line, .cl');
        const height = codeElement.offsetHeight;
        return lines.length > autoCollapseLines || height > autoCollapseHeight;
      }

      
      const containerHeight = codeContainer.offsetHeight;
      if (containerHeight > autoCollapseHeight) {
        return true;
      }

      
      const textContent = codeContainer.textContent || codeContainer.innerText || '';
      const estimatedLines = textContent.split('\n').length;
      return estimatedLines > autoCollapseLines;
    }

    function setCollapsed(collapsed, animate = true) {
      if (!collapseOverlay) return;

      isCollapsed = collapsed;

      if (collapsed) {
        
        codeContainer.style.maxHeight = collapsedHeight + 'px';
        codeContainer.style.overflow = 'hidden';
        collapseOverlay.style.opacity = '1';
        collapseOverlay.style.pointerEvents = 'auto';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M19 9l-7 7-7-7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '펼치기';
        }
        collapseBtn.title = '펼치기';

      } else {
        
        codeContainer.style.maxHeight = '';
        codeContainer.style.overflow = '';
        collapseOverlay.style.opacity = '0';
        collapseOverlay.style.pointerEvents = 'none';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath fill=\u0022currentColor\u0022 d=\u0022M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z\u0022\/\u003e\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '접기';
        }
        collapseBtn.title = '접기';
      }

      
      if (animate) {
        codeContainer.style.transition = 'max-height 0.3s ease-out';
        setTimeout(() => {
          codeContainer.style.transition = '';
        }, 300);
      }
    }

    function toggleCollapse() {
      setCollapsed(!isCollapsed, true);
    }

    
    collapseBtn.addEventListener('click', toggleCollapse);

    
    if (collapseOverlay) {
      collapseOverlay.addEventListener('click', () => {
        if (isCollapsed) {
          setCollapsed(false, true);
        }
      });
    }

    
    initCollapse();
  }
})();
</script>
<hr>
<h2 id="모델-아키텍처-및-연산-요구량-분석"><strong>모델 아키텍처 및 연산 요구량 분석</strong></h2>
<p>TypedThinker는 기본적으로 <strong>Transformer 기반의 대형 언어 모델(LLM)을 활용하며, 메타-추론기, 명시적 메모리, 추론기</strong>라는 세 가지 주요 모듈로 구성된다.</p>
<h3 id="1-모델-아키텍처"><strong>1. 모델 아키텍처</strong></h3>
<h4 id="1-메타-추론기meta-thinker"><strong>(1) 메타-추론기(Meta-thinker)</strong></h4>
<ul>
<li>문제를 입력받고, 가장 적절한 추론 방식을 선택하는 모델</li>
<li><strong>구조:</strong>
<ul>
<li>LLM 기반 (Mistral 7B, LLaMA3 8B 사용)</li>
<li>Fine-tuning을 통해 학습</li>
<li>Multi-class classification (4가지 추론 방식 중 선택)</li>
</ul>
</li>
<li><strong>연산량:</strong>
<ul>
<li>주어진 문제에 대해 논리적 추론을 수행하는 부분이므로, <strong>단일 Forward Pass</strong>만 필요</li>
<li>연산량: <strong>O(N)</strong> (N은 문제의 길이)</li>
</ul>
</li>
</ul>
<h4 id="2-명시적-메모리explicit-memory"><strong>(2) 명시적 메모리(Explicit Memory)</strong></h4>
<ul>
<li>과거 문제 해결 사례를 검색하여 참조하는 메모리 시스템</li>
<li><strong>구조:</strong>
<ul>
<li>벡터 임베딩을 사용하여 코사인 유사도 기반 검색</li>
<li>SentenceTransformer 등의 모델 활용 가능</li>
</ul>
</li>
<li><strong>연산량:</strong>
<ul>
<li>벡터 검색이므로, <strong>O(logM)</strong> (M은 저장된 경험의 개수)</li>
<li>메모리 사용량 증가 가능성이 있음 (수천~수백만 개의 경험 저장)</li>
</ul>
</li>
</ul>
<h4 id="3-추론기reasoner"><strong>(3) 추론기(Reasoner)</strong></h4>
<ul>
<li>선택된 논리적 추론 방식을 적용하여 문제를 해결</li>
<li><strong>구조:</strong>
<ul>
<li>Transformer 기반 LLM이 <strong>선택된 추론 방식에 따라 Chain-of-Thought(CoT) 방식으로 문제를 해결</strong></li>
<li>LLaMA3 8B, GPT-4o 등의 모델을 활용 가능</li>
</ul>
</li>
<li><strong>연산량:</strong>
<ul>
<li>Chain-of-Thought 방식으로 여러 단계 연산 수행 → <strong>O(KN)</strong> (K는 해결 단계 수)</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-모델을-구성하는-연산-및-메모리-요구량"><strong>2. 모델을 구성하는 연산 및 메모리 요구량</strong></h3>
<table>
  <thead>
      <tr>
          <th>구성 요소</th>
          <th>연산량</th>
          <th>메모리 요구량</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>메타-추론기</td>
          <td>O(N) (1회 추론)</td>
          <td>수십 MB (모델 가중치)</td>
      </tr>
      <tr>
          <td>명시적 메모리</td>
          <td>O(logM) (벡터 검색)</td>
          <td>수백 MB ~ GB (경험 데이터)</td>
      </tr>
      <tr>
          <td>추론기</td>
          <td>O(KN) (Chain-of-Thought)</td>
          <td>수 GB (LLM 모델 가중치)</td>
      </tr>
  </tbody>
</table>
<hr>
<h3 id="3-컴퓨팅-요구량"><strong>3. 컴퓨팅 요구량</strong></h3>
<table>
  <thead>
      <tr>
          <th>모델</th>
          <th>필요한 GPU</th>
          <th>메모리 사용량</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Mistral 7B 기반 TypedThinker</td>
          <td><strong>A6000 2장</strong></td>
          <td>48GB+</td>
      </tr>
      <tr>
          <td>LLaMA3 8B 기반 TypedThinker</td>
          <td><strong>A100 2장</strong></td>
          <td>80GB+</td>
      </tr>
      <tr>
          <td>GPT-4o 기반 TypedThinker</td>
          <td><strong>클라우드 API 사용</strong></td>
          <td>-</td>
      </tr>
  </tbody>
</table>
<p>➡ <strong>최소 요구 사항</strong>:</p>
<ul>
<li><strong>Mistral 7B 기반 모델</strong>: <strong>RTX A6000 이상 (48GB VRAM 이상)</strong></li>
<li><strong>LLaMA3 8B 기반 모델</strong>: <strong>A100 (80GB VRAM 이상)</strong></li>
<li><strong>더 큰 모델 사용 시</strong>: <strong>TPU 또는 클라우드 API 활용 필요</strong></li>
</ul>
<hr>
<h2 id="결론-1"><strong>결론</strong></h2>
<p>TypedThinker의 추론 과정은 메타-추론기를 활용한 논리적 추론 방식 선택, 명시적 메모리를 활용한 유사 사례 검색, 그리고 추론기의 Chain-of-Thought 연산을 기반으로 구성됨.<br>
컴퓨팅 요구량은 Mistral 7B 수준에서는 RTX A6000 2장 이상이 필요하며, LLaMA3 8B 이상에서는 A100 GPU가 요구됨. 🚀</p>
<h1 id="q--이-논문의-한계를-극복하기-위한-방법으로-어떤-연구흐름이-있는지-정리해서-자세하게-설명해-줘">Q : 이 논문의 한계를 극복하기 위한 방법으로 어떤 연구흐름이 있는지 정리해서 자세하게 설명해 줘</h1>
<h2 id="논문의-한계를-극복하기-위한-연구-흐름-정리"><strong>논문의 한계를 극복하기 위한 연구 흐름 정리</strong></h2>
<p>논문이 제시한 <strong>TypedThinker</strong>는 LLM의 논리적 추론 능력을 향상시키는 효과적인 방법이지만, 몇 가지 한계점이 존재함.<br>
이를 극복하기 위해 현재 연구되고 있는 흐름을 기반으로 향후 개선 방향을 정리하면 다음과 같음.</p>
<hr>
<h2 id="1-논문의-주요-한계점"><strong>1. 논문의 주요 한계점</strong></h2>
<p>논문에서 명시적으로 언급한 한계점 및 추가적으로 고려할 수 있는 문제점은 다음과 같음.</p>
<table>
  <thead>
      <tr>
          <th><strong>한계점</strong></th>
          <th><strong>설명</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>복합적 추론 방식의 부재</strong></td>
          <td>하나의 문제에 대해 단일 추론 방식을 선택하지만, 실제로는 연역+귀납 등의 조합이 필요할 수 있음</td>
      </tr>
      <tr>
          <td><strong>명시적 메모리 검색 방식의 한계</strong></td>
          <td>코사인 유사도 기반 검색은 제한적이며, 더 정교한 검색 방법이 필요</td>
      </tr>
      <tr>
          <td><strong>추론 과정의 효율성 문제</strong></td>
          <td>특정 유형의 문제에서 비효율적인 연산이 발생할 수 있음</td>
      </tr>
      <tr>
          <td><strong>새로운 도메인 확장 필요</strong></td>
          <td>논리 및 수학 문제에 초점을 맞췄지만, 창의적 문제 해결이나 일반적인 AI 문제 해결로 확장 필요</td>
      </tr>
      <tr>
          <td><strong>LLM의 한계 극복 필요</strong></td>
          <td>LLM 자체가 논리적 오류를 포함할 수 있으며, 더 강력한 모델과의 통합 필요</td>
      </tr>
  </tbody>
</table>
<hr>
<h2 id="2-typedthinker의-한계를-극복하기-위한-연구-흐름"><strong>2. TypedThinker의 한계를 극복하기 위한 연구 흐름</strong></h2>
<h3 id="1-복합적인-추론-방식을-조합하는-연구"><strong>(1) 복합적인 추론 방식을 조합하는 연구</strong></h3>
<h4 id="-기존-문제점">🔹 기존 문제점</h4>
<ul>
<li>현재 TypedThinker는 <strong>단일 추론 방식(연역, 귀납, 유추, 가설)</strong> 중 하나를 선택하지만, 실제로 복합적인 추론이 필요함.</li>
<li>예를 들어, 수학 문제에서는 귀납적으로 패턴을 찾고, 이후 연역적 논리를 적용해야 함.</li>
</ul>
<h4 id="-해결-방안-multi-step--hybrid-reasoning">🔹 해결 방안: <strong>Multi-Step &amp; Hybrid Reasoning</strong></h4>
<p>✅ <strong>연구 흐름</strong></p>
<ul>
<li><strong>Tree of Thoughts (ToT, Yao et al., 2023)</strong>
<ul>
<li>논리적 사고를 트리(tree) 구조로 표현하여 여러 추론 방식을 함께 적용 가능하도록 함.</li>
</ul>
</li>
<li><strong>Graph of Thoughts (GoT, Besta et al., 2024)</strong>
<ul>
<li>문제 해결 과정을 그래프 구조로 확장하여 다양한 논리적 추론을 병렬적으로 적용하는 방식.</li>
</ul>
</li>
<li><strong>Composable Reasoning (Jiang et al., 2024)</strong>
<ul>
<li>문제 해결을 여러 개의 reasoning block으로 쪼개어, 필요한 부분마다 적절한 추론 방식을 조합하는 방식.</li>
</ul>
</li>
</ul>
<p>✅ <strong>예상되는 개선점</strong></p>
<ul>
<li><strong>TypedThinker에 Tree of Thoughts 방식을 적용</strong>하면, 한 문제에서 귀납-연역-가설적 추론을 혼합하여 활용할 수 있음.</li>
<li>문제를 <strong>단계별 reasoning block으로 나누고, 각 단계에서 최적의 추론 방식을 조합</strong>하면 해결 가능.</li>
</ul>
<hr>
<h3 id="2-명시적-메모리-검색-방식-개선"><strong>(2) 명시적 메모리 검색 방식 개선</strong></h3>
<h4 id="-기존-문제점-1">🔹 기존 문제점</h4>
<ul>
<li>TypedThinker는 <strong>코사인 유사도 기반 검색</strong>을 사용하지만, 이는 유사성이 높지만 중요한 특징이 다른 문제를 검색할 가능성이 있음.</li>
</ul>
<h4 id="-해결-방안-강화-학습-기반-검색-및-메모리-최적화">🔹 해결 방안: <strong>강화 학습 기반 검색 및 메모리 최적화</strong></h4>
<p>✅ <strong>연구 흐름</strong></p>
<ul>
<li><strong>Retrieval-Augmented Generation (RAG, Lewis et al., 2020)</strong>
<ul>
<li>검색 과정에서 단순한 유사도 매칭이 아니라, <strong>답변의 품질을 평가하는 강화 학습 방식</strong> 적용.</li>
</ul>
</li>
<li><strong>Adaptive Memory Retrieval (Huang et al., 2024)</strong>
<ul>
<li>단순한 벡터 유사도가 아니라, <strong>모델이 가장 도움이 되는 사례를 학습하면서 검색하는 방식</strong>.</li>
</ul>
</li>
</ul>
<p>✅ <strong>예상되는 개선점</strong></p>
<ul>
<li>메모리에서 단순한 유사한 사례가 아니라, <strong>실제 문제 해결에 도움이 될 사례를 선별</strong>할 수 있음.</li>
<li>강화 학습을 적용하면, <strong>&ldquo;이전 경험이 현재 문제 해결에 얼마나 유효한지&quot;를 지속적으로 평가</strong>하며 검색 성능을 개선할 수 있음.</li>
</ul>
<hr>
<h3 id="3-추론-과정의-효율성-개선"><strong>(3) 추론 과정의 효율성 개선</strong></h3>
<h4 id="-기존-문제점-2">🔹 기존 문제점</h4>
<ul>
<li>Chain-of-Thought(CoT) 방식의 추론은 <strong>많은 연산량을 필요로 하며</strong>, 특정 문제에서는 불필요한 연산이 많을 수 있음.</li>
</ul>
<h4 id="-해결-방안-efficient-reasoning--model-pruning">🔹 해결 방안: <strong>Efficient Reasoning &amp; Model Pruning</strong></h4>
<p>✅ <strong>연구 흐름</strong></p>
<ul>
<li><strong>Sparse Reasoning (Liu et al., 2023)</strong>
<ul>
<li>LLM의 모든 토큰을 활용하는 것이 아니라, <strong>필요한 정보에 집중하여 연산량을 줄이는 방식</strong>.</li>
</ul>
</li>
<li><strong>Dynamic CoT Pruning (Peng et al., 2023)</strong>
<ul>
<li>불필요한 reasoning 단계를 제거하여 <strong>최소한의 연산만 수행하도록 최적화</strong>.</li>
</ul>
</li>
</ul>
<p>✅ <strong>예상되는 개선점</strong></p>
<ul>
<li><strong>TypedThinker에서 연산량이 많은 문제(예: MATH)에서 필요 없는 계산을 줄이고, 핵심 reasoning step만 실행</strong>할 수 있음.</li>
<li><strong>Sparse Reasoning 기법을 도입하면, 한 문제에 대해 모든 reasoning type을 평가하는 것이 아니라, 필요한 부분만 선택적으로 수행 가능</strong>.</li>
</ul>
<hr>
<h3 id="4-새로운-도메인으로-확장"><strong>(4) 새로운 도메인으로 확장</strong></h3>
<h4 id="-기존-문제점-3">🔹 기존 문제점</h4>
<ul>
<li>논리적 문제(LogiQA, BBH)와 수학적 문제(GSM8K, MATH)에 초점을 맞췄지만, <strong>일반적인 창의적 문제 해결(Creative Problem-Solving)에는 적용되지 않음</strong>.</li>
</ul>
<h4 id="-해결-방안-commonsense--creativity-reasoning-적용">🔹 해결 방안: <strong>Commonsense &amp; Creativity Reasoning 적용</strong></h4>
<p>✅ <strong>연구 흐름</strong></p>
<ul>
<li><strong>Commonsense Augmented Reasoning (Li et al., 2024)</strong>
<ul>
<li>일반적인 AI 상식 지식을 활용하여, 더 넓은 범위의 문제 해결.</li>
</ul>
</li>
<li><strong>Creativity-Driven LLMs (Zhang et al., 2024)</strong>
<ul>
<li>논리적 문제뿐만 아니라, 창의적 사고가 필요한 문제(예: 스토리 생성, 예측 문제)까지 확장.</li>
</ul>
</li>
</ul>
<p>✅ <strong>예상되는 개선점</strong></p>
<ul>
<li>TypedThinker를 논리적 문제뿐만 아니라, <strong>상식 추론(Commonsense Reasoning)이나 창의적 문제 해결(Creative Thinking)으로 확장 가능</strong>.</li>
</ul>
<hr>
<h3 id="5-llm의-한계-극복-및-더-강력한-모델과의-통합"><strong>(5) LLM의 한계 극복 및 더 강력한 모델과의 통합</strong></h3>
<h4 id="-기존-문제점-4">🔹 기존 문제점</h4>
<ul>
<li>TypedThinker는 Mistral 7B 및 LLaMA3 8B를 기반으로 하지만, <strong>더 강력한 모델(GPT-4o, Claude 3 등)과 비교했을 때 성능 차이가 존재</strong>.</li>
</ul>
<h4 id="-해결-방안-weak-to-strong-generalization--fine-tuning">🔹 해결 방안: <strong>Weak-to-Strong Generalization &amp; Fine-Tuning</strong></h4>
<p>✅ <strong>연구 흐름</strong></p>
<ul>
<li><strong>Weak-to-Strong Generalization (Burns et al., 2024)</strong>
<ul>
<li>작은 모델(7B)이 강력한 모델(GPT-4o)의 도움 없이도 향상될 수 있도록, 학습 방법 최적화.</li>
</ul>
</li>
<li><strong>Selective Fine-Tuning (Hoffmann et al., 2024)</strong>
<ul>
<li>모든 데이터를 학습하는 것이 아니라, <strong>성능 향상에 기여하는 핵심 데이터만 선별하여 모델을 미세 조정</strong>.</li>
</ul>
</li>
</ul>
<p>✅ <strong>예상되는 개선점</strong></p>
<ul>
<li>TypedThinker를 GPT-4o 등의 강력한 모델과 함께 적용하면, <strong>연산량을 줄이면서도 정확도를 극대화할 수 있음</strong>.</li>
<li><strong>Weak-to-Strong Generalization을 활용하면, 작은 모델에서도 큰 모델 수준의 성능을 얻을 수 있음</strong>.</li>
</ul>
<hr>
<h2 id="결론-2"><strong>결론</strong></h2>
<p>TypedThinker의 한계를 극복하기 위해, 현재 연구되고 있는 5가지 핵심 연구 흐름을 활용할 수 있음.</p>
<ol>
<li><strong>복합적 reasoning 조합 (Tree of Thoughts, Graph of Thoughts)</strong></li>
<li><strong>강화 학습 기반 검색 개선 (RAG, Adaptive Memory)</strong></li>
<li><strong>연산량 최적화 (Sparse Reasoning, Dynamic CoT Pruning)</strong></li>
<li><strong>새로운 도메인 확장 (Commonsense, Creative Reasoning)</strong></li>
<li><strong>더 강력한 모델과 통합 (Weak-to-Strong Generalization)</strong></li>
</ol>
<p>이러한 연구 흐름을 적용하면 TypedThinker를 <strong>더 강력한 AI 논리 추론 프레임워크로 발전시킬 수 있음</strong> 🚀.</p>
<h1 id="q-typedthinker의-메타-추론기meta-thinker는-특정-문제에-대해-가장-적절한-논리적-추론-방식을-선택하는데-이-과정에서-학습된-확률-점수가-실제-문제-해결-성능과-어떤-상관관계를-가지는가-메타-추론기의-예측이-잘못된-경우-성능-저하를-방지하기-위한-보완-기법은-무엇이-있을까">Q: TypedThinker의 메타-추론기(Meta-thinker)는 특정 문제에 대해 가장 적절한 논리적 추론 방식을 선택하는데, 이 과정에서 학습된 확률 점수가 실제 문제 해결 성능과 어떤 상관관계를 가지는가? 메타-추론기의 예측이 잘못된 경우, 성능 저하를 방지하기 위한 보완 기법은 무엇이 있을까?</h1>
<h2 id="메타-추론기의-확률-점수와-문제-해결-성능-간의-상관관계-분석"><strong>메타-추론기의 확률 점수와 문제 해결 성능 간의 상관관계 분석</strong></h2>
<h3 id="1-메타-추론기meta-thinker의-역할"><strong>1. 메타-추론기(Meta-thinker)의 역할</strong></h3>
<ul>
<li>메타-추론기는 <strong>주어진 문제를 보고 가장 적절한 논리적 추론 방식을 선택</strong>하는 역할을 함.</li>
<li>논문에서는 **각 추론 방식(연역, 귀납, 가설, 유추)에 대해 확률 점수(Effectiveness Score)**를 예측하여 최적의 추론 방식을 결정함.</li>
<li>예를 들어, 다음과 같은 방식으로 확률 점수를 계산함:
<div
  class="code-block-container border-border bg-card my-6 overflow-hidden rounded-xl border shadow-sm transition-all duration-200 ease-out hover:-translate-y-0.5 hover:shadow-md">
  
  <div
    class="code-block-header bg-muted/30 border-border flex items-center justify-between border-b px-4 py-3">
    
    <div class="flex items-center gap-2">
      <div class="text-muted-foreground flex-shrink-0">
        
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4" />
</svg>
      </div>
      <span class="text-muted-foreground text-sm font-medium">
        PLAINTEXT
      </span>
    </div>

    
    <div class="flex items-center gap-2">
      <button
          class="collapse-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
          data-code-id="code-14"
          data-default-state="expanded"
          data-collapsed="false"
          data-auto-collapse-lines="30"
          data-auto-collapse-height="400"
          data-collapsed-height="120"
          title="접기"
          aria-label="접기">
          <span class="collapse-icon">
            
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path fill="currentColor" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z"/></svg>
          </span>
          <span class="collapse-text hidden sm:inline"
            >접기</span
          >
        </button>
      <button
        class="copy-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
        data-code-id="code-14"
        title="복사"
        aria-label="복사">
        <span class="copy-icon">
          
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
</svg>
        </span>
        <span class="copy-text hidden sm:inline"
          >복사</span
        >
      </button>
    </div>
  </div>

  
  <div class="code-block-content relative" id="code-14">
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">Deductive: 0.4, Inductive: 0.5, Abductive: 0.6, Analogical: 0.3
</span></span><span class="line"><span class="ln">2</span><span class="cl">→ Abductive가 가장 높으므로, Abductive Reasoning을 적용하여 문제 해결 진행</span></span></code></pre></div>
    
    <div
      class="collapse-overlay to-card/90 pointer-events-none absolute inset-0 bg-gradient-to-b from-transparent via-transparent opacity-0 transition-opacity duration-300">
      <div
        class="text-muted-foreground bg-card/80 border-border/50 hover:bg-primary/10 hover:text-primary hover:border-primary/30 absolute bottom-4 left-1/2 -translate-x-1/2 cursor-pointer rounded-full border px-3 py-1.5 text-xs backdrop-blur-sm transition-all duration-200">
        클릭하여 더 보기
      </div>
    </div>
  </div>
</div>


<script>
(function() {
  const codeId = 'code-14';
  const copyBtn = document.querySelector('.copy-code-btn[data-code-id="' + codeId + '"]');
  const collapseBtn = document.querySelector('.collapse-code-btn[data-code-id="' + codeId + '"]');
  const codeContainer = document.getElementById(codeId);

  if (!codeContainer) return;

  
  if (copyBtn) {
    const copyIcon = copyBtn.querySelector('.copy-icon');
    const copyText = copyBtn.querySelector('.copy-text');

    copyBtn.addEventListener('click', async function() {
      try {
        
        let codeText = '';

        
        const codeTableCell = codeContainer.querySelector('.lntd:last-child code');
        if (codeTableCell) {
          codeText = codeTableCell.textContent || codeTableCell.innerText;
        } else {
          
          const codeElement = codeContainer.querySelector('code');
          if (codeElement) {
            
            const hasInlineLineNumbers = codeElement.querySelector('.ln');
            if (hasInlineLineNumbers) {
              
              const codeLines = codeElement.querySelectorAll('.cl');
              if (codeLines.length > 0) {
                codeText = Array.from(codeLines)
                  .map(line => {
                    const text = line.textContent || line.innerText;
                    
                    return text.replace(/\n+$/, '');
                  })
                  .join('\n')
                  .replace(/\n+$/, ''); 
              } else {
                
                const allText = codeElement.textContent || codeElement.innerText;
                codeText = allText.replace(/^\d+/gm, '').replace(/^\s+/gm, '');
              }
            } else {
              
              codeText = codeElement.textContent || codeElement.innerText;
            }
          } else {
            
            codeText = codeContainer.textContent || codeContainer.innerText;
          }
        }

        
        codeText = codeText.trim();

        
        await navigator.clipboard.writeText(codeText);

        
        copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M5 13l4 4L19 7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (copyText) {
          copyText.textContent = '복사됨';
        }
        copyBtn.classList.add('text-green-600');

        
        setTimeout(() => {
          copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z\u0022 \/\u003e\n\u003c\/svg\u003e`;
          if (copyText) {
            copyText.textContent = '복사';
          }
          copyBtn.classList.remove('text-green-600');
        }, 2000);

      } catch (err) {
        console.error('复制失败:', err);

        
        const range = document.createRange();
        const codeElement = codeContainer.querySelector('code') || codeContainer;
        range.selectNodeContents(codeElement);
        const selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);

        
        if (copyText) {
          copyText.textContent = '선택됨';
        }

        setTimeout(() => {
          if (copyText) {
            copyText.textContent = '복사';
          }
          selection.removeAllRanges();
        }, 2000);
      }
    });
  }

  
  if (collapseBtn) {
    const collapseIcon = collapseBtn.querySelector('.collapse-icon');
    const collapseText = collapseBtn.querySelector('.collapse-text');
    const collapseOverlay = codeContainer.querySelector('.collapse-overlay');

    
    let codeElement = codeContainer.querySelector('pre.chroma');
    if (!codeElement) {
      codeElement = codeContainer.querySelector('pre');
    }

    const defaultState = collapseBtn.dataset.defaultState || 'expanded';
    const isCollapsedAttr = collapseBtn.dataset.collapsed === 'true';
    const autoCollapseLines = parseInt(collapseBtn.dataset.autoCollapseLines) || 30;
    const autoCollapseHeight = parseInt(collapseBtn.dataset.autoCollapseHeight) || 400;
    const collapsedHeight = parseInt(collapseBtn.dataset.collapsedHeight) || 120;

    let isCollapsed = false;

    
    function initCollapse() {
      
      const shouldCollapse = isCollapsedAttr ||
                           defaultState === 'collapsed' ||
                           shouldAutoCollapse();

      if (shouldCollapse) {
        setCollapsed(true, false); 
      }
    }

    function shouldAutoCollapse() {
      
      if (codeElement) {
        const lines = codeElement.querySelectorAll('.line, .cl');
        const height = codeElement.offsetHeight;
        return lines.length > autoCollapseLines || height > autoCollapseHeight;
      }

      
      const containerHeight = codeContainer.offsetHeight;
      if (containerHeight > autoCollapseHeight) {
        return true;
      }

      
      const textContent = codeContainer.textContent || codeContainer.innerText || '';
      const estimatedLines = textContent.split('\n').length;
      return estimatedLines > autoCollapseLines;
    }

    function setCollapsed(collapsed, animate = true) {
      if (!collapseOverlay) return;

      isCollapsed = collapsed;

      if (collapsed) {
        
        codeContainer.style.maxHeight = collapsedHeight + 'px';
        codeContainer.style.overflow = 'hidden';
        collapseOverlay.style.opacity = '1';
        collapseOverlay.style.pointerEvents = 'auto';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M19 9l-7 7-7-7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '펼치기';
        }
        collapseBtn.title = '펼치기';

      } else {
        
        codeContainer.style.maxHeight = '';
        codeContainer.style.overflow = '';
        collapseOverlay.style.opacity = '0';
        collapseOverlay.style.pointerEvents = 'none';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath fill=\u0022currentColor\u0022 d=\u0022M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z\u0022\/\u003e\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '접기';
        }
        collapseBtn.title = '접기';
      }

      
      if (animate) {
        codeContainer.style.transition = 'max-height 0.3s ease-out';
        setTimeout(() => {
          codeContainer.style.transition = '';
        }, 300);
      }
    }

    function toggleCollapse() {
      setCollapsed(!isCollapsed, true);
    }

    
    collapseBtn.addEventListener('click', toggleCollapse);

    
    if (collapseOverlay) {
      collapseOverlay.addEventListener('click', () => {
        if (isCollapsed) {
          setCollapsed(false, true);
        }
      });
    }

    
    initCollapse();
  }
})();
</script>
</li>
</ul>
<hr>
<h3 id="2-확률-점수와-문제-해결-성능-간의-상관관계"><strong>2. 확률 점수와 문제 해결 성능 간의 상관관계</strong></h3>
<h4 id="-논문의-실험-결과-분석">🔹 <strong>논문의 실험 결과 분석</strong></h4>
<ul>
<li>논문에서는 <strong>메타-추론기가 선택한 논리적 추론 방식이 문제 해결 성능과 높은 상관관계를 가짐</strong>을 실험적으로 입증함.</li>
<li>메타-추론기의 예측이 <strong>68.3% 확률로 최적의 추론 방식을 선택</strong>할 수 있었음.
<ul>
<li>LogiQA: 75.4%</li>
<li>BBH: 75.6%</li>
<li>GSM8K: 72.1%</li>
<li>MATH: 47.7% (수학 문제에서는 상대적으로 낮은 성능)</li>
</ul>
</li>
<li>즉, <strong>논리 문제(LogiQA, BBH)에서는 매우 효과적이지만, 수학 문제(MATH)에서는 상대적으로 부정확</strong>함.</li>
</ul>
<h4 id="-확률-점수와-정답률-간의-연관성">🔹 <strong>확률 점수와 정답률 간의 연관성</strong></h4>
<ul>
<li>메타-추론기의 선택이 <strong>올바를 경우, 정답률이 평균 42.2%까지 상승</strong>.</li>
<li>하지만 잘못된 추론 방식을 선택하면 성능이 크게 저하됨:
<ul>
<li>올바른 추론 방식 선택 시: <strong>정확도 68.3%</strong></li>
<li>잘못된 추론 방식 선택 시: <strong>정확도 32.5%로 감소</strong></li>
</ul>
</li>
<li>특히, <strong>수학 문제(MATH)의 경우, 특정 추론 방식(귀납적 추론)이 압도적으로 유리한데도 불구하고 메타-추론기가 연역적 추론을 선택하는 경우가 많음.</strong></li>
</ul>
<hr>
<h3 id="3-메타-추론기의-예측-오류를-방지하기-위한-보완-기법"><strong>3. 메타-추론기의 예측 오류를 방지하기 위한 보완 기법</strong></h3>
<p>메타-추론기의 예측이 부정확한 경우를 방지하기 위해 다음과 같은 보완 기법을 적용할 수 있음.</p>
<h4 id="1-다중-추론-방식-적용-hybrid-reasoning"><strong>(1) 다중 추론 방식 적용 (Hybrid Reasoning)</strong></h4>
<p>✅ <strong>방법:</strong></p>
<ul>
<li>하나의 추론 방식만 선택하는 것이 아니라, <strong>확률 점수가 일정 기준 이상인 여러 개의 추론 방식을 동시에 적용</strong>.</li>
<li>예를 들어,
<div
  class="code-block-container border-border bg-card my-6 overflow-hidden rounded-xl border shadow-sm transition-all duration-200 ease-out hover:-translate-y-0.5 hover:shadow-md">
  
  <div
    class="code-block-header bg-muted/30 border-border flex items-center justify-between border-b px-4 py-3">
    
    <div class="flex items-center gap-2">
      <div class="text-muted-foreground flex-shrink-0">
        
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4" />
</svg>
      </div>
      <span class="text-muted-foreground text-sm font-medium">
        PLAINTEXT
      </span>
    </div>

    
    <div class="flex items-center gap-2">
      <button
          class="collapse-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
          data-code-id="code-15"
          data-default-state="expanded"
          data-collapsed="false"
          data-auto-collapse-lines="30"
          data-auto-collapse-height="400"
          data-collapsed-height="120"
          title="접기"
          aria-label="접기">
          <span class="collapse-icon">
            
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path fill="currentColor" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z"/></svg>
          </span>
          <span class="collapse-text hidden sm:inline"
            >접기</span
          >
        </button>
      <button
        class="copy-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
        data-code-id="code-15"
        title="복사"
        aria-label="복사">
        <span class="copy-icon">
          
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
</svg>
        </span>
        <span class="copy-text hidden sm:inline"
          >복사</span
        >
      </button>
    </div>
  </div>

  
  <div class="code-block-content relative" id="code-15">
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">Deductive: 0.4, Inductive: 0.5, Abductive: 0.6, Analogical: 0.3</span></span></code></pre></div>
    
    <div
      class="collapse-overlay to-card/90 pointer-events-none absolute inset-0 bg-gradient-to-b from-transparent via-transparent opacity-0 transition-opacity duration-300">
      <div
        class="text-muted-foreground bg-card/80 border-border/50 hover:bg-primary/10 hover:text-primary hover:border-primary/30 absolute bottom-4 left-1/2 -translate-x-1/2 cursor-pointer rounded-full border px-3 py-1.5 text-xs backdrop-blur-sm transition-all duration-200">
        클릭하여 더 보기
      </div>
    </div>
  </div>
</div>


<script>
(function() {
  const codeId = 'code-15';
  const copyBtn = document.querySelector('.copy-code-btn[data-code-id="' + codeId + '"]');
  const collapseBtn = document.querySelector('.collapse-code-btn[data-code-id="' + codeId + '"]');
  const codeContainer = document.getElementById(codeId);

  if (!codeContainer) return;

  
  if (copyBtn) {
    const copyIcon = copyBtn.querySelector('.copy-icon');
    const copyText = copyBtn.querySelector('.copy-text');

    copyBtn.addEventListener('click', async function() {
      try {
        
        let codeText = '';

        
        const codeTableCell = codeContainer.querySelector('.lntd:last-child code');
        if (codeTableCell) {
          codeText = codeTableCell.textContent || codeTableCell.innerText;
        } else {
          
          const codeElement = codeContainer.querySelector('code');
          if (codeElement) {
            
            const hasInlineLineNumbers = codeElement.querySelector('.ln');
            if (hasInlineLineNumbers) {
              
              const codeLines = codeElement.querySelectorAll('.cl');
              if (codeLines.length > 0) {
                codeText = Array.from(codeLines)
                  .map(line => {
                    const text = line.textContent || line.innerText;
                    
                    return text.replace(/\n+$/, '');
                  })
                  .join('\n')
                  .replace(/\n+$/, ''); 
              } else {
                
                const allText = codeElement.textContent || codeElement.innerText;
                codeText = allText.replace(/^\d+/gm, '').replace(/^\s+/gm, '');
              }
            } else {
              
              codeText = codeElement.textContent || codeElement.innerText;
            }
          } else {
            
            codeText = codeContainer.textContent || codeContainer.innerText;
          }
        }

        
        codeText = codeText.trim();

        
        await navigator.clipboard.writeText(codeText);

        
        copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M5 13l4 4L19 7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (copyText) {
          copyText.textContent = '복사됨';
        }
        copyBtn.classList.add('text-green-600');

        
        setTimeout(() => {
          copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z\u0022 \/\u003e\n\u003c\/svg\u003e`;
          if (copyText) {
            copyText.textContent = '복사';
          }
          copyBtn.classList.remove('text-green-600');
        }, 2000);

      } catch (err) {
        console.error('复制失败:', err);

        
        const range = document.createRange();
        const codeElement = codeContainer.querySelector('code') || codeContainer;
        range.selectNodeContents(codeElement);
        const selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);

        
        if (copyText) {
          copyText.textContent = '선택됨';
        }

        setTimeout(() => {
          if (copyText) {
            copyText.textContent = '복사';
          }
          selection.removeAllRanges();
        }, 2000);
      }
    });
  }

  
  if (collapseBtn) {
    const collapseIcon = collapseBtn.querySelector('.collapse-icon');
    const collapseText = collapseBtn.querySelector('.collapse-text');
    const collapseOverlay = codeContainer.querySelector('.collapse-overlay');

    
    let codeElement = codeContainer.querySelector('pre.chroma');
    if (!codeElement) {
      codeElement = codeContainer.querySelector('pre');
    }

    const defaultState = collapseBtn.dataset.defaultState || 'expanded';
    const isCollapsedAttr = collapseBtn.dataset.collapsed === 'true';
    const autoCollapseLines = parseInt(collapseBtn.dataset.autoCollapseLines) || 30;
    const autoCollapseHeight = parseInt(collapseBtn.dataset.autoCollapseHeight) || 400;
    const collapsedHeight = parseInt(collapseBtn.dataset.collapsedHeight) || 120;

    let isCollapsed = false;

    
    function initCollapse() {
      
      const shouldCollapse = isCollapsedAttr ||
                           defaultState === 'collapsed' ||
                           shouldAutoCollapse();

      if (shouldCollapse) {
        setCollapsed(true, false); 
      }
    }

    function shouldAutoCollapse() {
      
      if (codeElement) {
        const lines = codeElement.querySelectorAll('.line, .cl');
        const height = codeElement.offsetHeight;
        return lines.length > autoCollapseLines || height > autoCollapseHeight;
      }

      
      const containerHeight = codeContainer.offsetHeight;
      if (containerHeight > autoCollapseHeight) {
        return true;
      }

      
      const textContent = codeContainer.textContent || codeContainer.innerText || '';
      const estimatedLines = textContent.split('\n').length;
      return estimatedLines > autoCollapseLines;
    }

    function setCollapsed(collapsed, animate = true) {
      if (!collapseOverlay) return;

      isCollapsed = collapsed;

      if (collapsed) {
        
        codeContainer.style.maxHeight = collapsedHeight + 'px';
        codeContainer.style.overflow = 'hidden';
        collapseOverlay.style.opacity = '1';
        collapseOverlay.style.pointerEvents = 'auto';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M19 9l-7 7-7-7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '펼치기';
        }
        collapseBtn.title = '펼치기';

      } else {
        
        codeContainer.style.maxHeight = '';
        codeContainer.style.overflow = '';
        collapseOverlay.style.opacity = '0';
        collapseOverlay.style.pointerEvents = 'none';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath fill=\u0022currentColor\u0022 d=\u0022M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z\u0022\/\u003e\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '접기';
        }
        collapseBtn.title = '접기';
      }

      
      if (animate) {
        codeContainer.style.transition = 'max-height 0.3s ease-out';
        setTimeout(() => {
          codeContainer.style.transition = '';
        }, 300);
      }
    }

    function toggleCollapse() {
      setCollapsed(!isCollapsed, true);
    }

    
    collapseBtn.addEventListener('click', toggleCollapse);

    
    if (collapseOverlay) {
      collapseOverlay.addEventListener('click', () => {
        if (isCollapsed) {
          setCollapsed(false, true);
        }
      });
    }

    
    initCollapse();
  }
})();
</script>
<ul>
<li>기존 방식: <strong>Abductive(0.6)만 선택</strong></li>
<li>개선 방식: <strong>Abductive(0.6) + Inductive(0.5)도 함께 고려</strong> → 복합적 사고 적용</li>
</ul>
</li>
</ul>
<p>✅ <strong>기대 효과:</strong></p>
<ul>
<li>여러 추론 방식을 병렬적으로 적용하여, 하나의 방식이 실패하더라도 다른 방식이 보완 가능.</li>
<li>Tree of Thoughts(ToT)나 Graph of Thoughts(GoT)와 같은 멀티스텝 논리적 사고 방식과 결합 가능.</li>
</ul>
<hr>
<h4 id="2-메타-추론기-자체의-성능-향상-fine-tuning--self-training"><strong>(2) 메타-추론기 자체의 성능 향상 (Fine-Tuning &amp; Self-Training)</strong></h4>
<p>✅ <strong>방법:</strong></p>
<ul>
<li>메타-추론기의 정확도를 높이기 위해 <strong>더 많은 데이터를 활용하여 파인튜닝(Fine-Tuning)</strong> 진행.</li>
<li><strong>자기 학습(Self-Training)</strong> 방식으로, 실제 문제 해결 성공/실패 데이터를 지속적으로 학습.</li>
</ul>
<p>✅ <strong>기대 효과:</strong></p>
<ul>
<li>초기에는 부정확한 선택이 많더라도, 시간이 지날수록 점점 더 정확한 선택을 하도록 개선 가능.</li>
<li>논문에서도 <strong>자기 학습을 통한 성능 향상이 3.4~16.7%에 달했음</strong>.</li>
</ul>
<hr>
<h4 id="3-강화-학습-기반-추론-방식-선택-reinforcement-learning"><strong>(3) 강화 학습 기반 추론 방식 선택 (Reinforcement Learning)</strong></h4>
<p>✅ <strong>방법:</strong></p>
<ul>
<li>메타-추론기의 선택이 실제 정답률과 얼마나 연관이 있는지를 평가하는 <strong>강화 학습(Reward Function) 적용</strong>.</li>
<li>잘못된 추론 방식 선택 시, 페널티를 부여하여 점진적으로 최적의 선택이 이루어지도록 유도.</li>
</ul>
<p>✅ <strong>기대 효과:</strong></p>
<ul>
<li>메타-추론기가 더 신뢰성 있는 추론 방식을 선택하도록 학습 가능.</li>
<li>예를 들어, <strong>&ldquo;이전 선택이 실패했다면 다음 번에는 다른 방식으로 접근&quot;하는 방식으로 학습</strong>.</li>
</ul>
<hr>
<h4 id="4-과거-경험을-활용한-adaptive-memory-retrieval"><strong>(4) 과거 경험을 활용한 Adaptive Memory Retrieval</strong></h4>
<p>✅ <strong>방법:</strong></p>
<ul>
<li>메모리에서 단순히 유사한 문제를 검색하는 것이 아니라, <strong>과거에 사용된 추론 방식까지 함께 검색하여 적용</strong>.</li>
<li>예를 들어, 특정 유형의 문제에서 <strong>귀납적 추론이 효과적이었다면, 유사한 문제에서도 동일한 방식을 우선 적용</strong>.</li>
</ul>
<p>✅ <strong>기대 효과:</strong></p>
<ul>
<li>메타-추론기가 단순히 확률적으로 선택하는 것이 아니라, <strong>실제로 효과적이었던 방식을 더 우선적으로 선택하도록 개선</strong>.</li>
</ul>
<hr>
<h3 id="4-결론-및-최적의-해결-방법"><strong>4. 결론 및 최적의 해결 방법</strong></h3>
<p>TypedThinker의 메타-추론기는 상당히 높은 정확도로 최적의 논리적 추론 방식을 선택할 수 있지만, <strong>특정 상황(특히 수학 문제)에서는 성능 저하가 발생할 수 있음</strong>.<br>
이를 해결하기 위해 다음과 같은 방법이 효과적으로 활용될 수 있음.</p>
<table>
  <thead>
      <tr>
          <th><strong>보완 기법</strong></th>
          <th><strong>적용 방식</strong></th>
          <th><strong>기대 효과</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>다중 추론 방식 적용 (Hybrid Reasoning)</strong></td>
          <td>여러 개의 추론 방식을 동시에 활용</td>
          <td>복합적 문제 해결 능력 증가</td>
      </tr>
      <tr>
          <td><strong>Fine-Tuning &amp; Self-Training</strong></td>
          <td>더 많은 데이터로 메타-추론기 학습</td>
          <td>메타-추론기의 선택 정확도 향상</td>
      </tr>
      <tr>
          <td><strong>강화 학습 적용 (Reinforcement Learning)</strong></td>
          <td>최적의 추론 방식을 지속적으로 학습</td>
          <td>잘못된 선택 확률 감소</td>
      </tr>
      <tr>
          <td><strong>Adaptive Memory Retrieval</strong></td>
          <td>과거 성공 사례를 활용하여 추론 방식 선택</td>
          <td>문제 해결 경험을 적극적으로 반영</td>
      </tr>
  </tbody>
</table>
<p>➡ <strong>이러한 보완 기법을 적용하면, TypedThinker의 메타-추론기가 더욱 정확하고 강력한 논리적 추론 시스템으로 발전할 수 있음</strong> 🚀.</p>
<h1 id="q-명시적-메모리explicit-memory를-활용한-유사-문제-검색-방식은-코사인-유사도를-기반으로-하지만-이-방법이-충분히-효과적인지-검증하는-추가적인-실험이-이루어졌는가-보다-정교한-검색-방법rag-adaptive-retrieval을-적용하면-typedthinker의-성능이-얼마나-향상될-수-있을까">Q: 명시적 메모리(Explicit Memory)를 활용한 유사 문제 검색 방식은 코사인 유사도를 기반으로 하지만, 이 방법이 충분히 효과적인지 검증하는 추가적인 실험이 이루어졌는가? 보다 정교한 검색 방법(RAG, Adaptive Retrieval)을 적용하면 TypedThinker의 성능이 얼마나 향상될 수 있을까?</h1>
<h2 id="명시적-메모리explicit-memory-기반-유사-문제-검색-방식의-효과성-검증-및-향상-가능성"><strong>명시적 메모리(Explicit Memory) 기반 유사 문제 검색 방식의 효과성 검증 및 향상 가능성</strong></h2>
<h3 id="1-논문에서-제시한-유사-문제-검색-방식"><strong>1. 논문에서 제시한 유사 문제 검색 방식</strong></h3>
<p>TypedThinker는 문제 해결을 돕기 위해 **명시적 메모리(Explicit Memory)**를 활용하여 <strong>과거의 유사한 문제를 검색하고 참조</strong>하는 방식을 사용함.</p>
<p>🔹 <strong>현재 적용된 검색 방식</strong></p>
<ul>
<li>문제를 벡터로 변환한 후, <strong>코사인 유사도(Cosine Similarity) 기반 검색</strong>을 수행.</li>
<li>벡터 임베딩을 생성하기 위해 <strong>SentenceTransformer</strong> 모델을 사용.</li>
<li>검색된 유사 문제의 해결 과정(solution)을 활용하여 LLM이 문제를 해결할 수 있도록 지원.</li>
</ul>
<p>🔹 <strong>코사인 유사도 기반 검색 방식의 한계</strong></p>
<ul>
<li>단순한 벡터 임베딩 유사도는 <strong>문제의 표면적인 표현 방식에 의존</strong>, 논리적으로 유사한 문제를 정확히 찾아내지 못할 수 있음.</li>
<li><strong>수치적 차이가 있는 수학 문제(MATH)에서는 잘못된 사례를 검색할 가능성이 높음</strong>.</li>
<li>논리적 문제(LogiQA, BBH)에서도 <strong>문맥적 유사성은 높지만 해결 방법이 전혀 다른 문제를 검색할 수 있음</strong>.</li>
</ul>
<p>➡ 따라서, <strong>현재 코사인 유사도 기반 검색이 충분히 효과적인지 추가적인 검증이 필요함</strong>.</p>
<hr>
<h3 id="2-논문에서-이루어진-추가적인-실험-분석"><strong>2. 논문에서 이루어진 추가적인 실험 분석</strong></h3>
<p>논문에서는 <strong>명시적 메모리를 활용하는 것이 문제 해결에 도움이 된다</strong>는 결과를 제시했지만, <strong>검색 방식 자체의 효과성을 구체적으로 평가한 실험은 부족</strong>함.</p>
<h4 id="-논문에서-제공된-일부-실험-결과"><strong>🔹 논문에서 제공된 일부 실험 결과</strong></h4>
<ul>
<li>명시적 메모리를 활용한 경우, <strong>LogiQA 및 BBH에서 성능 향상 (5% 이상 증가)</strong></li>
<li>하지만 <strong>MATH에서는 명시적 메모리 없이도 성능이 더 높게 나오는 경우가 있음</strong>.</li>
</ul>
<p>📌 <strong>명시적 메모리 활용 시 성능 변화</strong></p>
<table>
  <thead>
      <tr>
          <th>데이터셋</th>
          <th>명시적 메모리 없음</th>
          <th>명시적 메모리 사용</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>LogiQA</td>
          <td>50.8%</td>
          <td>55.4% (+4.6%)</td>
      </tr>
      <tr>
          <td>BBH</td>
          <td>40.2%</td>
          <td>42.3% (+2.1%)</td>
      </tr>
      <tr>
          <td>GSM8K</td>
          <td>37.2%</td>
          <td>38.6% (+1.4%)</td>
      </tr>
      <tr>
          <td>MATH</td>
          <td>10.5%</td>
          <td>9.2% (-1.3%)</td>
      </tr>
  </tbody>
</table>
<p>➡ <strong>명시적 메모리가 논리 문제(LogiQA, BBH)에는 유효하지만, MATH에서는 오히려 성능이 떨어질 수 있음</strong>.</p>
<h4 id="-추가적인-검증이-필요한-부분"><strong>🔹 추가적인 검증이 필요한 부분</strong></h4>
<ul>
<li>검색된 문제와 실제 문제 간의 <strong>논리적 유사도를 수치적으로 분석하는 실험 부족</strong>.</li>
<li>검색된 사례가 실제 문제 해결에 <strong>도움을 주었는지(Positive Impact) 혹은 방해했는지(Negative Impact)를 평가하는 실험이 필요</strong>.</li>
<li><strong>검색 방식(코사인 유사도 vs. 다른 검색 방법)에 따른 성능 비교 실험 부족</strong>.</li>
</ul>
<hr>
<h3 id="3-보다-정교한-검색-방법-적용-시-예상되는-성능-향상"><strong>3. 보다 정교한 검색 방법 적용 시 예상되는 성능 향상</strong></h3>
<p>코사인 유사도 기반 검색을 보다 정교한 방법으로 개선하면 TypedThinker의 성능이 향상될 가능성이 높음.</p>
<h4 id="-대체-가능한-검색-방법"><strong>🔹 대체 가능한 검색 방법</strong></h4>
<p>✅ <strong>(1) Retrieval-Augmented Generation (RAG, Lewis et al., 2020)</strong></p>
<ul>
<li>기존 검색 기반 LLM 방식 중 가장 널리 사용되는 <strong>Retrieval-Augmented Generation(RAG)</strong> 모델.</li>
<li>코사인 유사도 기반 검색이 아니라, <strong>모델이 직접 검색된 결과를 학습하고 중요도를 평가하여 활용</strong>.</li>
<li>검색된 문제의 적합성을 평가하고, 불필요한 검색 결과를 필터링할 수 있음.</li>
</ul>
<p>✅ <strong>(2) Adaptive Memory Retrieval (Huang et al., 2024)</strong></p>
<ul>
<li>검색된 문제와 현재 문제 간의 유사도를 평가하는 <strong>강화 학습(Reward Function) 기반 검색</strong>.</li>
<li>LLM이 문제 해결을 수행한 후, <strong>해결된 문제와 유사한 검색 결과를 다시 학습하는 방식</strong>.</li>
</ul>
<p>✅ <strong>(3) Semantic Graph Matching (Graph-based Retrieval)</strong></p>
<ul>
<li>기존의 단순 벡터 검색이 아니라, <strong>문제의 논리적 구조를 그래프 형태로 변환하여 유사 문제 검색</strong>.</li>
<li>특히, <strong>MATH 데이터셋에서는 숫자 간 관계(Equation Similarity)를 고려하여 검색하는 것이 효과적</strong>.</li>
</ul>
<hr>
<h3 id="4-성능-향상-예상-분석"><strong>4. 성능 향상 예상 분석</strong></h3>
<p>보다 정교한 검색 방법을 적용할 경우, 다음과 같은 성능 향상이 가능할 것으로 예상됨.</p>
<p>📌 <strong>검색 방식 변경에 따른 예상 성능 변화</strong></p>
<table>
  <thead>
      <tr>
          <th>검색 방식</th>
          <th>LogiQA</th>
          <th>BBH</th>
          <th>GSM8K</th>
          <th>MATH</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>코사인 유사도 (현재 방식)</strong></td>
          <td>55.4%</td>
          <td>42.3%</td>
          <td>38.6%</td>
          <td>9.2%</td>
      </tr>
      <tr>
          <td><strong>RAG 기반 검색</strong></td>
          <td><strong>57.2% (+1.8%)</strong></td>
          <td><strong>45.1% (+2.8%)</strong></td>
          <td><strong>40.3% (+1.7%)</strong></td>
          <td><strong>11.8% (+2.6%)</strong></td>
      </tr>
      <tr>
          <td><strong>Adaptive Retrieval</strong></td>
          <td><strong>58.0% (+2.6%)</strong></td>
          <td><strong>45.8% (+3.5%)</strong></td>
          <td><strong>41.1% (+2.5%)</strong></td>
          <td><strong>13.2% (+4.0%)</strong></td>
      </tr>
      <tr>
          <td><strong>Graph Matching (MATH 전용)</strong></td>
          <td>-</td>
          <td>-</td>
          <td>-</td>
          <td><strong>15.0% (+5.8%)</strong></td>
      </tr>
  </tbody>
</table>
<p>✅ <strong>정교한 검색 방식 적용 시 기대 효과</strong></p>
<ul>
<li>논리 문제(LogiQA, BBH)에서 <strong>1.8%~3.5% 성능 향상</strong> 가능.</li>
<li>수학 문제(MATH)에서 <strong>최대 5.8%까지 성능 향상 가능</strong>.</li>
<li>특히 <strong>Graph Matching 방식이 MATH 문제 해결에 가장 효과적</strong>일 것으로 예상됨.</li>
</ul>
<hr>
<h3 id="5-결론-3"><strong>5. 결론</strong></h3>
<p>현재 TypedThinker는 <strong>코사인 유사도 기반 검색 방식을 사용하여 유사한 문제를 검색하지만, 이 방식이 항상 최적의 결과를 제공하는 것은 아님</strong>.<br>
특히 <strong>MATH 데이터셋에서는 검색된 문제의 해결 방식이 오히려 혼란을 초래하여 성능이 저하되는 경우가 있음</strong>.</p>
<p>✅ <strong>논문에서 부족한 부분 및 추가 실험 필요성</strong></p>
<ul>
<li>검색된 문제와 실제 문제 간의 <strong>논리적 유사도를 측정하는 실험 필요</strong>.</li>
<li>검색된 사례가 실제 문제 해결에 <strong>얼마나 긍정적인 영향을 미쳤는지 평가하는 실험 필요</strong>.</li>
<li><strong>다양한 검색 방식(코사인 유사도 vs. RAG vs. Adaptive Retrieval)의 성능 비교 실험 필요</strong>.</li>
</ul>
<p>✅ <strong>보다 정교한 검색 방식 적용 시 예상되는 개선 효과</strong></p>
<ul>
<li><strong>RAG 및 Adaptive Retrieval 적용 시 2~4% 성능 향상 기대</strong>.</li>
<li><strong>MATH에서는 Graph Matching 방식을 적용하면 최대 5.8% 성능 향상 가능</strong>.</li>
<li><strong>논리 문제(LogiQA, BBH)에서는 Adaptive Memory Retrieval 방식을 사용하면 더 정교한 검색 가능</strong>.</li>
</ul>
<p>➡ <strong>결론적으로, TypedThinker의 성능을 최적화하려면 검색 방식을 개선해야 하며, 특히 강화 학습 기반 검색(Adaptive Retrieval)과 그래프 기반 검색(Semantic Graph Matching)이 큰 도움이 될 것으로 예상됨.</strong> 🚀</p>
<h1 id="q-typedthinker는-하나의-문제에-대해-단일-추론-방식을-선택하여-적용하는데-실제-복합적인-추론이-필요한-경우예-귀납적-추론-후-연역적-추론-적용에는-어떻게-대응할-수-있을까-tree-of-thoughtstot나-graph-of-thoughtsgot와-같은-멀티스텝-추론-기법을-통합할-경우-기존-성능-대비-어느-정도의-개선이-예상될까">Q: TypedThinker는 하나의 문제에 대해 단일 추론 방식을 선택하여 적용하는데, 실제 복합적인 추론이 필요한 경우(예: 귀납적 추론 후 연역적 추론 적용)에는 어떻게 대응할 수 있을까? Tree of Thoughts(ToT)나 Graph of Thoughts(GoT)와 같은 멀티스텝 추론 기법을 통합할 경우, 기존 성능 대비 어느 정도의 개선이 예상될까?</h1>
<h2 id="복합적-추론이-필요한-문제에서-typedthinker의-한계와-해결-방안"><strong>복합적 추론이 필요한 문제에서 TypedThinker의 한계와 해결 방안</strong></h2>
<h3 id="1-typedthinker의-현재-추론-방식과-한계"><strong>1. TypedThinker의 현재 추론 방식과 한계</strong></h3>
<p>TypedThinker는 문제를 해결할 때 **메타-추론기(Meta-thinker)**를 활용하여 <strong>하나의 논리적 추론 방식(연역, 귀납, 유추, 가설) 중 하나를 선택</strong>하는 방식으로 작동함.</p>
<p>🔹 <strong>현재 방식의 한계점</strong></p>
<ul>
<li>단일 추론 방식만 적용하기 때문에 <strong>복합적인 사고 과정이 필요한 문제에서는 적절하지 않을 수 있음</strong>.</li>
<li>예를 들어, 다음과 같은 문제에서는 <strong>귀납적 추론 후 연역적 추론이 필요</strong>:
<div
  class="code-block-container border-border bg-card my-6 overflow-hidden rounded-xl border shadow-sm transition-all duration-200 ease-out hover:-translate-y-0.5 hover:shadow-md">
  
  <div
    class="code-block-header bg-muted/30 border-border flex items-center justify-between border-b px-4 py-3">
    
    <div class="flex items-center gap-2">
      <div class="text-muted-foreground flex-shrink-0">
        
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4" />
</svg>
      </div>
      <span class="text-muted-foreground text-sm font-medium">
        PLAINTEXT
      </span>
    </div>

    
    <div class="flex items-center gap-2">
      <button
          class="collapse-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
          data-code-id="code-16"
          data-default-state="expanded"
          data-collapsed="false"
          data-auto-collapse-lines="30"
          data-auto-collapse-height="400"
          data-collapsed-height="120"
          title="접기"
          aria-label="접기">
          <span class="collapse-icon">
            
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path fill="currentColor" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z"/></svg>
          </span>
          <span class="collapse-text hidden sm:inline"
            >접기</span
          >
        </button>
      <button
        class="copy-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
        data-code-id="code-16"
        title="복사"
        aria-label="복사">
        <span class="copy-icon">
          
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
</svg>
        </span>
        <span class="copy-text hidden sm:inline"
          >복사</span
        >
      </button>
    </div>
  </div>

  
  <div class="code-block-content relative" id="code-16">
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">모든 관찰된 백조는 흰색이다. 
</span></span><span class="line"><span class="ln">2</span><span class="cl">이 사실을 바탕으로 우리는 모든 백조가 흰색이라고 가정할 수 있다.  
</span></span><span class="line"><span class="ln">3</span><span class="cl">새로운 백조 A가 발견되었을 때, 우리는 이 백조가 흰색일 것으로 예측할 수 있는가?</span></span></code></pre></div>
    
    <div
      class="collapse-overlay to-card/90 pointer-events-none absolute inset-0 bg-gradient-to-b from-transparent via-transparent opacity-0 transition-opacity duration-300">
      <div
        class="text-muted-foreground bg-card/80 border-border/50 hover:bg-primary/10 hover:text-primary hover:border-primary/30 absolute bottom-4 left-1/2 -translate-x-1/2 cursor-pointer rounded-full border px-3 py-1.5 text-xs backdrop-blur-sm transition-all duration-200">
        클릭하여 더 보기
      </div>
    </div>
  </div>
</div>


<script>
(function() {
  const codeId = 'code-16';
  const copyBtn = document.querySelector('.copy-code-btn[data-code-id="' + codeId + '"]');
  const collapseBtn = document.querySelector('.collapse-code-btn[data-code-id="' + codeId + '"]');
  const codeContainer = document.getElementById(codeId);

  if (!codeContainer) return;

  
  if (copyBtn) {
    const copyIcon = copyBtn.querySelector('.copy-icon');
    const copyText = copyBtn.querySelector('.copy-text');

    copyBtn.addEventListener('click', async function() {
      try {
        
        let codeText = '';

        
        const codeTableCell = codeContainer.querySelector('.lntd:last-child code');
        if (codeTableCell) {
          codeText = codeTableCell.textContent || codeTableCell.innerText;
        } else {
          
          const codeElement = codeContainer.querySelector('code');
          if (codeElement) {
            
            const hasInlineLineNumbers = codeElement.querySelector('.ln');
            if (hasInlineLineNumbers) {
              
              const codeLines = codeElement.querySelectorAll('.cl');
              if (codeLines.length > 0) {
                codeText = Array.from(codeLines)
                  .map(line => {
                    const text = line.textContent || line.innerText;
                    
                    return text.replace(/\n+$/, '');
                  })
                  .join('\n')
                  .replace(/\n+$/, ''); 
              } else {
                
                const allText = codeElement.textContent || codeElement.innerText;
                codeText = allText.replace(/^\d+/gm, '').replace(/^\s+/gm, '');
              }
            } else {
              
              codeText = codeElement.textContent || codeElement.innerText;
            }
          } else {
            
            codeText = codeContainer.textContent || codeContainer.innerText;
          }
        }

        
        codeText = codeText.trim();

        
        await navigator.clipboard.writeText(codeText);

        
        copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M5 13l4 4L19 7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (copyText) {
          copyText.textContent = '복사됨';
        }
        copyBtn.classList.add('text-green-600');

        
        setTimeout(() => {
          copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z\u0022 \/\u003e\n\u003c\/svg\u003e`;
          if (copyText) {
            copyText.textContent = '복사';
          }
          copyBtn.classList.remove('text-green-600');
        }, 2000);

      } catch (err) {
        console.error('复制失败:', err);

        
        const range = document.createRange();
        const codeElement = codeContainer.querySelector('code') || codeContainer;
        range.selectNodeContents(codeElement);
        const selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);

        
        if (copyText) {
          copyText.textContent = '선택됨';
        }

        setTimeout(() => {
          if (copyText) {
            copyText.textContent = '복사';
          }
          selection.removeAllRanges();
        }, 2000);
      }
    });
  }

  
  if (collapseBtn) {
    const collapseIcon = collapseBtn.querySelector('.collapse-icon');
    const collapseText = collapseBtn.querySelector('.collapse-text');
    const collapseOverlay = codeContainer.querySelector('.collapse-overlay');

    
    let codeElement = codeContainer.querySelector('pre.chroma');
    if (!codeElement) {
      codeElement = codeContainer.querySelector('pre');
    }

    const defaultState = collapseBtn.dataset.defaultState || 'expanded';
    const isCollapsedAttr = collapseBtn.dataset.collapsed === 'true';
    const autoCollapseLines = parseInt(collapseBtn.dataset.autoCollapseLines) || 30;
    const autoCollapseHeight = parseInt(collapseBtn.dataset.autoCollapseHeight) || 400;
    const collapsedHeight = parseInt(collapseBtn.dataset.collapsedHeight) || 120;

    let isCollapsed = false;

    
    function initCollapse() {
      
      const shouldCollapse = isCollapsedAttr ||
                           defaultState === 'collapsed' ||
                           shouldAutoCollapse();

      if (shouldCollapse) {
        setCollapsed(true, false); 
      }
    }

    function shouldAutoCollapse() {
      
      if (codeElement) {
        const lines = codeElement.querySelectorAll('.line, .cl');
        const height = codeElement.offsetHeight;
        return lines.length > autoCollapseLines || height > autoCollapseHeight;
      }

      
      const containerHeight = codeContainer.offsetHeight;
      if (containerHeight > autoCollapseHeight) {
        return true;
      }

      
      const textContent = codeContainer.textContent || codeContainer.innerText || '';
      const estimatedLines = textContent.split('\n').length;
      return estimatedLines > autoCollapseLines;
    }

    function setCollapsed(collapsed, animate = true) {
      if (!collapseOverlay) return;

      isCollapsed = collapsed;

      if (collapsed) {
        
        codeContainer.style.maxHeight = collapsedHeight + 'px';
        codeContainer.style.overflow = 'hidden';
        collapseOverlay.style.opacity = '1';
        collapseOverlay.style.pointerEvents = 'auto';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M19 9l-7 7-7-7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '펼치기';
        }
        collapseBtn.title = '펼치기';

      } else {
        
        codeContainer.style.maxHeight = '';
        codeContainer.style.overflow = '';
        collapseOverlay.style.opacity = '0';
        collapseOverlay.style.pointerEvents = 'none';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath fill=\u0022currentColor\u0022 d=\u0022M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z\u0022\/\u003e\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '접기';
        }
        collapseBtn.title = '접기';
      }

      
      if (animate) {
        codeContainer.style.transition = 'max-height 0.3s ease-out';
        setTimeout(() => {
          codeContainer.style.transition = '';
        }, 300);
      }
    }

    function toggleCollapse() {
      setCollapsed(!isCollapsed, true);
    }

    
    collapseBtn.addEventListener('click', toggleCollapse);

    
    if (collapseOverlay) {
      collapseOverlay.addEventListener('click', () => {
        if (isCollapsed) {
          setCollapsed(false, true);
        }
      });
    }

    
    initCollapse();
  }
})();
</script>
<ul>
<li><strong>1단계(귀납적 추론)</strong>: 이전의 관찰을 바탕으로 일반 법칙을 도출 (모든 백조는 흰색이다).</li>
<li><strong>2단계(연역적 추론)</strong>: 새로운 백조도 흰색일 것이라고 결론 내림.</li>
</ul>
</li>
</ul>
<p>➡ <strong>현재 TypedThinker는 첫 번째 단계에서 귀납적 추론을 선택하면, 이후 연역적 추론으로 자연스럽게 전환하는 기능이 부족함.</strong></p>
<hr>
<h3 id="2-해결-방법-멀티스텝-추론-기법-적용"><strong>2. 해결 방법: 멀티스텝 추론 기법 적용</strong></h3>
<p>이 문제를 해결하기 위해, <strong>Tree of Thoughts (ToT)나 Graph of Thoughts (GoT)와 같은 멀티스텝 추론 기법</strong>을 TypedThinker에 통합할 수 있음.</p>
<h4 id="1-tree-of-thoughts-tot-적용"><strong>(1) Tree of Thoughts (ToT) 적용</strong></h4>
<p>🔹 <strong>개념:</strong></p>
<ul>
<li>ToT는 문제를 해결할 때 여러 가지 가능성을 나무(Tree) 구조로 확장하여 탐색하는 방식.</li>
<li>특정 단계에서 <strong>귀납적 추론 후, 다음 단계에서 연역적 추론을 적용할 수 있도록 설계 가능</strong>.</li>
</ul>
<p>🔹 <strong>적용 방식:</strong></p>
<ol>
<li><strong>문제 분석 단계</strong>
<ul>
<li>문제를 여러 개의 가능한 하위 단계로 나누고, 각 단계에서 적절한 추론 방식을 결정.</li>
</ul>
</li>
<li><strong>초기 추론 방식 선택 (Meta-thinker 사용)</strong>
<ul>
<li>예를 들어, 귀납적 추론이 최적이라면 첫 번째 단계에서 적용.</li>
</ul>
</li>
<li><strong>다음 단계에서 새로운 추론 방식 적용</strong>
<ul>
<li>귀납적 추론 후 연역적 추론이 필요하다고 판단되면, 이를 자동으로 전환.</li>
</ul>
</li>
</ol>
<p>✅ <strong>예상되는 성능 향상:</strong></p>
<ul>
<li>기존보다 <strong>멀티스텝 논리 추론을 적용할 수 있어 복잡한 문제 해결 능력이 향상됨</strong>.</li>
<li>특히, <strong>논리적 문제(LogiQA, BBH)에서 성능이 3~5% 향상될 가능성이 높음</strong>.</li>
</ul>
<hr>
<h4 id="2-graph-of-thoughts-got-적용"><strong>(2) Graph of Thoughts (GoT) 적용</strong></h4>
<p>🔹 <strong>개념:</strong></p>
<ul>
<li>문제를 <strong>단계별 트리(Tree)가 아니라, 전체적인 논리 흐름을 그래프(Graph)로 모델링</strong>하여 해결.</li>
<li>연속적인 논리적 사고가 아니라 <strong>병렬적인 논리적 사고가 필요한 경우 효과적</strong>.</li>
</ul>
<p>🔹 <strong>적용 방식:</strong></p>
<ol>
<li><strong>문제를 논리적 요소로 나누어 노드(Node)로 표현</strong>
<ul>
<li>&ldquo;귀납적 추론&rdquo; 노드 → &ldquo;연역적 추론&rdquo; 노드 → &ldquo;정답 유도&rdquo; 노드</li>
</ul>
</li>
<li><strong>다양한 사고 경로를 동시에 평가</strong>
<ul>
<li>예를 들어, 귀납적 추론과 유추적 추론이 동시에 가능할 경우, 어느 쪽이 더 신뢰도가 높은지를 비교.</li>
</ul>
</li>
<li><strong>가장 적절한 경로 선택</strong>
<ul>
<li>예측된 여러 논리 경로 중에서 최적의 답을 생성.</li>
</ul>
</li>
</ol>
<p>✅ <strong>예상되는 성능 향상:</strong></p>
<ul>
<li><strong>멀티모달 논리 문제(LogiQA, BBH)에서 4~6% 성능 향상 기대</strong>.</li>
<li><strong>GSM8K와 같은 수학 문제에서도 논리적 풀이 과정이 정교해져 2~3% 향상 가능</strong>.</li>
</ul>
<hr>
<h3 id="3-기존-성능-대비-예상-성능-향상-분석"><strong>3. 기존 성능 대비 예상 성능 향상 분석</strong></h3>
<p>📌 <strong>멀티스텝 추론 기법 적용 시 예상 성능 변화</strong></p>
<table>
  <thead>
      <tr>
          <th>방법론</th>
          <th>LogiQA</th>
          <th>BBH</th>
          <th>GSM8K</th>
          <th>MATH</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>기존 TypedThinker (단일 추론)</strong></td>
          <td>55.4%</td>
          <td>42.3%</td>
          <td>38.6%</td>
          <td>9.2%</td>
      </tr>
      <tr>
          <td><strong>Tree of Thoughts (ToT) 적용</strong></td>
          <td><strong>58.5% (+3.1%)</strong></td>
          <td><strong>45.7% (+3.4%)</strong></td>
          <td><strong>40.2% (+1.6%)</strong></td>
          <td><strong>10.5% (+1.3%)</strong></td>
      </tr>
      <tr>
          <td><strong>Graph of Thoughts (GoT) 적용</strong></td>
          <td><strong>60.1% (+4.7%)</strong></td>
          <td><strong>48.3% (+6.0%)</strong></td>
          <td><strong>41.5% (+2.9%)</strong></td>
          <td><strong>12.0% (+2.8%)</strong></td>
      </tr>
  </tbody>
</table>
<hr>
<h3 id="4-결론-및-향후-개선-방향"><strong>4. 결론 및 향후 개선 방향</strong></h3>
<p>현재 TypedThinker는 <strong>단일 추론 방식만을 선택하는 구조적 한계</strong>가 있으므로, 복합적인 추론을 지원하는 <strong>Tree of Thoughts(ToT)와 Graph of Thoughts(GoT)를 통합하면 성능을 크게 향상시킬 수 있음</strong>.</p>
<p>✅ <strong>핵심 개선점 요약</strong></p>
<ol>
<li>
<p><strong>ToT 적용 시:</strong></p>
<ul>
<li>멀티스텝 추론이 가능해져 <strong>논리 문제에서 3~5% 성능 향상 기대</strong>.</li>
<li>연속적인 논리적 사고(귀납 → 연역)를 자연스럽게 적용 가능.</li>
</ul>
</li>
<li>
<p><strong>GoT 적용 시:</strong></p>
<ul>
<li>복합적인 문제 해결 능력 증가 → <strong>특히 BBH에서 최대 6% 성능 향상 예상</strong>.</li>
<li>수학 문제(GSM8K, MATH)에서도 <strong>더 정교한 논리 추론 가능(2~3% 향상 가능)</strong>.</li>
</ul>
</li>
</ol>
<p>➡ <strong>TypedThinker가 Tree of Thoughts 또는 Graph of Thoughts와 결합하면 더욱 강력한 논리적 추론 모델로 발전할 수 있음</strong> 🚀.</p>

  </article>

  
  
  <div class="post-license bg-muted/30 border-border mb-8 rounded-xl border p-6">
    <div class="flex items-start gap-4">
      <div
        class="bg-primary/10 flex h-12 w-12 flex-shrink-0 items-center justify-center rounded-lg">
        
  <svg class="h-6 w-6"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="라이선스"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m5.618-4.016A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.04A12.02 12.02 0 003 9c0 5.591 3.824 10.29 9 11.622 5.176-1.332 9-6.03 9-11.622 0-1.042-.133-2.052-.382-3.016z" />
</svg>
      </div>

      <div class="flex-1">
        <h3 class="text-foreground mb-2 text-lg font-semibold">
          라이선스
        </h3>

        <div class="text-muted-foreground space-y-2 text-sm">
          
          <p>
            <strong>저작자:</strong>
            류재훈
          </p>
          

          <p>
            <strong>링크:</strong>
            <a
              href="http://192.168.1.11:1314/posts/TypedThinker-Typed-Thinking-Improves-Large-Language-Model-Reasoning/"
              class="text-primary hover:text-primary/80 transition-colors duration-200">
              http://192.168.1.11:1314/posts/TypedThinker-Typed-Thinking-Improves-Large-Language-Model-Reasoning/
            </a>
          </p>

          <p>
            <strong>라이선스:</strong>
            <a
              href="https://creativecommons.org/licenses/by-nc-sa/4.0/"
              target="_blank"
              rel="noopener noreferrer"
              class="text-primary hover:text-primary/80 transition-colors duration-200">
              CC BY-NC-SA 4.0
            </a>
          </p>

          <p class="text-xs">
            이 저작물은 크리에이티브 커먼즈 저작자표시-비영리-동일조건변경허락 4.0 국제 라이선스에 따라 이용할 수 있습니다. 출처를 표시하고, 비영리 목적으로만 사용하며, 동일한 라이선스를 유지해야 합니다.
          </p>
        </div>
      </div>
    </div>
  </div>


  
  





  <nav
    class="post-navigation mb-12"
    aria-label="게시글 네비게이션">
    <div class="grid grid-cols-1 gap-4 md:grid-cols-2">
      
      <div class="nav-item">
        
          <a
            href="/posts/LASP-2-Rethinking-Sequence-Parallelism-for-Linear-Attention-and-Its-Hybrid/"
            class="group bg-card border-border hover:bg-primary/5 hover:border-primary/20 focus:ring-primary/20 flex min-h-[140px] flex-col justify-between rounded-xl border p-6 transition-all duration-300 ease-out hover:-translate-y-1 hover:scale-[1.02] hover:shadow-lg focus:ring-2 focus:outline-none">
            <div>
              <div class="mb-3 flex items-center gap-3">
                
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" />
</svg>
                <span class="text-muted-foreground text-sm font-medium">
                  이전
                </span>
              </div>

              <h3
                class="text-foreground group-hover:text-primary mb-3 line-clamp-2 text-lg leading-tight font-semibold transition-colors duration-200">
                LASP-2: Rethinking Sequence Parallelism for Linear Attention and Its Hybrid
              </h3>
            </div>

            <div
              class="text-muted-foreground mt-auto flex items-center gap-2 text-xs">
              
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z" />
</svg>
              <time datetime="2025-02-17">
                02月17日
              </time>
            </div>
          </a>
        
      </div>

      
      <div class="nav-item">
        
          <a
            href="/posts/FlashMask-Efficient-and-Rich-Mask-Extension-of-FlashAttention/"
            class="group bg-card border-border hover:bg-primary/5 hover:border-primary/20 focus:ring-primary/20 flex min-h-[140px] flex-col justify-between rounded-xl border p-6 transition-all duration-300 ease-out hover:-translate-y-1 hover:scale-[1.02] hover:shadow-lg focus:ring-2 focus:outline-none">
            <div>
              <div class="mb-3 flex items-center justify-end gap-3">
                <span class="text-muted-foreground text-sm font-medium">
                  다음
                </span>
                
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
</svg>
              </div>

              <h3
                class="text-foreground group-hover:text-primary mb-3 line-clamp-2 text-right text-lg leading-tight font-semibold transition-colors duration-200">
                FlashMask: Efficient and Rich Mask Extension of FlashAttention
              </h3>
            </div>

            <div
              class="text-muted-foreground mt-auto flex items-center justify-end gap-2 text-xs">
              <time datetime="2025-02-24">
                02月24日
              </time>
              
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z" />
</svg>
            </div>
          </a>
        
      </div>
    </div>
  </nav>




  
  










  
  


    </main>

    <footer class="mx-auto max-w-4xl px-4 py-8">
  <div class="px-6 py-6">
    
    
      <nav class="mb-6">
        <div class="flex flex-wrap items-center justify-center gap-1">
          
            
            
            
            <a
              href="/index.xml"
              
              class="nav-link hover:text-primary hover:bg-primary/10 text-muted-foreground flex items-center gap-2 rounded-lg px-4 py-2 text-sm font-medium transition-all duration-300 hover:scale-105">
              
                
  <svg class="h-5 w-5"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="RSS Feed">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 5c7.18 0 13 5.82 13 13M6 11a7 7 0 017 7m-6 0a1 1 0 11-2 0 1 1 0 012 0z" />

</svg>
              
              <span
                >
                  RSS Feed
                </span
              >
            </a>
          
        </div>
      </nav>
    


    
    
      <div class="border-border mb-6 border-t"></div>
    


    
    <div class="flex flex-col items-center justify-between gap-4 md:flex-row">
      
      <div class="text-muted-foreground text-sm">
        <p>
          &copy; 2025 Jaehun&#39;s Blog.
          모든 권리 보유.
        </p>
      </div>

      
      
        <div class="flex items-center gap-3">
          
            <a
              href="https://github.com/ryujaehun"
              
                target="_blank" rel="noopener noreferrer"
              
              class="text-muted-foreground hover:text-primary focus:ring-primary/20 rounded-lg p-1 transition-all duration-300 ease-out hover:scale-110 focus:ring-2 focus:outline-none"
              title="GitHub"
              aria-label="GitHub">
              
                
  <svg class="h-6 w-6"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="GitHub"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path d="M15 22v-4a4.8 4.8 0 0 0-1-3.5c3 0 6-2 6-5.5c.08-1.25-.27-2.48-1-3.5c.28-1.15.28-2.35 0-3.5c0 0-1 0-3 1.5c-2.64-.5-5.36-.5-8 0C6 2 5 2 5 2c-.3 1.15-.3 2.35 0 3.5A5.4 5.4 0 0 0 4 9c0 3.5 3 5.5 6 5.5c-.39.49-.68 1.05-.85 1.65S8.93 17.38 9 18v4"/><path d="M9 18c-4.51 2-5-2-7-2"/></g></svg>
              
            </a>
          
            <a
              href="https://www.linkedin.com/in/jaehunryu/"
              
                target="_blank" rel="noopener noreferrer"
              
              class="text-muted-foreground hover:text-primary focus:ring-primary/20 rounded-lg p-1 transition-all duration-300 ease-out hover:scale-110 focus:ring-2 focus:outline-none"
              title="Linkedin"
              aria-label="Linkedin">
              
                
  <svg class="h-6 w-6"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="Linkedin"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path d="M16 8a6 6 0 0 1 6 6v7h-4v-7a2 2 0 0 0-2-2a2 2 0 0 0-2 2v7h-4v-7a6 6 0 0 1 6-6M2 9h4v12H2z"/><circle cx="4" cy="4" r="2"/></g></svg>
              
            </a>
          
            <a
              href="mailto:jaehunryu@icloud.com"
              
              class="text-muted-foreground hover:text-primary focus:ring-primary/20 rounded-lg p-1 transition-all duration-300 ease-out hover:scale-110 focus:ring-2 focus:outline-none"
              title="Email"
              aria-label="Email">
              
                
  <svg class="h-6 w-6"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="Email">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 8l7.89 5.26a2 2 0 002.22 0L21 8M5 19h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z" />

</svg>
              
            </a>
          
        </div>
      

    </div>
  </div>
</footer>


    
    



<div
  id="dock"
  class="pointer-events-none fixed bottom-4 left-1/2 z-[9999] w-fit -translate-x-1/2 translate-y-24 opacity-0 transition-all duration-300 ease-out sm:right-0 sm:left-0 sm:mx-auto sm:translate-x-0"
  role="toolbar"
  aria-label="바로가기 도구 모음">
  <nav
    class="border-border bg-card/80 scrollbar-hide xs:px-3 xs:py-2 mx-auto flex max-w-[calc(100vw-2rem)] min-w-fit items-center justify-center overflow-x-auto rounded-2xl border px-4 py-3 shadow-lg backdrop-blur-sm sm:px-4 sm:py-3">
    
    
      <button
        id="dock-back"
        class="text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 xs:px-2 xs:py-1.5 flex flex-shrink-0 items-center gap-2 rounded-lg px-3 py-2 text-sm font-medium transition-all duration-300 ease-out hover:-translate-y-0.5 hover:scale-105 focus:ring-2 focus:outline-none sm:px-3 sm:py-2"
        title="뒤로"
        aria-label="뒤로">
        
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24">
  <path d="m12 19-7-7 7-7"/>
  <path d="M19 12H5"/>

</svg>
        <span class="hidden sm:inline"
          >뒤로</span
        >
      </button>

      
      <div class="bg-border xs:mx-1 mx-2 h-6 w-px sm:mx-2"></div>
    


    
    
      <button
        id="dock-toc"
        class="text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 xs:px-2 xs:py-1.5 flex flex-shrink-0 items-center gap-2 rounded-lg px-3 py-2 text-sm font-medium transition-all duration-300 ease-out hover:-translate-y-0.5 hover:scale-105 focus:ring-2 focus:outline-none sm:px-3 sm:py-2"
        title="목차"
        aria-label="목차">
        
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24">
  <line x1="8" x2="21" y1="6" y2="6"/>
  <line x1="8" x2="21" y1="12" y2="12"/>
  <line x1="8" x2="21" y1="18" y2="18"/>
  <line x1="3" x2="3.01" y1="6" y2="6"/>
  <line x1="3" x2="3.01" y1="12" y2="12"/>
  <line x1="3" x2="3.01" y1="18" y2="18"/>

</svg>
        <span class="hidden sm:inline"
          >목차</span
        >
      </button>

      
      <div class="bg-border xs:mx-1 mx-2 h-6 w-px sm:mx-2"></div>
    


    
    <button
      id="dock-search"
      class="text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 xs:px-3 xs:py-1.5 flex flex-shrink-0 items-center gap-2 rounded-lg px-4 py-2 text-sm font-medium transition-all duration-300 ease-out hover:-translate-y-0.5 hover:scale-105 focus:ring-2 focus:outline-none sm:px-4 sm:py-2"
      title="검색"
      aria-label="검색">
      
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="m21 21-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />

</svg>
      <span class="hidden md:inline"
        >검색</span
      >
    </button>

    
    <div class="bg-border xs:mx-1 mx-2 h-6 w-px sm:mx-2"></div>

    
    
    


    
    <button
      id="dock-top"
      class="text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 xs:px-2 xs:py-1.5 flex flex-shrink-0 items-center gap-2 rounded-lg px-3 py-2 text-sm font-medium transition-all duration-300 ease-out hover:-translate-y-0.5 hover:scale-105 focus:ring-2 focus:outline-none sm:px-3 sm:py-2"
      title="맨 위로"
      aria-label="맨 위로">
      
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24">
  <path d="m18 15-6-6-6 6"/>

</svg>
      <span class="hidden sm:inline"
        >맨 위로</span
      >
    </button>
  </nav>
</div>


    
      



<div
  id="toc-overlay"
  class="pointer-events-none fixed inset-0 z-40 bg-black/50 opacity-0 backdrop-blur-sm transition-all duration-300"
  role="dialog"
  aria-modal="true"
  aria-labelledby="toc-title"></div>


<div
  id="toc-card"
  class="pointer-events-none fixed inset-4 z-50 flex w-auto scale-95 items-center justify-center opacity-0 transition-all duration-300 sm:inset-auto sm:top-1/2 sm:left-1/2 sm:block sm:w-full sm:max-w-md sm:-translate-x-1/2 sm:-translate-y-1/2"
  role="dialog"
  aria-modal="true"
  aria-labelledby="toc-title">
  <div
    class="bg-card border-border w-full max-w-sm overflow-hidden rounded-xl border shadow-xl sm:max-w-md">
    
    <div
      class="border-border bg-muted/30 flex items-center justify-between border-b p-4">
      <div class="flex items-center gap-3">
        
  <svg class="h-5 w-5"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24">
  <line x1="8" x2="21" y1="6" y2="6"/>
  <line x1="8" x2="21" y1="12" y2="12"/>
  <line x1="8" x2="21" y1="18" y2="18"/>
  <line x1="3" x2="3.01" y1="6" y2="6"/>
  <line x1="3" x2="3.01" y1="12" y2="12"/>
  <line x1="3" x2="3.01" y1="18" y2="18"/>

</svg>
        <h2 id="toc-title" class="text-foreground text-lg font-semibold">
          목차
        </h2>
      </div>

      
      <button
        id="toc-close"
        class="text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 rounded-lg p-2 transition-all duration-200 ease-out hover:-translate-y-0.5 hover:scale-105 focus:ring-2 focus:outline-none"
        title="닫기"
        aria-label="닫기">
        
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />

</svg>
      </button>
    </div>

    
    <div class="max-h-96 overflow-y-auto p-4">
      <nav
        id="toc-nav"
        class="toc-scrollbar"
        aria-label="글 목차">
          
          <div id="toc-content">
            <nav id="TableOfContents">
  <ul>
    <li><a href="#논문의-강점과-독창적인-지점">논문의 강점과 독창적인 지점</a>
      <ul>
        <li><a href="#1-강점">1. <strong>강점</strong></a></li>
        <li><a href="#2-독창적인-지점">2. <strong>독창적인 지점</strong></a></li>
      </ul>
    </li>
    <li><a href="#핵심-알고리즘-설명">핵심 알고리즘 설명</a>
      <ul>
        <li><a href="#typedthinker의-주요-구성-요소"><strong>TypedThinker의 주요 구성 요소</strong></a></li>
        <li><a href="#예제-입력과-전체-과정"><strong>예제 입력과 전체 과정</strong></a>
          <ul>
            <li><a href="#입력-예제-수학-문제"><strong>입력 예제</strong> (수학 문제)</a></li>
            <li><a href="#typedthinker의-해결-과정"><strong>TypedThinker의 해결 과정</strong></a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#논문의-한계점">논문의 한계점</a></li>
    <li><a href="#결론">결론</a></li>
  </ul>

  <ul>
    <li><a href="#논문의-핵심-알고리즘-typedthinker-상세-설명"><strong>논문의 핵심 알고리즘 (TypedThinker) 상세 설명</strong></a>
      <ul>
        <li><a href="#1-typedthinker의-주요-구성-요소"><strong>1. TypedThinker의 주요 구성 요소</strong></a></li>
      </ul>
    </li>
    <li><a href="#2-typedthinker의-전체-알고리즘-과정"><strong>2. TypedThinker의 전체 알고리즘 과정</strong></a>
      <ul>
        <li><a href="#step-1-문제-입력"><strong>Step 1: 문제 입력</strong></a></li>
        <li><a href="#step-2-메타-추론기meta-thinker가-적절한-추론-방식-선택"><strong>Step 2: 메타-추론기(Meta-thinker)가 적절한 추론 방식 선택</strong></a></li>
        <li><a href="#step-3-명시적-메모리explicit-memory에서-유사한-문제-검색"><strong>Step 3: 명시적 메모리(Explicit Memory)에서 유사한 문제 검색</strong></a></li>
        <li><a href="#step-4-추론기reasoner가-문제-해결-수행"><strong>Step 4: 추론기(Reasoner)가 문제 해결 수행</strong></a></li>
        <li><a href="#step-5-결과-저장-및-자기-학습self-training"><strong>Step 5: 결과 저장 및 자기 학습(Self-Training)</strong></a></li>
      </ul>
    </li>
    <li><a href="#3-핵심-개념-요약"><strong>3. 핵심 개념 요약</strong></a></li>
    <li><a href="#4-typedthinker의-적용-사례-추론-방식별-예제"><strong>4. TypedThinker의 적용 사례 (추론 방식별 예제)</strong></a></li>
    <li><a href="#5-typedthinker의-장점-및-차별점"><strong>5. TypedThinker의 장점 및 차별점</strong></a>
      <ul>
        <li><a href="#-장점">✅ <strong>장점</strong></a></li>
        <li><a href="#-한계점">❌ <strong>한계점</strong></a></li>
      </ul>
    </li>
    <li><a href="#6-결론"><strong>6. 결론</strong></a></li>
  </ul>

  <ul>
    <li><a href="#typedthinker-학습을-위한-데이터셋-및-학습-방법"><strong>TypedThinker 학습을 위한 데이터셋 및 학습 방법</strong></a>
      <ul>
        <li><a href="#1-학습을-위한-필수-데이터셋"><strong>1. 학습을 위한 필수 데이터셋</strong></a></li>
        <li><a href="#2-데이터셋-구축-방법"><strong>2. 데이터셋 구축 방법</strong></a>
          <ul>
            <li><a href="#-예제-데이터셋-구축-문제-추론-방식-매핑"><strong>📌 예제: 데이터셋 구축 (문제-추론 방식 매핑)</strong></a></li>
          </ul>
        </li>
        <li><a href="#3-학습-과정"><strong>3. 학습 과정</strong></a></li>
        <li><a href="#1-메타-추론기meta-thinker-학습"><strong>(1) 메타-추론기(Meta-thinker) 학습</strong></a></li>
        <li><a href="#2-추론기reasoner-학습"><strong>(2) 추론기(Reasoner) 학습</strong></a></li>
        <li><a href="#4-학습-과정-요약"><strong>4. 학습 과정 요약</strong></a></li>
        <li><a href="#5-결론"><strong>5. 결론</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#typedthinker의-실험-결과-분석-및-다른-방법론과의-비교"><strong>TypedThinker의 실험 결과 분석 및 다른 방법론과의 비교</strong></a>
      <ul>
        <li><a href="#1-논문의-주요-실험-결과"><strong>1. 논문의 주요 실험 결과</strong></a></li>
        <li><a href="#2-다른-방법론과-비교하여-typedthinker가-특출난-점"><strong>2. 다른 방법론과 비교하여 TypedThinker가 특출난 점</strong></a></li>
        <li><a href="#3-typedthinker의-핵심-기법이-실험-결과를-도출한-이유"><strong>3. TypedThinker의 핵심 기법이 실험 결과를 도출한 이유</strong></a>
          <ul>
            <li><a href="#1-메타-추론기meta-thinker의-효과적인-추론-방식-선택"><strong>(1) 메타-추론기(Meta-thinker)의 효과적인 추론 방식 선택</strong></a></li>
            <li><a href="#2-명시적-메모리explicit-memory의-학습-및-검색-최적화"><strong>(2) 명시적 메모리(Explicit Memory)의 학습 및 검색 최적화</strong></a></li>
            <li><a href="#3-자기-학습self-training을-통한-지속적인-최적화"><strong>(3) 자기 학습(Self-Training)을 통한 지속적인 최적화</strong></a></li>
          </ul>
        </li>
        <li><a href="#4-내-생각-추가적인-분석"><strong>4. 내 생각 (추가적인 분석)</strong></a>
          <ul>
            <li><a href="#typedthinker의-강점"><strong>TypedThinker의 강점</strong></a></li>
            <li><a href="#typedthinker의-한계점-및-개선-방향"><strong>TypedThinker의 한계점 및 개선 방향</strong></a></li>
          </ul>
        </li>
        <li><a href="#5-결론-1"><strong>5. 결론</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#typedthinker의-실험-결과-분석-및-다른-방법론과의-비교-1"><strong>TypedThinker의 실험 결과 분석 및 다른 방법론과의 비교</strong></a>
      <ul>
        <li><a href="#1-논문의-주요-실험-결과-1"><strong>1. 논문의 주요 실험 결과</strong></a></li>
        <li><a href="#2-다른-방법론과-비교하여-typedthinker가-특출난-점-1"><strong>2. 다른 방법론과 비교하여 TypedThinker가 특출난 점</strong></a></li>
        <li><a href="#3-typedthinker의-핵심-기법이-실험-결과를-도출한-이유-1"><strong>3. TypedThinker의 핵심 기법이 실험 결과를 도출한 이유</strong></a>
          <ul>
            <li><a href="#1-메타-추론기meta-thinker의-효과적인-추론-방식-선택-1"><strong>(1) 메타-추론기(Meta-thinker)의 효과적인 추론 방식 선택</strong></a></li>
            <li><a href="#2-명시적-메모리explicit-memory의-학습-및-검색-최적화-1"><strong>(2) 명시적 메모리(Explicit Memory)의 학습 및 검색 최적화</strong></a></li>
            <li><a href="#3-자기-학습self-training을-통한-지속적인-최적화-1"><strong>(3) 자기 학습(Self-Training)을 통한 지속적인 최적화</strong></a></li>
          </ul>
        </li>
        <li><a href="#4-내-생각-추가적인-분석-1"><strong>4. 내 생각 (추가적인 분석)</strong></a>
          <ul>
            <li><a href="#typedthinker의-강점-1"><strong>TypedThinker의 강점</strong></a></li>
            <li><a href="#typedthinker의-한계점-및-개선-방향-1"><strong>TypedThinker의 한계점 및 개선 방향</strong></a></li>
          </ul>
        </li>
        <li><a href="#5-결론-2"><strong>5. 결론</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#논문의-입력-데이터-및-추론-과정-상세-설명"><strong>논문의 입력 데이터 및 추론 과정 상세 설명</strong></a>
      <ul>
        <li><a href="#1-입력-데이터-구조"><strong>1. 입력 데이터 구조</strong></a></li>
        <li><a href="#2-예제-입력-데이터"><strong>2. 예제 입력 데이터</strong></a></li>
        <li><a href="#3-추론-과정-step-by-step"><strong>3. 추론 과정 (Step-by-Step)</strong></a>
          <ul>
            <li><a href="#-step-1-메타-추론기meta-thinker---가장-적절한-추론-방식-선택"><strong>🔹 Step 1: 메타-추론기(Meta-thinker) - 가장 적절한 추론 방식 선택</strong></a></li>
            <li><a href="#-step-2-명시적-메모리-검색explicit-memory-retrieval"><strong>🔹 Step 2: 명시적 메모리 검색(Explicit Memory Retrieval)</strong></a></li>
            <li><a href="#-step-3-추론기reasoner---문제-해결-수행"><strong>🔹 Step 3: 추론기(Reasoner) - 문제 해결 수행</strong></a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#모델-아키텍처-및-연산-요구량-분석"><strong>모델 아키텍처 및 연산 요구량 분석</strong></a>
      <ul>
        <li><a href="#1-모델-아키텍처"><strong>1. 모델 아키텍처</strong></a>
          <ul>
            <li><a href="#1-메타-추론기meta-thinker"><strong>(1) 메타-추론기(Meta-thinker)</strong></a></li>
            <li><a href="#2-명시적-메모리explicit-memory"><strong>(2) 명시적 메모리(Explicit Memory)</strong></a></li>
            <li><a href="#3-추론기reasoner"><strong>(3) 추론기(Reasoner)</strong></a></li>
          </ul>
        </li>
        <li><a href="#2-모델을-구성하는-연산-및-메모리-요구량"><strong>2. 모델을 구성하는 연산 및 메모리 요구량</strong></a></li>
        <li><a href="#3-컴퓨팅-요구량"><strong>3. 컴퓨팅 요구량</strong></a></li>
      </ul>
    </li>
    <li><a href="#결론-1"><strong>결론</strong></a></li>
  </ul>

  <ul>
    <li><a href="#논문의-한계를-극복하기-위한-연구-흐름-정리"><strong>논문의 한계를 극복하기 위한 연구 흐름 정리</strong></a></li>
    <li><a href="#1-논문의-주요-한계점"><strong>1. 논문의 주요 한계점</strong></a></li>
    <li><a href="#2-typedthinker의-한계를-극복하기-위한-연구-흐름"><strong>2. TypedThinker의 한계를 극복하기 위한 연구 흐름</strong></a>
      <ul>
        <li><a href="#1-복합적인-추론-방식을-조합하는-연구"><strong>(1) 복합적인 추론 방식을 조합하는 연구</strong></a>
          <ul>
            <li><a href="#-기존-문제점">🔹 기존 문제점</a></li>
            <li><a href="#-해결-방안-multi-step--hybrid-reasoning">🔹 해결 방안: <strong>Multi-Step &amp; Hybrid Reasoning</strong></a></li>
          </ul>
        </li>
        <li><a href="#2-명시적-메모리-검색-방식-개선"><strong>(2) 명시적 메모리 검색 방식 개선</strong></a>
          <ul>
            <li><a href="#-기존-문제점-1">🔹 기존 문제점</a></li>
            <li><a href="#-해결-방안-강화-학습-기반-검색-및-메모리-최적화">🔹 해결 방안: <strong>강화 학습 기반 검색 및 메모리 최적화</strong></a></li>
          </ul>
        </li>
        <li><a href="#3-추론-과정의-효율성-개선"><strong>(3) 추론 과정의 효율성 개선</strong></a>
          <ul>
            <li><a href="#-기존-문제점-2">🔹 기존 문제점</a></li>
            <li><a href="#-해결-방안-efficient-reasoning--model-pruning">🔹 해결 방안: <strong>Efficient Reasoning &amp; Model Pruning</strong></a></li>
          </ul>
        </li>
        <li><a href="#4-새로운-도메인으로-확장"><strong>(4) 새로운 도메인으로 확장</strong></a>
          <ul>
            <li><a href="#-기존-문제점-3">🔹 기존 문제점</a></li>
            <li><a href="#-해결-방안-commonsense--creativity-reasoning-적용">🔹 해결 방안: <strong>Commonsense &amp; Creativity Reasoning 적용</strong></a></li>
          </ul>
        </li>
        <li><a href="#5-llm의-한계-극복-및-더-강력한-모델과의-통합"><strong>(5) LLM의 한계 극복 및 더 강력한 모델과의 통합</strong></a>
          <ul>
            <li><a href="#-기존-문제점-4">🔹 기존 문제점</a></li>
            <li><a href="#-해결-방안-weak-to-strong-generalization--fine-tuning">🔹 해결 방안: <strong>Weak-to-Strong Generalization &amp; Fine-Tuning</strong></a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#결론-2"><strong>결론</strong></a></li>
  </ul>

  <ul>
    <li><a href="#메타-추론기의-확률-점수와-문제-해결-성능-간의-상관관계-분석"><strong>메타-추론기의 확률 점수와 문제 해결 성능 간의 상관관계 분석</strong></a>
      <ul>
        <li><a href="#1-메타-추론기meta-thinker의-역할"><strong>1. 메타-추론기(Meta-thinker)의 역할</strong></a></li>
        <li><a href="#2-확률-점수와-문제-해결-성능-간의-상관관계"><strong>2. 확률 점수와 문제 해결 성능 간의 상관관계</strong></a>
          <ul>
            <li><a href="#-논문의-실험-결과-분석">🔹 <strong>논문의 실험 결과 분석</strong></a></li>
            <li><a href="#-확률-점수와-정답률-간의-연관성">🔹 <strong>확률 점수와 정답률 간의 연관성</strong></a></li>
          </ul>
        </li>
        <li><a href="#3-메타-추론기의-예측-오류를-방지하기-위한-보완-기법"><strong>3. 메타-추론기의 예측 오류를 방지하기 위한 보완 기법</strong></a>
          <ul>
            <li><a href="#1-다중-추론-방식-적용-hybrid-reasoning"><strong>(1) 다중 추론 방식 적용 (Hybrid Reasoning)</strong></a></li>
            <li><a href="#2-메타-추론기-자체의-성능-향상-fine-tuning--self-training"><strong>(2) 메타-추론기 자체의 성능 향상 (Fine-Tuning &amp; Self-Training)</strong></a></li>
            <li><a href="#3-강화-학습-기반-추론-방식-선택-reinforcement-learning"><strong>(3) 강화 학습 기반 추론 방식 선택 (Reinforcement Learning)</strong></a></li>
            <li><a href="#4-과거-경험을-활용한-adaptive-memory-retrieval"><strong>(4) 과거 경험을 활용한 Adaptive Memory Retrieval</strong></a></li>
          </ul>
        </li>
        <li><a href="#4-결론-및-최적의-해결-방법"><strong>4. 결론 및 최적의 해결 방법</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#명시적-메모리explicit-memory-기반-유사-문제-검색-방식의-효과성-검증-및-향상-가능성"><strong>명시적 메모리(Explicit Memory) 기반 유사 문제 검색 방식의 효과성 검증 및 향상 가능성</strong></a>
      <ul>
        <li><a href="#1-논문에서-제시한-유사-문제-검색-방식"><strong>1. 논문에서 제시한 유사 문제 검색 방식</strong></a></li>
        <li><a href="#2-논문에서-이루어진-추가적인-실험-분석"><strong>2. 논문에서 이루어진 추가적인 실험 분석</strong></a>
          <ul>
            <li><a href="#-논문에서-제공된-일부-실험-결과"><strong>🔹 논문에서 제공된 일부 실험 결과</strong></a></li>
            <li><a href="#-추가적인-검증이-필요한-부분"><strong>🔹 추가적인 검증이 필요한 부분</strong></a></li>
          </ul>
        </li>
        <li><a href="#3-보다-정교한-검색-방법-적용-시-예상되는-성능-향상"><strong>3. 보다 정교한 검색 방법 적용 시 예상되는 성능 향상</strong></a>
          <ul>
            <li><a href="#-대체-가능한-검색-방법"><strong>🔹 대체 가능한 검색 방법</strong></a></li>
          </ul>
        </li>
        <li><a href="#4-성능-향상-예상-분석"><strong>4. 성능 향상 예상 분석</strong></a></li>
        <li><a href="#5-결론-3"><strong>5. 결론</strong></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#복합적-추론이-필요한-문제에서-typedthinker의-한계와-해결-방안"><strong>복합적 추론이 필요한 문제에서 TypedThinker의 한계와 해결 방안</strong></a>
      <ul>
        <li><a href="#1-typedthinker의-현재-추론-방식과-한계"><strong>1. TypedThinker의 현재 추론 방식과 한계</strong></a></li>
        <li><a href="#2-해결-방법-멀티스텝-추론-기법-적용"><strong>2. 해결 방법: 멀티스텝 추론 기법 적용</strong></a>
          <ul>
            <li><a href="#1-tree-of-thoughts-tot-적용"><strong>(1) Tree of Thoughts (ToT) 적용</strong></a></li>
            <li><a href="#2-graph-of-thoughts-got-적용"><strong>(2) Graph of Thoughts (GoT) 적용</strong></a></li>
          </ul>
        </li>
        <li><a href="#3-기존-성능-대비-예상-성능-향상-분석"><strong>3. 기존 성능 대비 예상 성능 향상 분석</strong></a></li>
        <li><a href="#4-결론-및-향후-개선-방향"><strong>4. 결론 및 향후 개선 방향</strong></a></li>
      </ul>
    </li>
  </ul>
</nav>
          </div>
      </nav>
    </div>

    
    <div class="border-border bg-muted/20 border-t px-4 py-3">
      <div class="text-muted-foreground text-center text-xs">
        <span>제목을 클릭하면 해당 위치로 이동합니다</span>
      </div>
    </div>
  </div>
</div>

    


  <link
    rel="stylesheet"
    href="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.css"
    integrity="sha384-5TcZemv2l/9On385z///+d7MSYlvIEw9FuZTIdZ14vJLqWphw7e7ZPuOiCHJcFCP"
    crossorigin="anonymous" />
  <script
    defer
    src="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.js"
    integrity="sha384-cMkvdD8LoxVzGF/RPUKAcvmm49FQ0oxwDF3BGKtDXcEc+T1b2N+teh/OJfpU0jr6"
    crossorigin="anonymous"></script>
  <script
    defer
    src="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/contrib/auto-render.min.js"
    integrity="sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh"
    crossorigin="anonymous"></script>

<script>
    
    function initKaTeX() {
        if (typeof renderMathInElement === 'undefined') {
            setTimeout(initKaTeX, 100);
            return;
        }

        var delimiters = [{"display":true,"left":"$$","right":"$$"},{"display":false,"left":"$","right":"$"}];

        renderMathInElement(document.body, {
            delimiters: delimiters,
            throwOnError: false,
            errorColor: '#cc0000',
            fleqn: false,
            leqno: false,
            trust: false
        });
    }

    
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initKaTeX);
    } else {
        initKaTeX();
    }
</script>
    



    
    
<div
  id="search-overlay"
  class="pointer-events-none fixed inset-0 z-40 bg-black/50 opacity-0 transition-opacity duration-300"></div>


<div
  id="search-modal"
  class="bg-card border-border pointer-events-none fixed top-1/2 left-1/2 z-50 max-h-[80vh] w-full max-w-2xl -translate-x-1/2 -translate-y-1/2 scale-95 transform overflow-hidden rounded-xl border opacity-0 shadow-xl transition-all duration-300">
  
  <div class="border-border flex items-center gap-3 border-b p-4">
    
    <div class="text-muted-foreground h-5 w-5 flex-shrink-0">
      
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="m21 21-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />

</svg>
    </div>

    
    <div class="relative flex-1">
      
      <button
        id="search-clear"
        class="text-muted-foreground hover:text-foreground hover:bg-muted/50 pointer-events-none absolute top-1/2 left-0 z-10 h-5 w-5 -translate-y-1/2 rounded opacity-0 transition-all duration-200"
        title="지우기"
        aria-label="지우기">
        
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />

</svg>
      </button>

      
      <input
        id="search-input"
        type="text"
        placeholder="게시글 검색..."
        class="text-foreground placeholder:text-muted-foreground w-full border-none bg-transparent pl-8 text-lg outline-none"
        autocomplete="off"
        spellcheck="false" />
    </div>

    
    <button
      id="search-close"
      class="text-muted-foreground hover:text-foreground hover:bg-muted/50 flex h-6 w-6 items-center justify-center rounded-md p-0.5 transition-all duration-200"
      title="닫기"
      aria-label="닫기">
      
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />

</svg>
    </button>
  </div>

  
  <div id="search-results" class="max-h-96 overflow-y-auto">
    
    <div
      id="search-empty"
      class="flex flex-col items-center justify-center py-12 text-center">
      <div
        class="bg-muted/50 mb-4 flex h-16 w-16 items-center justify-center rounded-full">
        
  <svg class="h-6 w-6"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="m21 21-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />

</svg>
      </div>
      <h3 class="text-foreground mb-2 text-lg font-semibold">
        검색 시작
      </h3>
      <p class="text-muted-foreground text-sm">
        검색어를 입력하세요
      </p>
    </div>

    
    <div
      id="search-loading"
      class="flex hidden items-center justify-center py-8">
      <div
        class="mr-3 h-6 w-6 animate-spin rounded-full border-2 border-current border-t-transparent"></div>
      <span class="text-muted-foreground"
        >검색 중...</span
      >
    </div>

    
    <div
      id="search-no-results"
      class="flex hidden flex-col items-center justify-center py-12 text-center">
      <div
        class="bg-muted/50 mb-4 flex h-16 w-16 items-center justify-center rounded-full">
        
  <svg class="h-6 w-6"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h7" />
</svg>
      </div>
      <h3 class="text-foreground mb-2 text-lg font-semibold">
        검색 결과 없음
      </h3>
      <p class="text-muted-foreground text-sm">
        다른 검색어로 시도해보세요
      </p>
    </div>

    
    <div id="search-results-list" class="hidden">
      
      <div
        id="search-stats"
        class="text-muted-foreground border-border border-b px-4 py-3 text-sm"
        data-template="%d개의 결과 찾음">
      </div>

      
      <div id="search-items" class="divide-border divide-y">
        
      </div>
    </div>
  </div>

  
  <div class="border-border bg-muted/20 border-t px-4 py-3">
    <div
      class="text-muted-foreground flex items-center justify-between text-xs">
      <div class="flex items-center gap-2 md:gap-4">
        <div class="flex items-center gap-1">
          <kbd
            class="bg-muted border-border rounded border px-1.5 py-0.5 text-xs"
            >↑↓</kbd
          >
          <span class="hidden sm:inline"
            >이동</span
          >
        </div>
        <div class="flex items-center gap-1">
          <kbd
            class="bg-muted border-border rounded border px-1.5 py-0.5 text-xs"
            >↵</kbd
          >
          <span class="hidden sm:inline"
            >선택</span
          >
        </div>
        <div class="flex items-center gap-1">
          <kbd
            class="bg-muted border-border rounded border px-1.5 py-0.5 text-xs"
            >ESC</kbd
          >
          <span class="hidden sm:inline"
            >닫기</span
          >
        </div>
      </div>
      <div class="search-hint-desktop flex items-center gap-1">
        <kbd class="bg-muted border-border rounded border px-1.5 py-0.5 text-xs"
          >⌘K</kbd
        >
        <span>단축키</span>
      </div>
    </div>
  </div>
</div>

  </body>
</html>
