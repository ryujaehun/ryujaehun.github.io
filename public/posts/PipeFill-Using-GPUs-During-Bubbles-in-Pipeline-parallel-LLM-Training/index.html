<!doctype html>
<html
  lang="ko-kr"
  data-theme="claude">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1314&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8" />
<meta
  name="viewport"
  content="width=device-width, initial-scale=1, shrink-to-fit=no" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />

<title>PipeFill: Using GPUs During Bubbles in Pipeline-parallel LLM Training | Jaehun&#39;s Blog</title>

<meta name="description" content="논문 링크
Q : 이 논문을 아주 자세하게 읽고 논문의 강점과 독창적인 지점을 설명해주고 핵심 알고리즘을 예시 입력을 들어서 전체적인 과정을 설명해줘 추가적으로 논문의 한계점에 대해서도 알려줘 논문『PipeFill: Using GPUs During Bubbles in..." />
<meta name="keywords" content="개발, 컴파일러, 프로그래밍, 에세이" />
<meta name="author" content="" />
<meta name="language" content="ko-kr" />

<meta name="robots" content="index, follow" />
<link rel="canonical" href="http://192.168.1.11:1314/posts/PipeFill-Using-GPUs-During-Bubbles-in-Pipeline-parallel-LLM-Training/" />



  <link rel="icon" type="image/svg+xml" href="/favicon.svg" />



<link rel="manifest" href="/site.webmanifest" />
<meta property="og:url" content="http://192.168.1.11:1314/posts/PipeFill-Using-GPUs-During-Bubbles-in-Pipeline-parallel-LLM-Training/">
  <meta property="og:site_name" content="Jaehun&#39;s Blog">
  <meta property="og:title" content="PipeFill: Using GPUs During Bubbles in Pipeline-parallel LLM Training">
  <meta property="og:description" content="논문 링크
Q : 이 논문을 아주 자세하게 읽고 논문의 강점과 독창적인 지점을 설명해주고 핵심 알고리즘을 예시 입력을 들어서 전체적인 과정을 설명해줘 추가적으로 논문의 한계점에 대해서도 알려줘 논문『PipeFill: Using GPUs During Bubbles in Pipeline-parallel LLM Training』의 핵심 내용을 상세히 분석하여, 논문의 강점, 독창적인 지점, 핵심 알고리즘의 전체적인 과정 및 한계점을 요약하였습니다.">
  <meta property="og:locale" content="ko_kr">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-03-25T00:00:00+00:00">
    <meta property="article:modified_time" content="2025-03-25T00:00:00+00:00">
    <meta property="og:image" content="http://192.168.1.11:1314/images/og-default.avif">


  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:image" content="http://192.168.1.11:1314/images/og-default.avif">
  <meta name="twitter:title" content="PipeFill: Using GPUs During Bubbles in Pipeline-parallel LLM Training">
  <meta name="twitter:description" content="논문 링크
Q : 이 논문을 아주 자세하게 읽고 논문의 강점과 독창적인 지점을 설명해주고 핵심 알고리즘을 예시 입력을 들어서 전체적인 과정을 설명해줘 추가적으로 논문의 한계점에 대해서도 알려줘 논문『PipeFill: Using GPUs During Bubbles in Pipeline-parallel LLM Training』의 핵심 내용을 상세히 분석하여, 논문의 강점, 독창적인 지점, 핵심 알고리즘의 전체적인 과정 및 한계점을 요약하였습니다.">


  <meta itemprop="name" content="PipeFill: Using GPUs During Bubbles in Pipeline-parallel LLM Training">
  <meta itemprop="description" content="논문 링크
Q : 이 논문을 아주 자세하게 읽고 논문의 강점과 독창적인 지점을 설명해주고 핵심 알고리즘을 예시 입력을 들어서 전체적인 과정을 설명해줘 추가적으로 논문의 한계점에 대해서도 알려줘 논문『PipeFill: Using GPUs During Bubbles in Pipeline-parallel LLM Training』의 핵심 내용을 상세히 분석하여, 논문의 강점, 독창적인 지점, 핵심 알고리즘의 전체적인 과정 및 한계점을 요약하였습니다.">
  <meta itemprop="datePublished" content="2025-03-25T00:00:00+00:00">
  <meta itemprop="dateModified" content="2025-03-25T00:00:00+00:00">
  <meta itemprop="wordCount" content="12254">
  <meta itemprop="image" content="http://192.168.1.11:1314/images/og-default.avif">
  <meta itemprop="keywords" content="Paper-Review,With-Gpt">







<script>
  window.HUGO_SEARCH_CONFIG = {
    searchIndexURL: "\"/index.json\""
  };
</script>


































<script>

  window.HUGO_GALLERY_CONFIG = {
    justified_gallery:  false ,
    lightbox:  false ,
    justified: "{}",
    lightbox_options: "{}"
  };
</script>




  
    <link rel="stylesheet" href="/css/compiled.css" />
  





  
    <link rel="stylesheet" href="/css/chroma.css" />
  












      <script src="/js/main.js"></script>



  <script src="/js/gumshoe.polyfills.min.js"></script>



        <script src="/js/toc.js" defer></script>



      <script src="/js/search.js" defer></script>



      <script src="/js/dock.js" defer></script>











  











    <script>
      
      (function() {
        const theme = localStorage.getItem('theme') || 'system';
        const colorScheme = localStorage.getItem('colorScheme') || 'claude';

        
        document.documentElement.setAttribute('data-theme', colorScheme);

        
        function applyTheme() {
          if (theme === 'dark' || (theme === 'system' && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
            document.documentElement.classList.add('dark');
          } else {
            document.documentElement.classList.remove('dark');
          }
        }

        applyTheme();

        
        if (theme === 'system') {
          window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', applyTheme);
        }
      })();
    </script>
  </head>

  <body class="bg-background text-foreground min-h-screen antialiased">
    
    
  <div
    id="reading-progress-container"
    class="reading-progress-container pointer-events-none fixed top-0 right-0 left-0 z-50 transition-opacity duration-300 ease-out"
    data-height="3"
    data-smooth-scroll="true"
    data-hide-on-complete="false">
    
    <div class="reading-progress-bg w-full"></div>

    
    <div
      id="reading-progress-bar"
      class="from-primary to-primary/80 reading-progress-bar 
        transition-all duration-150 ease-out
       absolute top-0 left-0 w-0 bg-gradient-to-r"></div>
  </div>

  <script>
    (function () {
      "use strict";

      const progressContainer = document.getElementById(
        "reading-progress-container",
      );
      const progressBar = document.getElementById("reading-progress-bar");

      if (!progressContainer || !progressBar) return;

      
      const config = {
        smoothScroll: progressContainer.dataset.smoothScroll === "true",
        hideOnComplete: progressContainer.dataset.hideOnComplete === "true",
      };

      let isVisible = true;
      let gumshoeInstance = null;

      
      function calculateProgress() {
        const scrollTop =
          window.pageYOffset || document.documentElement.scrollTop;
        const documentHeight = document.documentElement.scrollHeight;
        const windowHeight = window.innerHeight;
        const scrollableHeight = documentHeight - windowHeight;

        if (scrollableHeight <= 0) return 0;

        return Math.min(Math.max((scrollTop / scrollableHeight) * 100, 0), 100);
      }

      
      function updateProgress() {
        const progress = calculateProgress();
        progressBar.style.width = progress + "%";

        
        if (config.hideOnComplete && progress >= 99.5) {
          if (isVisible) {
            progressContainer.style.opacity = "0";
            isVisible = false;
          }
        } else if (!isVisible) {
          progressContainer.style.opacity = "1";
          isVisible = true;
        }
      }

      
      let ticking = false;
      function requestTick() {
        if (!ticking) {
          requestAnimationFrame(() => {
            updateProgress();
            ticking = false;
          });
          ticking = true;
        }
      }

      
      function init() {
        
        window.addEventListener("scroll", requestTick, { passive: true });
        window.addEventListener("resize", requestTick, { passive: true });
        document.addEventListener("visibilitychange", () => {
          if (!document.hidden) requestTick();
        });

        
        requestTick();

        
        window.addEventListener("beforeunload", () => {
          window.removeEventListener("scroll", requestTick);
          window.removeEventListener("resize", requestTick);
        });
      }

      
      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", init);
      } else {
        init();
      }
    })();
  </script>

    <header class="sticky top-0 z-50 mx-auto max-w-4xl px-4 py-6">
  <div
    class="border-border bg-card/80 flex items-center rounded-xl border px-6 py-4 shadow-sm backdrop-blur-sm">
    
    <div class="hidden w-full items-center md:flex">
      
      <div class="flex items-center">
        
          
          <a
            href="/"
            class="bg-primary text-primary-foreground hover:bg-primary/90 flex h-10 w-10 items-center justify-center rounded-full text-lg font-bold transition-transform duration-200 hover:scale-105"
            aria-label="Jaehun&#39;s Blog">
            J
          </a>
        
      </div>

      
      <nav class="mx-8 flex flex-1 items-center justify-center">
        <div class="flex items-center space-x-1">
          
          
            
            
            
              
                
              
            
            
            <a
              href="/posts/"
              class="nav-link 
                text-muted-foreground hover:text-primary hover:bg-primary/10
               focus:ring-primary/20 relative flex items-center gap-2 rounded-lg px-4 py-2 text-sm font-medium transition-all duration-300 ease-out hover:-translate-y-0.5 hover:scale-105 focus:ring-2 focus:outline-none">
              
                
  <svg class="h-5 w-5"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="nav.posts">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 20H5a2 2 0 01-2-2V6a2 2 0 012-2h10a2 2 0 012 2v1m2 13a2 2 0 01-2-2V7m2 13a2 2 0 002-2V9a2 2 0 00-2-2h-2m-4-3H9M7 16h6M7 8h6v4H7V8z" />

</svg>
              
              <span
                >
                  게시글
                </span
              >
            </a>
          
            
            
            
              
                
              
            
            
            <a
              href="/categories/"
              class="nav-link 
                text-muted-foreground hover:text-primary hover:bg-primary/10
               focus:ring-primary/20 relative flex items-center gap-2 rounded-lg px-4 py-2 text-sm font-medium transition-all duration-300 ease-out hover:-translate-y-0.5 hover:scale-105 focus:ring-2 focus:outline-none">
              
                
  <svg class="h-5 w-5"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="nav.categories">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10" />

</svg>
              
              <span
                >
                  카테고리
                </span
              >
            </a>
          
            
            
            
              
                
              
            
            
            <a
              href="/tags/"
              class="nav-link 
                text-muted-foreground hover:text-primary hover:bg-primary/10
               focus:ring-primary/20 relative flex items-center gap-2 rounded-lg px-4 py-2 text-sm font-medium transition-all duration-300 ease-out hover:-translate-y-0.5 hover:scale-105 focus:ring-2 focus:outline-none">
              
                
  <svg class="h-5 w-5"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="nav.tags">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 7h.01M7 3h5c.512 0 1.024.195 1.414.586l7 7a2 2 0 010 2.828l-7 7a2 2 0 01-2.828 0l-7-7A1.994 1.994 0 013 12V7a4 4 0 014-4z" />

</svg>
              
              <span
                >
                  태그
                </span
              >
            </a>
          
            
            
            
              
                
              
            
            
            <a
              href="/archives/"
              class="nav-link 
                text-muted-foreground hover:text-primary hover:bg-primary/10
               focus:ring-primary/20 relative flex items-center gap-2 rounded-lg px-4 py-2 text-sm font-medium transition-all duration-300 ease-out hover:-translate-y-0.5 hover:scale-105 focus:ring-2 focus:outline-none">
              
                
  <svg class="h-5 w-5"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="nav.archives">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 8h14M5 8a2 2 0 110-4h14a2 2 0 110 4M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8m-9 4h4" />

</svg>
              
              <span
                >
                  아카이브
                </span
              >
            </a>
          
        </div>
      </nav>

      
      <div class="flex items-center space-x-2">
        
        
<div class="relative">
  <button id="language-toggle"
    class="dropdown-toggle border-border bg-background text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex h-10 w-10 items-center justify-center rounded-lg border transition-all duration-300 ease-out hover:scale-105 focus:ring-2 focus:outline-none active:scale-95"
    data-dropdown-type="language"
    aria-label="언어 변경"
    aria-expanded="false"
    aria-haspopup="true">
      
  <svg class="h-5 w-5 relative z-10"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="언어 변경">
	<path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="m5 8l6 6m-7 0l6-6l2-3M2 5h12M7 2h1m14 20l-5-10l-5 10m2-4h6" />
</svg></button>

  
  <div id="language-dropdown"
    class="dropdown-menu border-border bg-popover/95 absolute top-12 right-0 z-[60] hidden w-40 rounded-lg border p-1 shadow-lg backdrop-blur-sm transition-all duration-200 ease-out"
    data-dropdown-type="language"
    role="menu"
    aria-labelledby="language-toggle"><a href="/ko/" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none" role="menuitem" aria-current="true"><span class="font-medium">한국어</span></a><a href="/en/" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none" role="menuitem"><span class="font-medium">English</span></a></div>
</div>

        
        
<div class="relative">
  <button id="color-scheme-toggle"
    class="dropdown-toggle border-border bg-background text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex h-10 w-10 items-center justify-center rounded-lg border transition-all duration-300 ease-out hover:scale-105 focus:ring-2 focus:outline-none active:scale-95"
    data-dropdown-type="color-scheme"
    aria-label="테마 변경"
    aria-expanded="false"
    aria-haspopup="true">
      
  <svg class="h-5 w-5 relative z-10"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="테마 변경">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 21a4 4 0 01-4-4V5a2 2 0 012-2h4a2 2 0 012 2v12a4 4 0 01-4 4zM21 5a2 2 0 00-2-2h-4a2 2 0 00-2 2v6a2 2 0 002 2h4a2 2 0 002-2V5z" />

</svg></button>

  
  <div id="color-scheme-dropdown"
    class="dropdown-menu border-border bg-popover/95 absolute top-12 right-0 z-[60] hidden w-44 rounded-lg border p-1 shadow-lg backdrop-blur-sm transition-all duration-200 ease-out"
    data-dropdown-type="color-scheme"><button data-color-scheme="claude" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none"><span>Default</span></button><button data-color-scheme="default" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none"><span>White</span></button><button data-color-scheme="bumblebee" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none"><span>Bumblebee</span></button><button data-color-scheme="emerald" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none"><span>Emerald</span></button><button data-color-scheme="nord" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none"><span>Nord</span></button><button data-color-scheme="sunset" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none"><span>Sunset</span></button><button data-color-scheme="abyss" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none"><span>Abyss</span></button><button data-color-scheme="dracula" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none"><span>Dracula</span></button><button data-color-scheme="amethyst" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none"><span>Amethyst</span></button><button data-color-scheme="slate" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none"><span>Slate</span></button><button data-color-scheme="twitter" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none"><span>Twitter</span></button></div>
</div>

        
        
<div class="relative">
  <button id="theme-toggle"
    class="dropdown-toggle border-border bg-background text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex h-10 w-10 items-center justify-center rounded-lg border transition-all duration-300 ease-out hover:scale-105 focus:ring-2 focus:outline-none active:scale-95"
    data-dropdown-type="theme"
    aria-label="테마 변경"
    aria-expanded="false"
    aria-haspopup="true">
      
      
  <svg class="h-5 w-5 sun-icon hidden relative z-10"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="라이트">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" />

</svg>
      
      
  <svg class="h-5 w-5 moon-icon hidden relative z-10"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="다크">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" />

</svg>
      
      
  <svg class="h-5 w-5 system-icon hidden relative z-10"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="시스템">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.75 17L9 20l-1 1h8l-1-1-.75-3M3 13h18M5 17h14a2 2 0 002-2V5a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z" />

</svg></button>

  
  <div id="theme-dropdown"
    class="dropdown-menu border-border bg-popover/95 absolute top-12 right-0 z-[60] hidden w-40 rounded-lg border p-1 shadow-lg backdrop-blur-sm transition-all duration-200 ease-out"
    data-dropdown-type="theme"><button data-theme="light" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none">
  <svg class="h-5 w-5 mr-3 h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="라이트">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" />

</svg><span>라이트</span></button><button data-theme="dark" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none">
  <svg class="h-5 w-5 mr-3 h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="다크">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" />

</svg><span>다크</span></button><button data-theme="system" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none">
  <svg class="h-5 w-5 mr-3 h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="시스템">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.75 17L9 20l-1 1h8l-1-1-.75-3M3 13h18M5 17h14a2 2 0 002-2V5a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z" />

</svg><span>시스템</span></button></div>
</div>
      </div>
    </div>

    
    <div class="flex w-full items-center justify-between md:hidden">
      
      
<div class="relative">
  <button
    id="mobile-menu-toggle"
    class="dropdown-toggle border-border bg-background text-muted-foreground hover:bg-accent hover:text-foreground flex h-10 w-10 items-center justify-center rounded-lg border transition-colors duration-200"
    data-dropdown-type="mobile-menu"
    aria-label="메뉴"
    aria-expanded="false"
    aria-haspopup="true">
    
  <svg class="h-5 w-5"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="메뉴">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16" />

</svg>
  </button>

  
  <div
    id="mobile-menu"
    class="mobile-menu dropdown-menu border-border bg-popover/95 absolute top-12 left-0 z-[60] hidden w-80 max-w-[calc(100vw-2rem)] rounded-lg border p-1 shadow-lg backdrop-blur-sm transition-all duration-200 ease-out md:hidden"
    data-dropdown-type="mobile-menu"
    role="menu"
    aria-labelledby="mobile-menu-toggle">
    <nav class="flex flex-col">
      
      
        
        
        
          
            
          
        
        
        <a
          href="/posts/"
          class="nav-link 
            text-muted-foreground hover:text-primary hover:bg-primary/10
           focus:ring-primary/20 relative flex items-center gap-3 rounded-md px-4 py-3 text-sm font-medium transition-all duration-200 ease-out hover:translate-x-1 focus:ring-2 focus:outline-none"
          role="menuitem"
          >
          
            
  <svg class="h-5 w-5"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="nav.posts">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 20H5a2 2 0 01-2-2V6a2 2 0 012-2h10a2 2 0 012 2v1m2 13a2 2 0 01-2-2V7m2 13a2 2 0 002-2V9a2 2 0 00-2-2h-2m-4-3H9M7 16h6M7 8h6v4H7V8z" />

</svg>
          
          <span
            >
              게시글
            </span
          >
        </a>
      
        
        
        
          
            
          
        
        
        <a
          href="/categories/"
          class="nav-link 
            text-muted-foreground hover:text-primary hover:bg-primary/10
           focus:ring-primary/20 relative flex items-center gap-3 rounded-md px-4 py-3 text-sm font-medium transition-all duration-200 ease-out hover:translate-x-1 focus:ring-2 focus:outline-none"
          role="menuitem"
          >
          
            
  <svg class="h-5 w-5"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="nav.categories">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10" />

</svg>
          
          <span
            >
              카테고리
            </span
          >
        </a>
      
        
        
        
          
            
          
        
        
        <a
          href="/tags/"
          class="nav-link 
            text-muted-foreground hover:text-primary hover:bg-primary/10
           focus:ring-primary/20 relative flex items-center gap-3 rounded-md px-4 py-3 text-sm font-medium transition-all duration-200 ease-out hover:translate-x-1 focus:ring-2 focus:outline-none"
          role="menuitem"
          >
          
            
  <svg class="h-5 w-5"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="nav.tags">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 7h.01M7 3h5c.512 0 1.024.195 1.414.586l7 7a2 2 0 010 2.828l-7 7a2 2 0 01-2.828 0l-7-7A1.994 1.994 0 013 12V7a4 4 0 014-4z" />

</svg>
          
          <span
            >
              태그
            </span
          >
        </a>
      
        
        
        
          
            
          
        
        
        <a
          href="/archives/"
          class="nav-link 
            text-muted-foreground hover:text-primary hover:bg-primary/10
           focus:ring-primary/20 relative flex items-center gap-3 rounded-md px-4 py-3 text-sm font-medium transition-all duration-200 ease-out hover:translate-x-1 focus:ring-2 focus:outline-none"
          role="menuitem"
          >
          
            
  <svg class="h-5 w-5"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="nav.archives">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 8h14M5 8a2 2 0 110-4h14a2 2 0 110 4M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8m-9 4h4" />

</svg>
          
          <span
            >
              아카이브
            </span
          >
        </a>
      
    </nav>
  </div>
</div>


      
      <div class="flex items-center space-x-2">
        
        
<div class="relative">
  <button id="language-toggle"
    class="dropdown-toggle border-border bg-background text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex h-10 w-10 items-center justify-center rounded-lg border transition-all duration-300 ease-out hover:scale-105 focus:ring-2 focus:outline-none active:scale-95"
    data-dropdown-type="language"
    aria-label="언어 변경"
    aria-expanded="false"
    aria-haspopup="true">
      
  <svg class="h-5 w-5 relative z-10"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="언어 변경">
	<path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="m5 8l6 6m-7 0l6-6l2-3M2 5h12M7 2h1m14 20l-5-10l-5 10m2-4h6" />
</svg></button>

  
  <div id="language-dropdown"
    class="dropdown-menu border-border bg-popover/95 absolute top-12 right-0 z-[60] hidden w-40 rounded-lg border p-1 shadow-lg backdrop-blur-sm transition-all duration-200 ease-out"
    data-dropdown-type="language"
    role="menu"
    aria-labelledby="language-toggle"><a href="/ko/" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none" role="menuitem" aria-current="true"><span class="font-medium">한국어</span></a><a href="/en/" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none" role="menuitem"><span class="font-medium">English</span></a></div>
</div>

        
        
<div class="relative">
  <button id="color-scheme-toggle"
    class="dropdown-toggle border-border bg-background text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex h-10 w-10 items-center justify-center rounded-lg border transition-all duration-300 ease-out hover:scale-105 focus:ring-2 focus:outline-none active:scale-95"
    data-dropdown-type="color-scheme"
    aria-label="테마 변경"
    aria-expanded="false"
    aria-haspopup="true">
      
  <svg class="h-5 w-5 relative z-10"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="테마 변경">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 21a4 4 0 01-4-4V5a2 2 0 012-2h4a2 2 0 012 2v12a4 4 0 01-4 4zM21 5a2 2 0 00-2-2h-4a2 2 0 00-2 2v6a2 2 0 002 2h4a2 2 0 002-2V5z" />

</svg></button>

  
  <div id="color-scheme-dropdown"
    class="dropdown-menu border-border bg-popover/95 absolute top-12 right-0 z-[60] hidden w-44 rounded-lg border p-1 shadow-lg backdrop-blur-sm transition-all duration-200 ease-out"
    data-dropdown-type="color-scheme"><button data-color-scheme="claude" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none"><span>Default</span></button><button data-color-scheme="default" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none"><span>White</span></button><button data-color-scheme="bumblebee" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none"><span>Bumblebee</span></button><button data-color-scheme="emerald" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none"><span>Emerald</span></button><button data-color-scheme="nord" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none"><span>Nord</span></button><button data-color-scheme="sunset" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none"><span>Sunset</span></button><button data-color-scheme="abyss" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none"><span>Abyss</span></button><button data-color-scheme="dracula" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none"><span>Dracula</span></button><button data-color-scheme="amethyst" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none"><span>Amethyst</span></button><button data-color-scheme="slate" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none"><span>Slate</span></button><button data-color-scheme="twitter" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none"><span>Twitter</span></button></div>
</div>

        
        
<div class="relative">
  <button id="theme-toggle"
    class="dropdown-toggle border-border bg-background text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex h-10 w-10 items-center justify-center rounded-lg border transition-all duration-300 ease-out hover:scale-105 focus:ring-2 focus:outline-none active:scale-95"
    data-dropdown-type="theme"
    aria-label="테마 변경"
    aria-expanded="false"
    aria-haspopup="true">
      
      
  <svg class="h-5 w-5 sun-icon hidden relative z-10"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="라이트">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" />

</svg>
      
      
  <svg class="h-5 w-5 moon-icon hidden relative z-10"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="다크">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" />

</svg>
      
      
  <svg class="h-5 w-5 system-icon hidden relative z-10"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="시스템">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.75 17L9 20l-1 1h8l-1-1-.75-3M3 13h18M5 17h14a2 2 0 002-2V5a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z" />

</svg></button>

  
  <div id="theme-dropdown"
    class="dropdown-menu border-border bg-popover/95 absolute top-12 right-0 z-[60] hidden w-40 rounded-lg border p-1 shadow-lg backdrop-blur-sm transition-all duration-200 ease-out"
    data-dropdown-type="theme"><button data-theme="light" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none">
  <svg class="h-5 w-5 mr-3 h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="라이트">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" />

</svg><span>라이트</span></button><button data-theme="dark" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none">
  <svg class="h-5 w-5 mr-3 h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="다크">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" />

</svg><span>다크</span></button><button data-theme="system" class="text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground flex w-full items-center rounded-md px-4 py-2 text-sm transition-all duration-200 ease-out focus:outline-none">
  <svg class="h-5 w-5 mr-3 h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="시스템">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.75 17L9 20l-1 1h8l-1-1-.75-3M3 13h18M5 17h14a2 2 0 002-2V5a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z" />

</svg><span>시스템</span></button></div>
</div>
      </div>
    </div>
  </div>
</header>


    <main class="mx-auto max-w-4xl px-4 py-6">
      
  
  <nav
  class="breadcrumb mb-4 md:mb-6 py-1"
  aria-label="경로">
  <ol class="text-muted-foreground flex items-center space-x-1 md:space-x-2 text-sm overflow-x-auto whitespace-nowrap scrollbar-hide py-1">
    
    <li class="flex-shrink-0">
      <a
        href="/"
        class="text-muted-foreground hover:text-primary hover:bg-primary/10 flex items-center gap-0.5 md:gap-1 rounded-lg px-1 md:px-3 py-0.5 md:py-1.5 transition-all duration-200 ease-out hover:-translate-y-0.5 hover:scale-[1.02]">
        
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="홈">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="m3 12 2-2m0 0 7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6" />

</svg>
        <span class="max-w-[4rem] md:max-w-none truncate">홈</span>
      </a>
    </li>

    
    
      <li class="flex items-center gap-1 md:gap-2 min-w-0">
        <span class="text-muted-foreground/50 flex-shrink-0"
          >
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
</svg>
        </span>

        
          
          <div class="flex items-center gap-1 md:gap-2 min-w-0">
            
              
              <a
                href="/posts"
                class="text-muted-foreground hover:text-primary hover:bg-primary/10 flex items-center gap-0.5 md:gap-1 rounded-lg px-1 md:px-3 py-0.5 md:py-1.5 transition-all duration-200 ease-out hover:-translate-y-0.5 hover:scale-[1.02] flex-shrink-0">
                
                  
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 20H5a2 2 0 01-2-2V6a2 2 0 012-2h10a2 2 0 012 2v1m2 13a2 2 0 01-2-2V7m2 13a2 2 0 002-2V9a2 2 0 00-2-2h-2m-4-3H9M7 16h6M7 8h6v4H7V8z" />

</svg>
                  <span class="max-w-[3rem] md:max-w-none truncate">게시글</span>
                
              </a>
              <span class="text-muted-foreground/50 flex-shrink-0"
                >
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
</svg></span
              >
            
            
            <span class="text-foreground flex items-center gap-0.5 md:gap-1 font-medium min-w-0">
              
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
</svg>
              <span class="max-w-[8rem] md:max-w-[16rem] lg:max-w-none truncate">PipeFill: Using GPUs During Bubbles in Pipeline-parallel LLM Training</span>
            </span>
          </div>
        
      </li>
    

  </ol>
</nav>



  


  
  <header class="mb-8">
    


<div class="post-meta">
  
  <h1 class="text-foreground mb-6 text-3xl leading-tight font-bold md:text-4xl">
    PipeFill: Using GPUs During Bubbles in Pipeline-parallel LLM Training
  </h1>

  
  


  
  <div class="bg-card border-border flex flex-col gap-4 rounded-xl border p-6">
    
    <div
      class="text-muted-foreground flex flex-wrap items-center gap-4 text-sm">
      
      <div class="flex items-center gap-2">
        
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="작성일"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z" />
</svg>
        <time datetime="2025-03-25">
          2025년 03월 25일
        </time>
      </div>

      
      


      
      
        <div class="flex items-center gap-2">
          
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="읽는 시간"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
</svg>
          <span
            >25 분</span
          >
        </div>
      


      
      
        <div class="flex items-center gap-2">
          
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="단어 수"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h7" />
</svg>
          <span>12254 단어</span>
        </div>
      

    </div>

    
    
      <div class="flex flex-wrap items-center gap-4">
        
        
          <div class="flex items-center gap-2">
            
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="카테고리"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 7v10a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-6l-2-2H5a2 2 0 00-2 2z" />
</svg>
            <span class="text-muted-foreground mr-2 text-sm"
              >카테고리:</span
            >
            <div class="flex flex-wrap gap-2">
              
                <a
                  href="/categories/paper-review/"
                  class="bg-primary/10 text-primary hover:bg-primary/20 focus:ring-primary/20 inline-flex items-center rounded-full px-3 py-1 text-sm font-medium transition-all duration-200 ease-out hover:-translate-y-0.5 hover:scale-105 hover:shadow-md focus:ring-2 focus:outline-none">
                  paper-review
                </a>
              
                <a
                  href="/categories/with-gpt/"
                  class="bg-primary/10 text-primary hover:bg-primary/20 focus:ring-primary/20 inline-flex items-center rounded-full px-3 py-1 text-sm font-medium transition-all duration-200 ease-out hover:-translate-y-0.5 hover:scale-105 hover:shadow-md focus:ring-2 focus:outline-none">
                  with-gpt
                </a>
              
            </div>
          </div>
        


        
        

      </div>
    


    
    

  </div>
</div>

  </header>

  
  <article class="prose prose-neutral dark:prose-invert mb-12 max-w-none">
    <p><a href="https://arxiv.org/abs/2410.07192">논문 링크</a></p>
<h1 id="q--이-논문을-아주-자세하게-읽고-논문의-강점과-독창적인-지점을-설명해주고-핵심-알고리즘을-예시-입력을-들어서-전체적인-과정을-설명해줘-추가적으로-논문의-한계점에-대해서도-알려줘">Q : 이 논문을 아주 자세하게 읽고 논문의 강점과 독창적인 지점을 설명해주고 핵심 알고리즘을 예시 입력을 들어서 전체적인 과정을 설명해줘 추가적으로 논문의 한계점에 대해서도 알려줘</h1>
<p>논문『PipeFill: Using GPUs During Bubbles in Pipeline-parallel LLM Training』의 핵심 내용을 상세히 분석하여, 논문의 강점, 독창적인 지점, 핵심 알고리즘의 전체적인 과정 및 한계점을 요약하였습니다.</p>
<hr>
<h2 id="-결론-요약">📌 결론 (요약)</h2>
<p>『PipeFill』은 파이프라인 병렬 처리 과정에서 GPU의 유휴 시간(버블)을 독립적인 다른 작업(fill job)을 수행함으로써 메워서 GPU 사용률을 최대 <strong>63% 향상</strong>시키며, 주 작업(LLM 학습)의 성능 저하는 <strong>2% 이하</strong>로 매우 적은 수준입니다. 특히 큰 규모(8,000 GPU 이상)의 모델 훈련에서 탁월한 효율성 향상을 보였습니다.</p>
<hr>
<h2 id="-논문의-강점과-독창적인-지점">🚀 논문의 강점과 독창적인 지점</h2>
<h3 id="강점">강점</h3>
<ul>
<li><strong>GPU 자원 효율성 극대화</strong>: 일반적으로 파이프라인 병렬 처리는 GPU idle time(버블)이 전체 작업 시간의 15~60% 차지하여 비효율성이 높았는데, 이 시간에 다른 작업을 수행하여 GPU의 사용률을 크게 높였습니다.</li>
<li><strong>낮은 오버헤드로 효율성 확보</strong>: LLM 학습 속도를 거의 저하하지 않으면서(2% 미만) 추가 GPU 자원을 활용하여 비용 절감 효과를 얻었습니다.</li>
<li><strong>유연성 있는 Job Scheduling</strong>: 사용자가 원하는 우선순위에 따라 fill job을 자유롭게 배정할 수 있는 커스터마이징 가능한 scheduler를 제공합니다.</li>
</ul>
<h3 id="독창성">독창성</h3>
<ul>
<li>파이프라인 버블을 독립된 추가적인 작업으로 채운 최초의 방법으로, 기존 방식이 의존적인 job만을 처리한 반면 본 논문은 완전히 독립적인 별개의 작업을 유휴 시간에 처리할 수 있게 만들었습니다.</li>
<li>기존 GPU 자원 공유 기술은 주 작업 성능 저하가 컸으나, PipeFill은 pipeline bubble의 특성을 정확히 파악하여 주 작업 성능에 미치는 영향을 최소화하는 구조적 설계를 했습니다.</li>
</ul>
<hr>
<h2 id="-핵심-알고리즘-프로세스-예시를-포함한-설명">📗 핵심 알고리즘 프로세스 (예시를 포함한 설명)</h2>
<p>PipeFill의 핵심 알고리즘은 크게 3가지 요소로 구성됩니다.</p>
<h3 id="-pipeline-bubble-instrumentation">① Pipeline Bubble Instrumentation</h3>
<ul>
<li>기존 pipeline-parallel 학습 알고리즘 (예: GPipe, 1F1B)에 명시적으로 버블을 식별하고, 시간 및 메모리 가용성을 측정하는 명령어를 추가하여 실제 버블 크기를 계측합니다.</li>
</ul>
<h3 id="-fill-job-execution-algorithm-실행-계획">② Fill Job Execution Algorithm (실행 계획)</h3>
<ul>
<li>측정된 버블 정보를 기반으로 fill job을 GPU 메모리 및 버블 시간 내에서 처리할 수 있게 분할(partition)하는 Greedy 알고리즘을 실행합니다.</li>
<li>작업을 가능한 한 GPU 메모리와 시간 제약 내에서 잘게 쪼개서 pipeline bubble 사이에 삽입합니다.</li>
</ul>
<h3 id="-fill-job-scheduling">③ Fill Job Scheduling</h3>
<ul>
<li>사용자 정의 가능한 스케줄링 정책(SJF, Makespan Minimizing 등)을 통해 job이 최적으로 처리될 수 있도록 제어합니다.</li>
</ul>
<p><strong>예시 입력 및 전체 과정 (예시)</strong></p>

  <blockquote
    class="border-primary bg-muted/30 hover:bg-muted/40 my-6 rounded-r-lg border-l-4 py-4 pr-4 pl-6 italic transition-all duration-200 ease-out hover:translate-x-1">
    <div class="prose prose-sm max-w-none">
      <ul>
<li><strong>Main Job</strong>: 16개 GPU를 사용하여 16단계 pipeline-parallel LLM 훈련 (microbatch=2, minibatch=1024)</li>
<li><strong>측정된 버블 정보</strong>:
<ul>
<li>Bubble Duration: GPU당 평균 약 100ms</li>
<li>사용 가능한 GPU 메모리: 약 4.5GB</li>
</ul>
</li>
<li><strong>Fill Job</strong>: BERT-large 모델의 batch inference job</li>
</ul>
<p><strong>알고리즘 프로세스</strong>:</p>
<ol>
<li>버블 기간(100ms) 동안 BERT-large 모델을 GPU 메모리(4.5GB)에 맞추어 실행 가능한 크기(예: batch size 8)로 쪼갬</li>
<li>실행 가능한 각 작은 단위를 pipeline bubble에 삽입하여 GPU idle time 동안 BERT-large 모델의 추론을 수행</li>
<li>주 작업(LLM training) 버블이 끝나기 전 자동으로 상태를 저장 및 복원하여 context switching 수행</li>
<li>버블이 종료될 때 fill job을 일시 중단하고 다시 주 작업으로 돌아감</li>
</ol>
<p>이 과정을 통해 추가적인 inference 작업을 GPU idle 시간에 처리하여 GPU utilization 증가 및 추가 작업 성과를 얻음.</p>
    </div>
  </blockquote>

<hr>
<h2 id="-실험-및-성능-비교-테이블로-요약">📊 실험 및 성능 비교 (테이블로 요약)</h2>
<table>
  <thead>
      <tr>
          <th>GPU 개수</th>
          <th>전통적 PP 방식 GPU 활용률</th>
          <th>PipeFill 적용 시 GPU 활용률</th>
          <th>PipeFill 활용률 증가폭</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>1K</td>
          <td>약 46.8 TFLOPS</td>
          <td>약 51 TFLOPS</td>
          <td>+9%</td>
      </tr>
      <tr>
          <td>4K</td>
          <td>약 22.7 TFLOPS</td>
          <td>약 33 TFLOPS</td>
          <td>+45%</td>
      </tr>
      <tr>
          <td>8K</td>
          <td>약 17.8 TFLOPS</td>
          <td>약 29 TFLOPS</td>
          <td>+63%</td>
      </tr>
  </tbody>
</table>
<hr>
<h2 id="-논문의-한계점-및-개선-가능성">🔻 논문의 한계점 및 개선 가능성</h2>
<h3 id="-context-switching-overhead-존재">① Context Switching Overhead 존재</h3>
<ul>
<li>버블이 짧을 경우 context switching 비용이 상대적으로 높아지므로 버블의 길이가 짧아지면 GPU 효율이 떨어질 수 있습니다.</li>
</ul>
<h3 id="-memory-제한-문제">② Memory 제한 문제</h3>
<ul>
<li>주 작업이 매우 큰 메모리를 사용할 경우 fill job 수행이 제한될 수 있어 작은 메모리로는 고효율의 fill job 처리가 어렵습니다. 메모리 오프로딩 등의 방식으로 완화했지만, 여전히 메모리가 주요 병목입니다.</li>
</ul>
<h3 id="-실시간-작업-처리-한계">③ 실시간 작업 처리 한계</h3>
<ul>
<li>버블 기간이 일정하지 않아 실시간성이 강하게 요구되는 inference 작업은 처리가 어려워 batch inference 또는 training 위주로 제한되는 단점이 있습니다.</li>
</ul>
<hr>
<h2 id="-요약-및-최종-평가">🎯 요약 및 최종 평가</h2>
<p>PipeFill은 LLM과 같은 초거대 모델의 병렬 훈련 과정에서 발생하는 GPU 자원의 낭비(버블)를 효과적으로 활용하는 혁신적인 방법으로, 큰 규모에서 뛰어난 GPU 효율 개선을 보여줍니다. 그러나 짧은 버블 처리의 비효율성, 메모리 한계 등의 문제는 향후 연구를 통해 추가적으로 해결해야 할 과제로 남아 있습니다.</p>
<h1 id="q--논문의-핵심알고리즘을-예시를-들어-아주-자세하게-설명해주고-정리해-줘">Q : 논문의 핵심알고리즘을 예시를 들어 아주 자세하게 설명해주고 정리해 줘</h1>
<p>논문의 핵심 알고리즘을 예시를 들어 <strong>아주 구체적으로</strong> 설명하고 단계별로 명확히 정리하겠습니다.</p>
<hr>
<h1 id="pipefill의-핵심-알고리즘-개요">🎯『PipeFill』의 핵심 알고리즘 개요</h1>
<p>『PipeFill』의 핵심 아이디어는 <strong>파이프라인 병렬 훈련 시 발생하는 GPU Idle 시간(파이프라인 버블)에 독립적인 추가 작업(Fill job)을 투입하여 GPU 자원을 최대한 활용하는 것</strong>입니다.</p>
<p>이 알고리즘의 수행은 다음 3가지 주요 구성요소로 이루어져 있습니다:</p>
<ol>
<li><strong>Pipeline Bubble Instrumentation (버블 계측)</strong></li>
<li><strong>Fill Job Execution Plan (작업 실행 계획 수립)</strong></li>
<li><strong>Fill Job Scheduling (작업 스케줄링)</strong></li>
</ol>
<hr>
<h1 id="-알고리즘-예시-및-세부-단계-설명">📌 <strong>알고리즘 예시 및 세부 단계 설명</strong></h1>
<p>이제 실제 예시 입력을 통해 각 단계를 상세히 설명하겠습니다.</p>
<h3 id="-예시-입력">🔸 예시 입력:</h3>
<ul>
<li><strong>Main job</strong>:
<ul>
<li>LLM (40B 파라미터) 모델</li>
<li>GPU 8,000개 사용</li>
<li>파이프라인 병렬 구성 (16단계 파이프라인)</li>
<li>Microbatch = 2, Minibatch = 1024</li>
</ul>
</li>
<li><strong>측정된 버블 정보</strong> (실험기반 가상값):
<ul>
<li>GPU 버블 기간 평균: <strong>100 ms</strong></li>
<li>GPU 메모리 가용량: <strong>4.5 GB</strong></li>
</ul>
</li>
<li><strong>Fill job</strong>:
<ul>
<li>BERT-Large 모델 (334M 파라미터)</li>
<li>Batch Inference 작업 (GPU 메모리 요구량: batch size 8 기준 약 4GB)</li>
<li>독립된 추가 작업으로, pipeline 버블에 수행 예정</li>
</ul>
</li>
</ul>
<hr>
<h2 id="-step-1--pipeline-bubble-instrumentation-버블-계측">🚩 <strong>STEP 1 : Pipeline Bubble Instrumentation (버블 계측)</strong></h2>
<h3 id="목적">목적:</h3>
<p>파이프라인 병렬 알고리즘에서 pipeline bubble(유휴시간)의 정확한 길이와 메모리 가용량을 계측하기 위해 파이프라인 엔진을 수정하여 명령어를 추가합니다.</p>
<h3 id="예시를-통한-수행-과정">예시를 통한 수행 과정:</h3>
<ul>
<li>기존 파이프라인 스케줄링 (예: GPipe 알고리즘)
<div
  class="code-block-container border-border bg-card my-6 overflow-hidden rounded-xl border shadow-sm transition-all duration-200 ease-out hover:-translate-y-0.5 hover:shadow-md">
  
  <div
    class="code-block-header bg-muted/30 border-border flex items-center justify-between border-b px-4 py-3">
    
    <div class="flex items-center gap-2">
      <div class="text-muted-foreground flex-shrink-0">
        
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4" />
</svg>
      </div>
      <span class="text-muted-foreground text-sm font-medium">
        PLAINTEXT
      </span>
    </div>

    
    <div class="flex items-center gap-2">
      <button
          class="collapse-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
          data-code-id="code-0"
          data-default-state="expanded"
          data-collapsed="false"
          data-auto-collapse-lines="30"
          data-auto-collapse-height="400"
          data-collapsed-height="120"
          title="접기"
          aria-label="접기">
          <span class="collapse-icon">
            
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path fill="currentColor" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z"/></svg>
          </span>
          <span class="collapse-text hidden sm:inline"
            >접기</span
          >
        </button>
      <button
        class="copy-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
        data-code-id="code-0"
        title="복사"
        aria-label="복사">
        <span class="copy-icon">
          
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
</svg>
        </span>
        <span class="copy-text hidden sm:inline"
          >복사</span
        >
      </button>
    </div>
  </div>

  
  <div class="code-block-content relative" id="code-0">
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">[Forward → Forward → Forward → Bubble → Backward → Backward → Bubble]</span></span></code></pre></div>
    
    <div
      class="collapse-overlay to-card/90 pointer-events-none absolute inset-0 bg-gradient-to-b from-transparent via-transparent opacity-0 transition-opacity duration-300">
      <div
        class="text-muted-foreground bg-card/80 border-border/50 hover:bg-primary/10 hover:text-primary hover:border-primary/30 absolute bottom-4 left-1/2 -translate-x-1/2 cursor-pointer rounded-full border px-3 py-1.5 text-xs backdrop-blur-sm transition-all duration-200">
        클릭하여 더 보기
      </div>
    </div>
  </div>
</div>


<script>
(function() {
  const codeId = 'code-0';
  const copyBtn = document.querySelector('.copy-code-btn[data-code-id="' + codeId + '"]');
  const collapseBtn = document.querySelector('.collapse-code-btn[data-code-id="' + codeId + '"]');
  const codeContainer = document.getElementById(codeId);

  if (!codeContainer) return;

  
  if (copyBtn) {
    const copyIcon = copyBtn.querySelector('.copy-icon');
    const copyText = copyBtn.querySelector('.copy-text');

    copyBtn.addEventListener('click', async function() {
      try {
        
        let codeText = '';

        
        const codeTableCell = codeContainer.querySelector('.lntd:last-child code');
        if (codeTableCell) {
          codeText = codeTableCell.textContent || codeTableCell.innerText;
        } else {
          
          const codeElement = codeContainer.querySelector('code');
          if (codeElement) {
            
            const hasInlineLineNumbers = codeElement.querySelector('.ln');
            if (hasInlineLineNumbers) {
              
              const codeLines = codeElement.querySelectorAll('.cl');
              if (codeLines.length > 0) {
                codeText = Array.from(codeLines)
                  .map(line => {
                    const text = line.textContent || line.innerText;
                    
                    return text.replace(/\n+$/, '');
                  })
                  .join('\n')
                  .replace(/\n+$/, ''); 
              } else {
                
                const allText = codeElement.textContent || codeElement.innerText;
                codeText = allText.replace(/^\d+/gm, '').replace(/^\s+/gm, '');
              }
            } else {
              
              codeText = codeElement.textContent || codeElement.innerText;
            }
          } else {
            
            codeText = codeContainer.textContent || codeContainer.innerText;
          }
        }

        
        codeText = codeText.trim();

        
        await navigator.clipboard.writeText(codeText);

        
        copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M5 13l4 4L19 7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (copyText) {
          copyText.textContent = '복사됨';
        }
        copyBtn.classList.add('text-green-600');

        
        setTimeout(() => {
          copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z\u0022 \/\u003e\n\u003c\/svg\u003e`;
          if (copyText) {
            copyText.textContent = '복사';
          }
          copyBtn.classList.remove('text-green-600');
        }, 2000);

      } catch (err) {
        console.error('复制失败:', err);

        
        const range = document.createRange();
        const codeElement = codeContainer.querySelector('code') || codeContainer;
        range.selectNodeContents(codeElement);
        const selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);

        
        if (copyText) {
          copyText.textContent = '선택됨';
        }

        setTimeout(() => {
          if (copyText) {
            copyText.textContent = '복사';
          }
          selection.removeAllRanges();
        }, 2000);
      }
    });
  }

  
  if (collapseBtn) {
    const collapseIcon = collapseBtn.querySelector('.collapse-icon');
    const collapseText = collapseBtn.querySelector('.collapse-text');
    const collapseOverlay = codeContainer.querySelector('.collapse-overlay');

    
    let codeElement = codeContainer.querySelector('pre.chroma');
    if (!codeElement) {
      codeElement = codeContainer.querySelector('pre');
    }

    const defaultState = collapseBtn.dataset.defaultState || 'expanded';
    const isCollapsedAttr = collapseBtn.dataset.collapsed === 'true';
    const autoCollapseLines = parseInt(collapseBtn.dataset.autoCollapseLines) || 30;
    const autoCollapseHeight = parseInt(collapseBtn.dataset.autoCollapseHeight) || 400;
    const collapsedHeight = parseInt(collapseBtn.dataset.collapsedHeight) || 120;

    let isCollapsed = false;

    
    function initCollapse() {
      
      const shouldCollapse = isCollapsedAttr ||
                           defaultState === 'collapsed' ||
                           shouldAutoCollapse();

      if (shouldCollapse) {
        setCollapsed(true, false); 
      }
    }

    function shouldAutoCollapse() {
      
      if (codeElement) {
        const lines = codeElement.querySelectorAll('.line, .cl');
        const height = codeElement.offsetHeight;
        return lines.length > autoCollapseLines || height > autoCollapseHeight;
      }

      
      const containerHeight = codeContainer.offsetHeight;
      if (containerHeight > autoCollapseHeight) {
        return true;
      }

      
      const textContent = codeContainer.textContent || codeContainer.innerText || '';
      const estimatedLines = textContent.split('\n').length;
      return estimatedLines > autoCollapseLines;
    }

    function setCollapsed(collapsed, animate = true) {
      if (!collapseOverlay) return;

      isCollapsed = collapsed;

      if (collapsed) {
        
        codeContainer.style.maxHeight = collapsedHeight + 'px';
        codeContainer.style.overflow = 'hidden';
        collapseOverlay.style.opacity = '1';
        collapseOverlay.style.pointerEvents = 'auto';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M19 9l-7 7-7-7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '펼치기';
        }
        collapseBtn.title = '펼치기';

      } else {
        
        codeContainer.style.maxHeight = '';
        codeContainer.style.overflow = '';
        collapseOverlay.style.opacity = '0';
        collapseOverlay.style.pointerEvents = 'none';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath fill=\u0022currentColor\u0022 d=\u0022M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z\u0022\/\u003e\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '접기';
        }
        collapseBtn.title = '접기';
      }

      
      if (animate) {
        codeContainer.style.transition = 'max-height 0.3s ease-out';
        setTimeout(() => {
          codeContainer.style.transition = '';
        }, 300);
      }
    }

    function toggleCollapse() {
      setCollapsed(!isCollapsed, true);
    }

    
    collapseBtn.addEventListener('click', toggleCollapse);

    
    if (collapseOverlay) {
      collapseOverlay.addEventListener('click', () => {
        if (isCollapsed) {
          setCollapsed(false, true);
        }
      });
    }

    
    initCollapse();
  }
})();
</script>
</li>
<li>계측 단계에서는 <code>bubble 명령어</code>를 추가:
<div
  class="code-block-container border-border bg-card my-6 overflow-hidden rounded-xl border shadow-sm transition-all duration-200 ease-out hover:-translate-y-0.5 hover:shadow-md">
  
  <div
    class="code-block-header bg-muted/30 border-border flex items-center justify-between border-b px-4 py-3">
    
    <div class="flex items-center gap-2">
      <div class="text-muted-foreground flex-shrink-0">
        
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4" />
</svg>
      </div>
      <span class="text-muted-foreground text-sm font-medium">
        PSEUDO
      </span>
    </div>

    
    <div class="flex items-center gap-2">
      <button
          class="collapse-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
          data-code-id="code-1"
          data-default-state="expanded"
          data-collapsed="false"
          data-auto-collapse-lines="30"
          data-auto-collapse-height="400"
          data-collapsed-height="120"
          title="접기"
          aria-label="접기">
          <span class="collapse-icon">
            
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path fill="currentColor" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z"/></svg>
          </span>
          <span class="collapse-text hidden sm:inline"
            >접기</span
          >
        </button>
      <button
        class="copy-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
        data-code-id="code-1"
        title="복사"
        aria-label="복사">
        <span class="copy-icon">
          
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
</svg>
        </span>
        <span class="copy-text hidden sm:inline"
          >복사</span
        >
      </button>
    </div>
  </div>

  
  <div class="code-block-content relative" id="code-1">
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">[Forward → Forward → Forward → [Bubble_start → 측정 → Bubble_end] → Backward → ...]</span></span></code></pre></div>
    
    <div
      class="collapse-overlay to-card/90 pointer-events-none absolute inset-0 bg-gradient-to-b from-transparent via-transparent opacity-0 transition-opacity duration-300">
      <div
        class="text-muted-foreground bg-card/80 border-border/50 hover:bg-primary/10 hover:text-primary hover:border-primary/30 absolute bottom-4 left-1/2 -translate-x-1/2 cursor-pointer rounded-full border px-3 py-1.5 text-xs backdrop-blur-sm transition-all duration-200">
        클릭하여 더 보기
      </div>
    </div>
  </div>
</div>


<script>
(function() {
  const codeId = 'code-1';
  const copyBtn = document.querySelector('.copy-code-btn[data-code-id="' + codeId + '"]');
  const collapseBtn = document.querySelector('.collapse-code-btn[data-code-id="' + codeId + '"]');
  const codeContainer = document.getElementById(codeId);

  if (!codeContainer) return;

  
  if (copyBtn) {
    const copyIcon = copyBtn.querySelector('.copy-icon');
    const copyText = copyBtn.querySelector('.copy-text');

    copyBtn.addEventListener('click', async function() {
      try {
        
        let codeText = '';

        
        const codeTableCell = codeContainer.querySelector('.lntd:last-child code');
        if (codeTableCell) {
          codeText = codeTableCell.textContent || codeTableCell.innerText;
        } else {
          
          const codeElement = codeContainer.querySelector('code');
          if (codeElement) {
            
            const hasInlineLineNumbers = codeElement.querySelector('.ln');
            if (hasInlineLineNumbers) {
              
              const codeLines = codeElement.querySelectorAll('.cl');
              if (codeLines.length > 0) {
                codeText = Array.from(codeLines)
                  .map(line => {
                    const text = line.textContent || line.innerText;
                    
                    return text.replace(/\n+$/, '');
                  })
                  .join('\n')
                  .replace(/\n+$/, ''); 
              } else {
                
                const allText = codeElement.textContent || codeElement.innerText;
                codeText = allText.replace(/^\d+/gm, '').replace(/^\s+/gm, '');
              }
            } else {
              
              codeText = codeElement.textContent || codeElement.innerText;
            }
          } else {
            
            codeText = codeContainer.textContent || codeContainer.innerText;
          }
        }

        
        codeText = codeText.trim();

        
        await navigator.clipboard.writeText(codeText);

        
        copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M5 13l4 4L19 7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (copyText) {
          copyText.textContent = '복사됨';
        }
        copyBtn.classList.add('text-green-600');

        
        setTimeout(() => {
          copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z\u0022 \/\u003e\n\u003c\/svg\u003e`;
          if (copyText) {
            copyText.textContent = '복사';
          }
          copyBtn.classList.remove('text-green-600');
        }, 2000);

      } catch (err) {
        console.error('复制失败:', err);

        
        const range = document.createRange();
        const codeElement = codeContainer.querySelector('code') || codeContainer;
        range.selectNodeContents(codeElement);
        const selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);

        
        if (copyText) {
          copyText.textContent = '선택됨';
        }

        setTimeout(() => {
          if (copyText) {
            copyText.textContent = '복사';
          }
          selection.removeAllRanges();
        }, 2000);
      }
    });
  }

  
  if (collapseBtn) {
    const collapseIcon = collapseBtn.querySelector('.collapse-icon');
    const collapseText = collapseBtn.querySelector('.collapse-text');
    const collapseOverlay = codeContainer.querySelector('.collapse-overlay');

    
    let codeElement = codeContainer.querySelector('pre.chroma');
    if (!codeElement) {
      codeElement = codeContainer.querySelector('pre');
    }

    const defaultState = collapseBtn.dataset.defaultState || 'expanded';
    const isCollapsedAttr = collapseBtn.dataset.collapsed === 'true';
    const autoCollapseLines = parseInt(collapseBtn.dataset.autoCollapseLines) || 30;
    const autoCollapseHeight = parseInt(collapseBtn.dataset.autoCollapseHeight) || 400;
    const collapsedHeight = parseInt(collapseBtn.dataset.collapsedHeight) || 120;

    let isCollapsed = false;

    
    function initCollapse() {
      
      const shouldCollapse = isCollapsedAttr ||
                           defaultState === 'collapsed' ||
                           shouldAutoCollapse();

      if (shouldCollapse) {
        setCollapsed(true, false); 
      }
    }

    function shouldAutoCollapse() {
      
      if (codeElement) {
        const lines = codeElement.querySelectorAll('.line, .cl');
        const height = codeElement.offsetHeight;
        return lines.length > autoCollapseLines || height > autoCollapseHeight;
      }

      
      const containerHeight = codeContainer.offsetHeight;
      if (containerHeight > autoCollapseHeight) {
        return true;
      }

      
      const textContent = codeContainer.textContent || codeContainer.innerText || '';
      const estimatedLines = textContent.split('\n').length;
      return estimatedLines > autoCollapseLines;
    }

    function setCollapsed(collapsed, animate = true) {
      if (!collapseOverlay) return;

      isCollapsed = collapsed;

      if (collapsed) {
        
        codeContainer.style.maxHeight = collapsedHeight + 'px';
        codeContainer.style.overflow = 'hidden';
        collapseOverlay.style.opacity = '1';
        collapseOverlay.style.pointerEvents = 'auto';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M19 9l-7 7-7-7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '펼치기';
        }
        collapseBtn.title = '펼치기';

      } else {
        
        codeContainer.style.maxHeight = '';
        codeContainer.style.overflow = '';
        collapseOverlay.style.opacity = '0';
        collapseOverlay.style.pointerEvents = 'none';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath fill=\u0022currentColor\u0022 d=\u0022M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z\u0022\/\u003e\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '접기';
        }
        collapseBtn.title = '접기';
      }

      
      if (animate) {
        codeContainer.style.transition = 'max-height 0.3s ease-out';
        setTimeout(() => {
          codeContainer.style.transition = '';
        }, 300);
      }
    }

    function toggleCollapse() {
      setCollapsed(!isCollapsed, true);
    }

    
    collapseBtn.addEventListener('click', toggleCollapse);

    
    if (collapseOverlay) {
      collapseOverlay.addEventListener('click', () => {
        if (isCollapsed) {
          setCollapsed(false, true);
        }
      });
    }

    
    initCollapse();
  }
})();
</script>
</li>
<li>각 GPU는 버블 시작 시점에 시간을 기록하고, 다음 단계가 시작되는 순간까지의 시간과 사용 가능한 GPU 메모리량을 계측합니다.
<ul>
<li><strong>예시 결과</strong>:
<ul>
<li>측정된 버블 기간: <code>100ms</code></li>
<li>사용 가능한 GPU 메모리: <code>4.5GB</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="-step-2--fill-job-execution-plan-작업-실행-계획-수립">🚩 <strong>STEP 2 : Fill Job Execution Plan (작업 실행 계획 수립)</strong></h2>
<h3 id="목적-1">목적:</h3>
<p>계측된 버블의 기간과 메모리 제약에 따라, Fill job을 잘게 나누어 pipeline 버블에서 효율적으로 실행 가능하도록 합니다.</p>
<h3 id="구체적-과정-greedy-알고리즘-예시">구체적 과정 (Greedy 알고리즘 예시):</h3>
<ul>
<li>
<p><strong>입력</strong>:</p>
<ul>
<li>버블 정보: <code>[버블 기간: 100ms, 메모리: 4.5GB]</code></li>
<li>Fill job 정보: <code>[BERT-Large 추론 (Batch size=8): 실행시간 30ms, 메모리 필요량 4GB]</code></li>
<li>실행해야 하는 총 샘플 수: 예) 320개 (샘플 8개 처리에 30ms 걸림, 총 40회 반복 필요)</li>
</ul>
</li>
<li>
<p><strong>실행 계획 수립 예시</strong>:</p>
<div
  class="code-block-container border-border bg-card my-6 overflow-hidden rounded-xl border shadow-sm transition-all duration-200 ease-out hover:-translate-y-0.5 hover:shadow-md">
  
  <div
    class="code-block-header bg-muted/30 border-border flex items-center justify-between border-b px-4 py-3">
    
    <div class="flex items-center gap-2">
      <div class="text-muted-foreground flex-shrink-0">
        
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4" />
</svg>
      </div>
      <span class="text-muted-foreground text-sm font-medium">
        PSEUDO
      </span>
    </div>

    
    <div class="flex items-center gap-2">
      <button
          class="collapse-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
          data-code-id="code-2"
          data-default-state="expanded"
          data-collapsed="false"
          data-auto-collapse-lines="30"
          data-auto-collapse-height="400"
          data-collapsed-height="120"
          title="접기"
          aria-label="접기">
          <span class="collapse-icon">
            
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path fill="currentColor" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z"/></svg>
          </span>
          <span class="collapse-text hidden sm:inline"
            >접기</span
          >
        </button>
      <button
        class="copy-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
        data-code-id="code-2"
        title="복사"
        aria-label="복사">
        <span class="copy-icon">
          
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
</svg>
        </span>
        <span class="copy-text hidden sm:inline"
          >복사</span
        >
      </button>
    </div>
  </div>

  
  <div class="code-block-content relative" id="code-2">
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">bubble_time = 100ms
</span></span><span class="line"><span class="ln">2</span><span class="cl">single_batch_execution_time = 30ms
</span></span><span class="line"><span class="ln">3</span><span class="cl">memory_required = 4GB &lt; 4.5GB (만족)
</span></span><span class="line"><span class="ln">4</span><span class="cl">
</span></span><span class="line"><span class="ln">5</span><span class="cl">계획:
</span></span><span class="line"><span class="ln">6</span><span class="cl">- 하나의 버블(100ms) 동안 Batch inference 작업을 최대 3회(90ms) 실행 가능
</span></span><span class="line"><span class="ln">7</span><span class="cl">- 매 버블마다 24개의 샘플 처리 가능 (3회×batch size 8)
</span></span><span class="line"><span class="ln">8</span><span class="cl">- 총 320개 샘플 처리 필요 → 약 13~14개 버블 사용 (24개×13=312, 24×14=336)
</span></span><span class="line"><span class="ln">9</span><span class="cl">- 전체 계획: [버블1(24샘플), 버블2(24샘플), …, 버블14(마지막은 일부 샘플)]</span></span></code></pre></div>
    
    <div
      class="collapse-overlay to-card/90 pointer-events-none absolute inset-0 bg-gradient-to-b from-transparent via-transparent opacity-0 transition-opacity duration-300">
      <div
        class="text-muted-foreground bg-card/80 border-border/50 hover:bg-primary/10 hover:text-primary hover:border-primary/30 absolute bottom-4 left-1/2 -translate-x-1/2 cursor-pointer rounded-full border px-3 py-1.5 text-xs backdrop-blur-sm transition-all duration-200">
        클릭하여 더 보기
      </div>
    </div>
  </div>
</div>


<script>
(function() {
  const codeId = 'code-2';
  const copyBtn = document.querySelector('.copy-code-btn[data-code-id="' + codeId + '"]');
  const collapseBtn = document.querySelector('.collapse-code-btn[data-code-id="' + codeId + '"]');
  const codeContainer = document.getElementById(codeId);

  if (!codeContainer) return;

  
  if (copyBtn) {
    const copyIcon = copyBtn.querySelector('.copy-icon');
    const copyText = copyBtn.querySelector('.copy-text');

    copyBtn.addEventListener('click', async function() {
      try {
        
        let codeText = '';

        
        const codeTableCell = codeContainer.querySelector('.lntd:last-child code');
        if (codeTableCell) {
          codeText = codeTableCell.textContent || codeTableCell.innerText;
        } else {
          
          const codeElement = codeContainer.querySelector('code');
          if (codeElement) {
            
            const hasInlineLineNumbers = codeElement.querySelector('.ln');
            if (hasInlineLineNumbers) {
              
              const codeLines = codeElement.querySelectorAll('.cl');
              if (codeLines.length > 0) {
                codeText = Array.from(codeLines)
                  .map(line => {
                    const text = line.textContent || line.innerText;
                    
                    return text.replace(/\n+$/, '');
                  })
                  .join('\n')
                  .replace(/\n+$/, ''); 
              } else {
                
                const allText = codeElement.textContent || codeElement.innerText;
                codeText = allText.replace(/^\d+/gm, '').replace(/^\s+/gm, '');
              }
            } else {
              
              codeText = codeElement.textContent || codeElement.innerText;
            }
          } else {
            
            codeText = codeContainer.textContent || codeContainer.innerText;
          }
        }

        
        codeText = codeText.trim();

        
        await navigator.clipboard.writeText(codeText);

        
        copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M5 13l4 4L19 7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (copyText) {
          copyText.textContent = '복사됨';
        }
        copyBtn.classList.add('text-green-600');

        
        setTimeout(() => {
          copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z\u0022 \/\u003e\n\u003c\/svg\u003e`;
          if (copyText) {
            copyText.textContent = '복사';
          }
          copyBtn.classList.remove('text-green-600');
        }, 2000);

      } catch (err) {
        console.error('复制失败:', err);

        
        const range = document.createRange();
        const codeElement = codeContainer.querySelector('code') || codeContainer;
        range.selectNodeContents(codeElement);
        const selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);

        
        if (copyText) {
          copyText.textContent = '선택됨';
        }

        setTimeout(() => {
          if (copyText) {
            copyText.textContent = '복사';
          }
          selection.removeAllRanges();
        }, 2000);
      }
    });
  }

  
  if (collapseBtn) {
    const collapseIcon = collapseBtn.querySelector('.collapse-icon');
    const collapseText = collapseBtn.querySelector('.collapse-text');
    const collapseOverlay = codeContainer.querySelector('.collapse-overlay');

    
    let codeElement = codeContainer.querySelector('pre.chroma');
    if (!codeElement) {
      codeElement = codeContainer.querySelector('pre');
    }

    const defaultState = collapseBtn.dataset.defaultState || 'expanded';
    const isCollapsedAttr = collapseBtn.dataset.collapsed === 'true';
    const autoCollapseLines = parseInt(collapseBtn.dataset.autoCollapseLines) || 30;
    const autoCollapseHeight = parseInt(collapseBtn.dataset.autoCollapseHeight) || 400;
    const collapsedHeight = parseInt(collapseBtn.dataset.collapsedHeight) || 120;

    let isCollapsed = false;

    
    function initCollapse() {
      
      const shouldCollapse = isCollapsedAttr ||
                           defaultState === 'collapsed' ||
                           shouldAutoCollapse();

      if (shouldCollapse) {
        setCollapsed(true, false); 
      }
    }

    function shouldAutoCollapse() {
      
      if (codeElement) {
        const lines = codeElement.querySelectorAll('.line, .cl');
        const height = codeElement.offsetHeight;
        return lines.length > autoCollapseLines || height > autoCollapseHeight;
      }

      
      const containerHeight = codeContainer.offsetHeight;
      if (containerHeight > autoCollapseHeight) {
        return true;
      }

      
      const textContent = codeContainer.textContent || codeContainer.innerText || '';
      const estimatedLines = textContent.split('\n').length;
      return estimatedLines > autoCollapseLines;
    }

    function setCollapsed(collapsed, animate = true) {
      if (!collapseOverlay) return;

      isCollapsed = collapsed;

      if (collapsed) {
        
        codeContainer.style.maxHeight = collapsedHeight + 'px';
        codeContainer.style.overflow = 'hidden';
        collapseOverlay.style.opacity = '1';
        collapseOverlay.style.pointerEvents = 'auto';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M19 9l-7 7-7-7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '펼치기';
        }
        collapseBtn.title = '펼치기';

      } else {
        
        codeContainer.style.maxHeight = '';
        codeContainer.style.overflow = '';
        collapseOverlay.style.opacity = '0';
        collapseOverlay.style.pointerEvents = 'none';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath fill=\u0022currentColor\u0022 d=\u0022M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z\u0022\/\u003e\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '접기';
        }
        collapseBtn.title = '접기';
      }

      
      if (animate) {
        codeContainer.style.transition = 'max-height 0.3s ease-out';
        setTimeout(() => {
          codeContainer.style.transition = '';
        }, 300);
      }
    }

    function toggleCollapse() {
      setCollapsed(!isCollapsed, true);
    }

    
    collapseBtn.addEventListener('click', toggleCollapse);

    
    if (collapseOverlay) {
      collapseOverlay.addEventListener('click', () => {
        if (isCollapsed) {
          setCollapsed(false, true);
        }
      });
    }

    
    initCollapse();
  }
})();
</script>
</li>
<li>
<p>위와 같이 실제로 GPU idle time 내에서 효율적으로 job을 분할하여 처리 가능하게 만듦.</p>
</li>
</ul>
<hr>
<h2 id="-step-3--fill-job-scheduling-작업-스케줄링">🚩 <strong>STEP 3 : Fill Job Scheduling (작업 스케줄링)</strong></h2>
<h3 id="목적-2">목적:</h3>
<p>여러 fill job이 존재할 때, 사용자의 우선순위(빠른 완료, 긴 작업 우선 등)에 따라 적절한 GPU와 버블 시점에 배정합니다.</p>
<h3 id="예시를-통한-scheduling-방식">예시를 통한 Scheduling 방식:</h3>
<ul>
<li>
<p><strong>Fill Job</strong> 여러 개 존재 예시:</p>
<ul>
<li>Job A (BERT inference, 300개 샘플, 소요시간 짧음)</li>
<li>Job B (EfficientNet Training, 긴 작업, 소요시간 김)</li>
</ul>
</li>
<li>
<p><strong>사용자 정의 Scheduling Policy</strong> 예시:</p>
<ul>
<li>&ldquo;Shortest Job First (SJF)&rdquo;: 짧은 작업을 빠르게 완료하여 GPU를 비움
<div
  class="code-block-container border-border bg-card my-6 overflow-hidden rounded-xl border shadow-sm transition-all duration-200 ease-out hover:-translate-y-0.5 hover:shadow-md">
  
  <div
    class="code-block-header bg-muted/30 border-border flex items-center justify-between border-b px-4 py-3">
    
    <div class="flex items-center gap-2">
      <div class="text-muted-foreground flex-shrink-0">
        
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4" />
</svg>
      </div>
      <span class="text-muted-foreground text-sm font-medium">
        PLAINTEXT
      </span>
    </div>

    
    <div class="flex items-center gap-2">
      <button
          class="collapse-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
          data-code-id="code-3"
          data-default-state="expanded"
          data-collapsed="false"
          data-auto-collapse-lines="30"
          data-auto-collapse-height="400"
          data-collapsed-height="120"
          title="접기"
          aria-label="접기">
          <span class="collapse-icon">
            
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path fill="currentColor" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z"/></svg>
          </span>
          <span class="collapse-text hidden sm:inline"
            >접기</span
          >
        </button>
      <button
        class="copy-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
        data-code-id="code-3"
        title="복사"
        aria-label="복사">
        <span class="copy-icon">
          
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
</svg>
        </span>
        <span class="copy-text hidden sm:inline"
          >복사</span
        >
      </button>
    </div>
  </div>

  
  <div class="code-block-content relative" id="code-3">
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">선택 → Job A 우선 배정</span></span></code></pre></div>
    
    <div
      class="collapse-overlay to-card/90 pointer-events-none absolute inset-0 bg-gradient-to-b from-transparent via-transparent opacity-0 transition-opacity duration-300">
      <div
        class="text-muted-foreground bg-card/80 border-border/50 hover:bg-primary/10 hover:text-primary hover:border-primary/30 absolute bottom-4 left-1/2 -translate-x-1/2 cursor-pointer rounded-full border px-3 py-1.5 text-xs backdrop-blur-sm transition-all duration-200">
        클릭하여 더 보기
      </div>
    </div>
  </div>
</div>


<script>
(function() {
  const codeId = 'code-3';
  const copyBtn = document.querySelector('.copy-code-btn[data-code-id="' + codeId + '"]');
  const collapseBtn = document.querySelector('.collapse-code-btn[data-code-id="' + codeId + '"]');
  const codeContainer = document.getElementById(codeId);

  if (!codeContainer) return;

  
  if (copyBtn) {
    const copyIcon = copyBtn.querySelector('.copy-icon');
    const copyText = copyBtn.querySelector('.copy-text');

    copyBtn.addEventListener('click', async function() {
      try {
        
        let codeText = '';

        
        const codeTableCell = codeContainer.querySelector('.lntd:last-child code');
        if (codeTableCell) {
          codeText = codeTableCell.textContent || codeTableCell.innerText;
        } else {
          
          const codeElement = codeContainer.querySelector('code');
          if (codeElement) {
            
            const hasInlineLineNumbers = codeElement.querySelector('.ln');
            if (hasInlineLineNumbers) {
              
              const codeLines = codeElement.querySelectorAll('.cl');
              if (codeLines.length > 0) {
                codeText = Array.from(codeLines)
                  .map(line => {
                    const text = line.textContent || line.innerText;
                    
                    return text.replace(/\n+$/, '');
                  })
                  .join('\n')
                  .replace(/\n+$/, ''); 
              } else {
                
                const allText = codeElement.textContent || codeElement.innerText;
                codeText = allText.replace(/^\d+/gm, '').replace(/^\s+/gm, '');
              }
            } else {
              
              codeText = codeElement.textContent || codeElement.innerText;
            }
          } else {
            
            codeText = codeContainer.textContent || codeContainer.innerText;
          }
        }

        
        codeText = codeText.trim();

        
        await navigator.clipboard.writeText(codeText);

        
        copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M5 13l4 4L19 7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (copyText) {
          copyText.textContent = '복사됨';
        }
        copyBtn.classList.add('text-green-600');

        
        setTimeout(() => {
          copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z\u0022 \/\u003e\n\u003c\/svg\u003e`;
          if (copyText) {
            copyText.textContent = '복사';
          }
          copyBtn.classList.remove('text-green-600');
        }, 2000);

      } catch (err) {
        console.error('复制失败:', err);

        
        const range = document.createRange();
        const codeElement = codeContainer.querySelector('code') || codeContainer;
        range.selectNodeContents(codeElement);
        const selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);

        
        if (copyText) {
          copyText.textContent = '선택됨';
        }

        setTimeout(() => {
          if (copyText) {
            copyText.textContent = '복사';
          }
          selection.removeAllRanges();
        }, 2000);
      }
    });
  }

  
  if (collapseBtn) {
    const collapseIcon = collapseBtn.querySelector('.collapse-icon');
    const collapseText = collapseBtn.querySelector('.collapse-text');
    const collapseOverlay = codeContainer.querySelector('.collapse-overlay');

    
    let codeElement = codeContainer.querySelector('pre.chroma');
    if (!codeElement) {
      codeElement = codeContainer.querySelector('pre');
    }

    const defaultState = collapseBtn.dataset.defaultState || 'expanded';
    const isCollapsedAttr = collapseBtn.dataset.collapsed === 'true';
    const autoCollapseLines = parseInt(collapseBtn.dataset.autoCollapseLines) || 30;
    const autoCollapseHeight = parseInt(collapseBtn.dataset.autoCollapseHeight) || 400;
    const collapsedHeight = parseInt(collapseBtn.dataset.collapsedHeight) || 120;

    let isCollapsed = false;

    
    function initCollapse() {
      
      const shouldCollapse = isCollapsedAttr ||
                           defaultState === 'collapsed' ||
                           shouldAutoCollapse();

      if (shouldCollapse) {
        setCollapsed(true, false); 
      }
    }

    function shouldAutoCollapse() {
      
      if (codeElement) {
        const lines = codeElement.querySelectorAll('.line, .cl');
        const height = codeElement.offsetHeight;
        return lines.length > autoCollapseLines || height > autoCollapseHeight;
      }

      
      const containerHeight = codeContainer.offsetHeight;
      if (containerHeight > autoCollapseHeight) {
        return true;
      }

      
      const textContent = codeContainer.textContent || codeContainer.innerText || '';
      const estimatedLines = textContent.split('\n').length;
      return estimatedLines > autoCollapseLines;
    }

    function setCollapsed(collapsed, animate = true) {
      if (!collapseOverlay) return;

      isCollapsed = collapsed;

      if (collapsed) {
        
        codeContainer.style.maxHeight = collapsedHeight + 'px';
        codeContainer.style.overflow = 'hidden';
        collapseOverlay.style.opacity = '1';
        collapseOverlay.style.pointerEvents = 'auto';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M19 9l-7 7-7-7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '펼치기';
        }
        collapseBtn.title = '펼치기';

      } else {
        
        codeContainer.style.maxHeight = '';
        codeContainer.style.overflow = '';
        collapseOverlay.style.opacity = '0';
        collapseOverlay.style.pointerEvents = 'none';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath fill=\u0022currentColor\u0022 d=\u0022M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z\u0022\/\u003e\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '접기';
        }
        collapseBtn.title = '접기';
      }

      
      if (animate) {
        codeContainer.style.transition = 'max-height 0.3s ease-out';
        setTimeout(() => {
          codeContainer.style.transition = '';
        }, 300);
      }
    }

    function toggleCollapse() {
      setCollapsed(!isCollapsed, true);
    }

    
    collapseBtn.addEventListener('click', toggleCollapse);

    
    if (collapseOverlay) {
      collapseOverlay.addEventListener('click', () => {
        if (isCollapsed) {
          setCollapsed(false, true);
        }
      });
    }

    
    initCollapse();
  }
})();
</script>
</li>
<li>&ldquo;Makespan Minimizing&rdquo;: GPU 사용률 극대화를 위해 효율이 높은 작업 우선 배정
<div
  class="code-block-container border-border bg-card my-6 overflow-hidden rounded-xl border shadow-sm transition-all duration-200 ease-out hover:-translate-y-0.5 hover:shadow-md">
  
  <div
    class="code-block-header bg-muted/30 border-border flex items-center justify-between border-b px-4 py-3">
    
    <div class="flex items-center gap-2">
      <div class="text-muted-foreground flex-shrink-0">
        
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4" />
</svg>
      </div>
      <span class="text-muted-foreground text-sm font-medium">
        PLAINTEXT
      </span>
    </div>

    
    <div class="flex items-center gap-2">
      <button
          class="collapse-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
          data-code-id="code-4"
          data-default-state="expanded"
          data-collapsed="false"
          data-auto-collapse-lines="30"
          data-auto-collapse-height="400"
          data-collapsed-height="120"
          title="접기"
          aria-label="접기">
          <span class="collapse-icon">
            
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path fill="currentColor" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z"/></svg>
          </span>
          <span class="collapse-text hidden sm:inline"
            >접기</span
          >
        </button>
      <button
        class="copy-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
        data-code-id="code-4"
        title="복사"
        aria-label="복사">
        <span class="copy-icon">
          
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
</svg>
        </span>
        <span class="copy-text hidden sm:inline"
          >복사</span
        >
      </button>
    </div>
  </div>

  
  <div class="code-block-content relative" id="code-4">
    <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">GPU TFLOPS 효율성이 높은 작업 우선 → 효율이 높은 inference (Job A) 우선</span></span></code></pre></div>
    
    <div
      class="collapse-overlay to-card/90 pointer-events-none absolute inset-0 bg-gradient-to-b from-transparent via-transparent opacity-0 transition-opacity duration-300">
      <div
        class="text-muted-foreground bg-card/80 border-border/50 hover:bg-primary/10 hover:text-primary hover:border-primary/30 absolute bottom-4 left-1/2 -translate-x-1/2 cursor-pointer rounded-full border px-3 py-1.5 text-xs backdrop-blur-sm transition-all duration-200">
        클릭하여 더 보기
      </div>
    </div>
  </div>
</div>


<script>
(function() {
  const codeId = 'code-4';
  const copyBtn = document.querySelector('.copy-code-btn[data-code-id="' + codeId + '"]');
  const collapseBtn = document.querySelector('.collapse-code-btn[data-code-id="' + codeId + '"]');
  const codeContainer = document.getElementById(codeId);

  if (!codeContainer) return;

  
  if (copyBtn) {
    const copyIcon = copyBtn.querySelector('.copy-icon');
    const copyText = copyBtn.querySelector('.copy-text');

    copyBtn.addEventListener('click', async function() {
      try {
        
        let codeText = '';

        
        const codeTableCell = codeContainer.querySelector('.lntd:last-child code');
        if (codeTableCell) {
          codeText = codeTableCell.textContent || codeTableCell.innerText;
        } else {
          
          const codeElement = codeContainer.querySelector('code');
          if (codeElement) {
            
            const hasInlineLineNumbers = codeElement.querySelector('.ln');
            if (hasInlineLineNumbers) {
              
              const codeLines = codeElement.querySelectorAll('.cl');
              if (codeLines.length > 0) {
                codeText = Array.from(codeLines)
                  .map(line => {
                    const text = line.textContent || line.innerText;
                    
                    return text.replace(/\n+$/, '');
                  })
                  .join('\n')
                  .replace(/\n+$/, ''); 
              } else {
                
                const allText = codeElement.textContent || codeElement.innerText;
                codeText = allText.replace(/^\d+/gm, '').replace(/^\s+/gm, '');
              }
            } else {
              
              codeText = codeElement.textContent || codeElement.innerText;
            }
          } else {
            
            codeText = codeContainer.textContent || codeContainer.innerText;
          }
        }

        
        codeText = codeText.trim();

        
        await navigator.clipboard.writeText(codeText);

        
        copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M5 13l4 4L19 7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (copyText) {
          copyText.textContent = '복사됨';
        }
        copyBtn.classList.add('text-green-600');

        
        setTimeout(() => {
          copyIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z\u0022 \/\u003e\n\u003c\/svg\u003e`;
          if (copyText) {
            copyText.textContent = '복사';
          }
          copyBtn.classList.remove('text-green-600');
        }, 2000);

      } catch (err) {
        console.error('复制失败:', err);

        
        const range = document.createRange();
        const codeElement = codeContainer.querySelector('code') || codeContainer;
        range.selectNodeContents(codeElement);
        const selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);

        
        if (copyText) {
          copyText.textContent = '선택됨';
        }

        setTimeout(() => {
          if (copyText) {
            copyText.textContent = '복사';
          }
          selection.removeAllRanges();
        }, 2000);
      }
    });
  }

  
  if (collapseBtn) {
    const collapseIcon = collapseBtn.querySelector('.collapse-icon');
    const collapseText = collapseBtn.querySelector('.collapse-text');
    const collapseOverlay = codeContainer.querySelector('.collapse-overlay');

    
    let codeElement = codeContainer.querySelector('pre.chroma');
    if (!codeElement) {
      codeElement = codeContainer.querySelector('pre');
    }

    const defaultState = collapseBtn.dataset.defaultState || 'expanded';
    const isCollapsedAttr = collapseBtn.dataset.collapsed === 'true';
    const autoCollapseLines = parseInt(collapseBtn.dataset.autoCollapseLines) || 30;
    const autoCollapseHeight = parseInt(collapseBtn.dataset.autoCollapseHeight) || 400;
    const collapsedHeight = parseInt(collapseBtn.dataset.collapsedHeight) || 120;

    let isCollapsed = false;

    
    function initCollapse() {
      
      const shouldCollapse = isCollapsedAttr ||
                           defaultState === 'collapsed' ||
                           shouldAutoCollapse();

      if (shouldCollapse) {
        setCollapsed(true, false); 
      }
    }

    function shouldAutoCollapse() {
      
      if (codeElement) {
        const lines = codeElement.querySelectorAll('.line, .cl');
        const height = codeElement.offsetHeight;
        return lines.length > autoCollapseLines || height > autoCollapseHeight;
      }

      
      const containerHeight = codeContainer.offsetHeight;
      if (containerHeight > autoCollapseHeight) {
        return true;
      }

      
      const textContent = codeContainer.textContent || codeContainer.innerText || '';
      const estimatedLines = textContent.split('\n').length;
      return estimatedLines > autoCollapseLines;
    }

    function setCollapsed(collapsed, animate = true) {
      if (!collapseOverlay) return;

      isCollapsed = collapsed;

      if (collapsed) {
        
        codeContainer.style.maxHeight = collapsedHeight + 'px';
        codeContainer.style.overflow = 'hidden';
        collapseOverlay.style.opacity = '1';
        collapseOverlay.style.pointerEvents = 'auto';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M19 9l-7 7-7-7\u0022 \/\u003e\n\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '펼치기';
        }
        collapseBtn.title = '펼치기';

      } else {
        
        codeContainer.style.maxHeight = '';
        codeContainer.style.overflow = '';
        collapseOverlay.style.opacity = '0';
        collapseOverlay.style.pointerEvents = 'none';

        
        collapseIcon.innerHTML = `\n  \u003csvg class=\u0022h-3 w-3\u0022\n    fill=\u0022none\u0022\n    stroke=\u0022currentColor\u0022\n    viewBox=\u00220 0 24 24\u0022\u003e\u003cpath fill=\u0022currentColor\u0022 d=\u0022M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z\u0022\/\u003e\u003c\/svg\u003e`;
        if (collapseText) {
          collapseText.textContent = '접기';
        }
        collapseBtn.title = '접기';
      }

      
      if (animate) {
        codeContainer.style.transition = 'max-height 0.3s ease-out';
        setTimeout(() => {
          codeContainer.style.transition = '';
        }, 300);
      }
    }

    function toggleCollapse() {
      setCollapsed(!isCollapsed, true);
    }

    
    collapseBtn.addEventListener('click', toggleCollapse);

    
    if (collapseOverlay) {
      collapseOverlay.addEventListener('click', () => {
        if (isCollapsed) {
          setCollapsed(false, true);
        }
      });
    }

    
    initCollapse();
  }
})();
</script>
</li>
</ul>
</li>
<li>
<p>배정 결과: Fill Job Executor는 각 GPU의 bubble 시점을 인지하여 <strong>정해진 스케줄링 정책</strong>에 맞춰 작업을 투입하고 완료 시까지 계속 수행합니다.</p>
</li>
</ul>
<hr>
<h2 id="-추가-context-switching-과정">🚩 <strong>추가: Context Switching 과정</strong></h2>
<ul>
<li>Main Job 버블 발생 (Idle 시간 시작)</li>
<li>Executor가 fill job의 이전 상태(모델 weights, activations)를 로딩하고 연산 수행</li>
<li>버블이 종료되는 시점 직전에 fill job 상태를 빠르게 저장하고 작업 중단</li>
<li>GPU 상태를 Main job으로 복원하고 다시 메인 작업 시작</li>
</ul>
<p>이 과정을 통해 메인 작업 성능 저하를 2% 이내로 최소화함</p>
<hr>
<h2 id="-요약정리">📋 <strong>요약정리</strong></h2>
<table>
  <thead>
      <tr>
          <th>단계</th>
          <th>주요 역할</th>
          <th>예시 작업 수행 방식</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>① Bubble Instrumentation</strong></td>
          <td>버블 기간 및 메모리 가용량 측정</td>
          <td>버블 측정 (<code>100ms</code>, <code>4.5GB</code>)</td>
      </tr>
      <tr>
          <td><strong>② Execution Plan</strong></td>
          <td>버블 제약 내에서 job 분할</td>
          <td>버블 당 BERT inference 3회 처리 (24 샘플)</td>
      </tr>
      <tr>
          <td><strong>③ Scheduling</strong></td>
          <td>우선순위에 따라 job 배정</td>
          <td>짧은 작업(BERT inference) 우선 배정</td>
      </tr>
  </tbody>
</table>
<hr>
<h2 id="-결론적-요약">✨ <strong>결론적 요약</strong></h2>
<p>『PipeFill』은 <strong>파이프라인 병렬 처리 중 발생하는 GPU idle 시간</strong>에 대해 정확한 계측 → 세부 실행 계획 수립 → 효율적인 작업 스케줄링을 통해 GPU 사용률을 크게 높이는 알고리즘이며, 위의 단계별 알고리즘이 이를 구체적으로 설명하고 있습니다.</p>
<h1 id="q--이-논문에서-제시한-결과를-자세하게-보고-다른-방법론에-비하여-특출난-점과-논문에서-제기하는-어떠한-방법이-이러한-결과를-도출하게-되었는지-논문에서-제시하는-이유와-너의-생각을-알려줘">Q : 이 논문에서 제시한 결과를 자세하게 보고 다른 방법론에 비하여 특출난 점과 논문에서 제기하는 어떠한 방법이 이러한 결과를 도출하게 되었는지 논문에서 제시하는 이유와 너의 생각을 알려줘</h1>
<p>논문『PipeFill』에서 제시한 실험 결과를 자세히 살펴보며, 다른 방법론과 비교하여 특출난 점을 분석하고, 논문이 설명하는 성능 향상의 원인과 이에 대한 추가적인 생각을 제시하겠습니다.</p>
<hr>
<h2 id="-논문에서-제시한-주요-결과-정량적-수치">📊 논문에서 제시한 주요 결과 (정량적 수치)</h2>
<p>『PipeFill』 논문은 실험에서 GPU의 **Pipeline Bubble(유휴 시간)**을 추가 작업(Fill job)으로 메웠을 때, 기존의 Pipeline Parallelism (PP) 방식 대비 큰 GPU 효율성 향상을 보였습니다.</p>
<table>
  <thead>
      <tr>
          <th>GPU 개수</th>
          <th>전통적 PP 방식 GPU 활용률 (TFLOPS)</th>
          <th>PipeFill 적용 시 GPU 활용률 (TFLOPS)</th>
          <th>GPU 활용률 증가폭 (%)</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>1,000</td>
          <td>46.8</td>
          <td>51.0</td>
          <td>+9%</td>
      </tr>
      <tr>
          <td>2,000</td>
          <td>34.5</td>
          <td>39.2</td>
          <td>+14%</td>
      </tr>
      <tr>
          <td>4,000</td>
          <td>22.7</td>
          <td>33.0</td>
          <td>+45%</td>
      </tr>
      <tr>
          <td>8,000</td>
          <td>17.8</td>
          <td>29.0</td>
          <td><strong>+63%</strong></td>
      </tr>
  </tbody>
</table>
<p>특히 GPU 개수가 많아질수록 버블 비율이 높아져서 성능 저하가 심했던 기존 방식과 달리, PipeFill은 오히려 활용률을 크게 높이는 결과를 보였습니다.</p>
<hr>
<h2 id="-다른-방법론과-비교하여-특출난-점">🌟 다른 방법론과 비교하여 특출난 점</h2>
<p>『PipeFill』이 기존 연구와 비교하여 특출난 점을 크게 3가지로 요약하면:</p>
<h3 id="-독립적인-작업의-병렬-수행">① 독립적인 작업의 병렬 수행</h3>
<ul>
<li>기존 연구들 (예: PipeFisher, Bamboo)은 pipeline bubble을 채우기 위해 <strong>주작업과 연관된 작업만 사용</strong>했습니다.</li>
<li>『PipeFill』은 <strong>주 작업과 완전히 독립된 작업</strong>을 활용하여 GPU 자원을 효율적으로 활용하는 최초의 방법으로, 매우 독창적인 아이디어입니다.</li>
</ul>
<h3 id="-매우-낮은-성능-오버헤드-주-작업-성능-손실-최소화">② 매우 낮은 성능 오버헤드 (주 작업 성능 손실 최소화)</h3>
<ul>
<li>GPU 자원을 공유하는 다른 연구(Muri, Antman 등)는 주작업과의 메모리 경합으로 인해 주 작업 성능이 크게 저하되는 경우가 많았습니다.</li>
<li>PipeFill은 context switching을 pipeline bubble 시점으로 한정하여 <strong>주 작업의 성능 손실을 2% 미만</strong>으로 극소화했습니다.</li>
</ul>
<table>
  <thead>
      <tr>
          <th>방법론</th>
          <th>주 작업 성능 오버헤드</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Muri, Antman (기존 방법)</td>
          <td>10% 이상 (상대적으로 높음)</td>
      </tr>
      <tr>
          <td>PipeFill (본 논문)</td>
          <td><strong>2% 미만</strong> (매우 낮음)</td>
      </tr>
  </tbody>
</table>
<h3 id="-높은-gpu-활용률-향상-scaling-효과-우수">③ 높은 GPU 활용률 향상 (Scaling 효과 우수)</h3>
<ul>
<li>GPU 개수가 많아짐에 따라 기존 pipeline 방식은 버블로 인한 효율 저하가 급격히 심해졌으나, PipeFill은 오히려 GPU 자원을 추가로 활용할 수 있어 <strong>강력한 Scaling 효과</strong>를 얻었습니다.</li>
</ul>
<hr>
<h2 id="-논문에서-제시하는-성능-향상의-주요-원인-분석">📌 논문에서 제시하는 성능 향상의 주요 원인 분석</h2>
<p>논문에서 제시된 이유는 다음과 같습니다:</p>
<h3 id="-명확한-버블-계측-및-세부-실행-계획">① 명확한 버블 계측 및 세부 실행 계획</h3>
<ul>
<li>논문의 <strong>Pipeline Bubble Instrumentation</strong> 방법은 버블을 정확히 계측해(시간 및 GPU 메모리 가용량) fill job을 효과적으로 실행할 수 있게 만듭니다.</li>
<li>이렇게 정확히 측정된 데이터는 **세부 실행 계획(Execution Plan Algorithm)**을 수립하여 효율적 작업 분할을 가능하게 했습니다.</li>
</ul>
<h3 id="-독립-작업의-특성-활용">② 독립 작업의 특성 활용</h3>
<ul>
<li>독립 작업(fill job)은 주 작업과의 의존성이 없어서 주 작업 성능 저하 없이 pipeline bubble만큼의 시간에 GPU 자원을 효율적으로 활용할 수 있습니다.</li>
<li>따라서, 메모리와 시간 제약에 맞추어 최적화된 fill job의 배치로 추가적인 성능 이득을 얻습니다.</li>
</ul>
<h3 id="-최적화된-context-switching-전략">③ 최적화된 Context Switching 전략</h3>
<ul>
<li>Pipeline bubble의 시작과 종료 시점을 정확히 파악하여, fill job의 상태 저장 및 복원을 통해 context switching 비용을 최소화했습니다.</li>
<li>이로 인해 주 작업 성능 저하가 거의 없이 추가적인 작업 수행이 가능했습니다.</li>
</ul>
<hr>
<h2 id="-추가적인-나의-생각-분석적-평가">🤔 추가적인 나의 생각 (분석적 평가)</h2>
<p>이러한 뛰어난 성과는 다음의 이유들로 뒷받침됩니다:</p>
<h3 id="-gpu-병렬-처리-특성-활용">① GPU 병렬 처리 특성 활용</h3>
<ul>
<li>현대 GPU는 병렬 처리 능력이 매우 뛰어나지만, 실제로는 Idle 시간이 상당히 많아(15~60%), 그동안 자원이 낭비되었습니다.</li>
<li>PipeFill의 아이디어는 GPU의 고유한 특성을 활용해, idle time을 가치 있는 추가적 작업 시간으로 전환하여 매우 현명한 접근을 취했습니다.</li>
</ul>
<h3 id="-현실적인-하드웨어-환경-최적화">② 현실적인 하드웨어 환경 최적화</h3>
<ul>
<li>PipeFill은 GPU 메모리의 현실적 제약(일반적으로 주 작업이 대부분의 GPU 메모리 점유)을 고려하여 작업의 분할과 실행 계획을 정교하게 세웠습니다.</li>
<li>기존 연구들은 메모리 충돌로 인한 성능 저하가 많았지만, PipeFill은 이 점을 현실적으로 반영하여 실험을 통해 최적의 상태를 찾아낸 것이 큰 장점입니다.</li>
</ul>
<h3 id="-현업에서의-실질적-활용-가능성-높음">③ 현업에서의 실질적 활용 가능성 높음</h3>
<ul>
<li>독립된 작업 처리, 커스터마이징 가능한 scheduling 정책 등은 실제 데이터센터나 클라우드 환경에서 매우 유용합니다.</li>
<li>실제 작업 현장에서 자원 활용을 극대화하는 솔루션으로 빠르게 도입 가능성이 높은 실용적인 연구라고 평가할 수 있습니다.</li>
</ul>
<hr>
<h2 id="-한계점-및-추가-개선-가능성-제안">🚧 한계점 및 추가 개선 가능성 제안</h2>
<ul>
<li>논문에서의 한계점으로 언급된 짧은 버블의 경우, context switching overhead가 상대적으로 높아져 효율이 떨어질 수 있습니다.</li>
<li>버블이 짧을 때의 효율성을 더욱 개선할 수 있는 추가적인 연구가 필요합니다. 예를 들어:
<ul>
<li><strong>Fill job의 경량화 및 모델 압축 기법</strong> 적용</li>
<li>짧은 버블에서 더 낮은 overhead를 가지는 <strong>빠른 Context switching 기술</strong> 개발</li>
</ul>
</li>
</ul>
<hr>
<h2 id="-요약-및-결론적-평가">📗 요약 및 결론적 평가</h2>
<table>
  <thead>
      <tr>
          <th>평가 항목</th>
          <th>평가 및 설명</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>독창성</td>
          <td>최초로 파이프라인 버블에 독립적인 작업 수행</td>
      </tr>
      <tr>
          <td>성능 효율성</td>
          <td>주 작업 성능 저하 최소화(2%)와 GPU 효율성 극대화(최대 63%)</td>
      </tr>
      <tr>
          <td>현실적 적용 가능성</td>
          <td>높은 실용성과 데이터센터 환경의 실질적 적용 가능성 우수</td>
      </tr>
      <tr>
          <td>추가 개선점</td>
          <td>짧은 버블에 대한 효율적 대처 방안 연구 필요</td>
      </tr>
  </tbody>
</table>
<p>『PipeFill』은 독창적이며 현실적으로 매우 효과적인 솔루션으로, GPU 자원을 극대화할 수 있는 훌륭한 연구입니다. 특히 GPU 병렬 처리 특성에 최적화된 설계로 인해 높은 성능 향상을 이뤄냈으며, 실용적인 관점에서도 향후 클라우드와 데이터센터의 효율적인 운영에 매우 큰 기여를 할 수 있는 방법론이라 생각됩니다.</p>
<h1 id="q--이-논문의-한계를-극복하기-위한-방법으로-어떤-연구흐름이-있는지-정리해서-자세하게-설명해-줘">Q : 이 논문의 한계를 극복하기 위한 방법으로 어떤 연구흐름이 있는지 정리해서 자세하게 설명해 줘</h1>
<p>이 논문『PipeFill』이 가진 한계를 명확히 정리하고, 이를 극복하기 위해 최근 연구에서 나타나는 흐름과 다양한 방법론을 체계적으로 분석하여 제안하겠습니다.</p>
<hr>
<h2 id="-먼저pipefill의-한계점-정리">📝 먼저『PipeFill』의 한계점 정리</h2>
<p>『PipeFill』은 GPU 활용률을 크게 개선하였지만, 여전히 다음과 같은 한계점들이 존재합니다.</p>
<table>
  <thead>
      <tr>
          <th>한계점</th>
          <th>구체적인 문제점 설명</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>① 짧은 버블에서의 비효율성</td>
          <td>버블이 매우 짧을 경우 context switching 비용이 증가하여 효율이 떨어짐.</td>
      </tr>
      <tr>
          <td>② GPU 메모리 제한</td>
          <td>주 작업이 대부분의 GPU 메모리를 점유하여 fill job을 위한 메모리가 부족.</td>
      </tr>
      <tr>
          <td>③ 실시간성이 요구되는 작업 불가능</td>
          <td>pipeline bubble의 불규칙성으로 실시간 작업(real-time inference 등)은 불가능</td>
      </tr>
  </tbody>
</table>
<hr>
<h2 id="-위-한계를-극복하기-위한-최근-연구-흐름-및-방법론">🚧 위 한계를 극복하기 위한 최근 연구 흐름 및 방법론</h2>
<p>이러한 한계를 극복하기 위한 최근의 연구는 다음의 흐름들로 진행되고 있습니다.</p>
<h2 id="--짧은-버블에-대한-효율적-대응-연구">📌 ① 짧은 버블에 대한 효율적 대응 연구</h2>
<p>짧은 pipeline bubble을 효율적으로 활용하기 위한 연구가 활발히 이루어지고 있습니다.</p>
<h3 id="-최근-연구-흐름-및-방법">💡 최근 연구 흐름 및 방법:</h3>
<ul>
<li>
<p><strong>모델 최적화 및 경량화 (Model Optimization &amp; Compression)</strong></p>
<ul>
<li>Quantization(양자화), Pruning(가지치기), Distillation(지식 증류) 등을 통한 fill job 모델 경량화로 짧은 시간 내 빠르게 실행.</li>
<li>예시 연구:
<ul>
<li>『TinyML』연구 흐름: 초소형 모델을 GPU idle 시간에 빠르게 처리 가능</li>
<li>MobileNet, EfficientNet 계열 경량화 모델 적극 활용.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Lightweight Context Switching 기술 개발</strong></p>
<ul>
<li>GPU kernel-level switching, low-latency checkpointing 기술을 통해 overhead 감소.</li>
<li>예시 연구:
<ul>
<li>『REEF (USENIX'22)』 논문에서 microsecond-scale GPU kernel-level context switching 제공</li>
<li>커널 단위로 context를 빠르게 저장/복원할 수 있는 시스템 연구</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>미세입자화된 Task Scheduling (Fine-grained Task Scheduling)</strong></p>
<ul>
<li>pipeline bubble 내부에서도 micro-bubble을 잘게 쪼개 작업 배치 및 context switching 전략을 최적화하는 방법.</li>
<li>예시 연구:
<ul>
<li>『Salus (Yu, 2019)』, GPU의 idle 시간을 극소 단위로 쪼개어 더 작은 작업 배치 전략 수행.</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="--gpu-메모리-제한-해결을-위한-연구">📌 ② GPU 메모리 제한 해결을 위한 연구</h2>
<p>메모리 부족 문제를 해결하기 위한 최근 연구 흐름은 GPU 외부 메모리를 적극 활용하는 방향으로 진행됩니다.</p>
<h3 id="-최근-연구-흐름-및-방법-1">💡 최근 연구 흐름 및 방법:</h3>
<ul>
<li>
<p><strong>CPU 메모리 Offloading 연구</strong></p>
<ul>
<li>optimizer states, activations 등을 CPU RAM에 offload하여 GPU 메모리를 확보하는 연구.</li>
<li>예시 연구:
<ul>
<li>『ZeRO-Offload (Microsoft DeepSpeed)』, CPU 메모리 offload 전략을 통해 GPU 메모리를 효율적으로 확보</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>NVMe Offloading 기술 연구</strong></p>
<ul>
<li>고성능 SSD(NVMe)를 사용하여 GPU 메모리를 추가 확보하는 기술로 대용량 모델 처리</li>
<li>예시 연구:
<ul>
<li>『ZeRO-Infinity』(Rajbhandari et al.)와 같이 NVMe storage를 활용해 GPU 메모리를 크게 확장 가능</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>GPU 내 메모리 압축(Compression) 기술</strong></p>
<ul>
<li>모델의 activation, gradient 등을 실시간으로 압축하여 GPU 메모리 사용량 축소</li>
<li>예시 연구:
<ul>
<li>『ACTNN (Activation Compressed Training Neural Networks)』, activation 압축으로 GPU 메모리 사용량 감소</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="--실시간-작업real-time-task-처리를-위한-연구">📌 ③ 실시간 작업(real-time task) 처리를 위한 연구</h2>
<p>Pipeline bubble의 불규칙성을 극복하여 실시간 작업을 처리하기 위한 연구들이 나타나고 있습니다.</p>
<h3 id="-최근-연구-흐름-및-방법-2">💡 최근 연구 흐름 및 방법:</h3>
<ul>
<li>
<p><strong>예측 기반 Scheduling (Predictive Scheduling)</strong></p>
<ul>
<li>버블 발생 시간을 미리 예측하여 real-time inference 작업을 미리 준비하는 기술</li>
<li>예시 연구:
<ul>
<li>『PipeSwitch』(OSDI, 2020): GPU idle 시점을 예측하고 미리 작업 준비, real-time inference 가능성 탐구</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Adaptive &amp; Dynamic Scheduling</strong></p>
<ul>
<li>실시간으로 pipeline 상황을 모니터링하며 유동적으로 작업을 스케줄링하여 버블 예측 불확실성을 해결하는 방법</li>
<li>예시 연구:
<ul>
<li>『AntMan』(OSDI, 2020): 실시간 GPU idle 자원 탐지 및 동적 job scheduling 제공</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>낮은 지연시간(Low Latency) 작업 처리 기술</strong></p>
<ul>
<li>버블의 시작 시점을 최대한 빠르게 인식하고 작업을 빠르게 시작하여 실시간 작업을 가능케 하는 연구</li>
<li>예시 연구:
<ul>
<li>『FlashAttention』과 같은 효율적이고 빠른 GPU 커널로 낮은 latency 작업 처리 가능성 향상</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="-제안하는-통합-연구-흐름-및-해결-방안-제안">🎯 제안하는 통합 연구 흐름 및 해결 방안 제안</h2>
<p>위의 개별적인 방법론을 종합하여 한계를 극복하기 위한 구체적인 연구 흐름을 다음과 같이 제안합니다.</p>
<table>
  <thead>
      <tr>
          <th>문제점</th>
          <th>해결 전략</th>
          <th>예시 적용 연구방법</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>짧은 버블 비효율성</td>
          <td>모델 경량화, 빠른 context 전환</td>
          <td>TinyML, EfficientNet, REEF, Salus</td>
      </tr>
      <tr>
          <td>GPU 메모리 제한</td>
          <td>메모리 Offload 및 압축기술</td>
          <td>ZeRO-Offload, ZeRO-Infinity, ACTNN</td>
      </tr>
      <tr>
          <td>실시간 작업 불가능성</td>
          <td>예측기반, 동적 Scheduling 기술</td>
          <td>PipeSwitch, AntMan, FlashAttention</td>
      </tr>
  </tbody>
</table>
<ul>
<li>통합된 연구의 예시적 흐름:
<ol>
<li>버블의 시작과 길이를 정확하게 예측하여 (Predictive scheduling),</li>
<li>예측된 짧은 버블을 이용할 때는 경량화된 모델을 빠른 context 전환 기술로 투입하고,</li>
<li>예측된 긴 버블은 CPU/NVMe offloading 기술로 메모리를 확보해 무거운 작업을 수행하는 <strong>Adaptive 방식의 통합 연구</strong>가 필요합니다.</li>
</ol>
</li>
</ul>
<hr>
<h2 id="-결론적-평가">✨ 결론적 평가</h2>
<p>『PipeFill』의 한계를 극복하기 위한 최근 연구 흐름은:</p>
<ul>
<li><strong>짧은 버블 대응을 위한 모델 최적화 및 빠른 Context switching 연구</strong></li>
<li><strong>GPU 메모리 확보를 위한 Offloading 및 압축 기술 연구</strong></li>
<li><strong>실시간 작업 처리를 위한 예측 및 Adaptive Scheduling 연구</strong></li>
</ul>
<p>등 다양한 분야에서 활발히 진행 중이며, 이러한 기술들의 통합적 활용과 연구가 향후 PipeFill의 한계를 극복하고 더욱 뛰어난 GPU 활용을 가능케 할 것입니다.</p>
<h1 id="q--pipefill이-짧은-파이프라인-버블에서는-효율성이-떨어지는-이유가-무엇이며-이-문제를-해결하기-위해-어떤-방법론을-추가로-고려할-수-있을까">Q : PipeFill이 짧은 파이프라인 버블에서는 효율성이 떨어지는 이유가 무엇이며, 이 문제를 해결하기 위해 어떤 방법론을 추가로 고려할 수 있을까?</h1>
<p>PipeFill이 짧은 파이프라인 버블에서 효율성이 떨어지는 이유는 다음과 같은 세 가지 주요 원인으로 정리할 수 있습니다.</p>
<ol>
<li>
<p><strong>Context Switching 오버헤드</strong>:
짧은 버블에서는 작업을 시작하고 종료하기 위한 context switching 비용(작업의 상태 저장 및 복원 등)이 버블 시간 대비 상대적으로 커집니다. 예컨대, 10ms 미만의 매우 짧은 버블에서는 상태를 저장하고 불러오는 시간 자체가 버블 시간의 많은 부분을 차지할 수 있습니다.</p>
</li>
<li>
<p><strong>GPU 작업 초기화 비용</strong>:
GPU 커널 작업을 시작하는 과정에서 발생하는 초기화 비용이 있는데, 짧은 버블에서는 이 비용이 GPU에서 실제로 연산되는 시간과 비슷한 규모로 커지게 되어 효율이 떨어질 수 있습니다.</p>
</li>
<li>
<p><strong>메모리 제약으로 인한 제한적 Batch 크기</strong>:
짧은 버블에서는 작업의 크기나 배치를 늘려 GPU 활용도를 높이는 게 어렵습니다. 제한된 메모리 공간에 너무 작은 Batch를 투입하면 GPU 자원을 충분히 활용하지 못하고 낮은 병렬성만 가지게 되어, 효율이 급감합니다.</p>
</li>
</ol>
<p>이러한 문제들을 해결하고 PipeFill의 효율성을 짧은 버블에서도 높이기 위한 방법론은 다음과 같습니다.</p>
<ol>
<li>
<p>경량화 모델을 이용한 Fast-Fill 전략:
짧은 버블에서는 최대한 가벼운 작업을 실행하여 context switching 오버헤드를 최소화할 수 있습니다. MobileNet, EfficientNet 등 가벼운 모델을 양자화나 pruning 기법을 통해 추가적으로 경량화하여 짧은 시간에 즉각적으로 실행이 가능하게 하는 것입니다.</p>
</li>
<li>
<p>GPU 커널의 Fast Context Switching 기술 개발:
GPU의 Kernel-level Preemption이나 빠른 Checkpoint/Restore 기술을 연구하여 작업의 상태를 거의 즉각적으로 저장 및 복구할 수 있게 만듦으로써 context switching 비용을 획기적으로 낮추는 기술적 방법론이 필요합니다. 실제로 최근 USENIX 논문들(예: REEF)에서는 GPU 작업 단위의 매우 빠른 전환 기술을 제공하여 초단위 미만의 짧은 작업에서도 높은 효율성을 확보했습니다.</p>
</li>
<li>
<p>미세입자화된 Task Scheduling 방법:
버블을 더욱 세분화하여 아주 작은 크기의 micro-task 단위로 처리하고, 각 Task가 거의 독립적으로 작동하게 하는 방법입니다. 이렇게 하면 context switching 부담이 감소하고 GPU의 idle time을 좀 더 효율적으로 활용할 수 있습니다. 대표적으로 ‘Salus’ 등의 연구는 GPU 자원을 더 세부적인 단위로 분할하여 효율성을 높인 바 있습니다.</p>
</li>
<li>
<p>CPU/NVMe Offloading과 메모리 최적화:
짧은 버블을 활용하기 위해 메모리 최적화를 더욱 심도 있게 추진하고, 작은 시간에도 GPU가 바로 작업에 들어갈 수 있도록 메모리의 빠른 준비(offloading)를 적극적으로 활용해야 합니다. 예를 들어, NVMe 스토리지나 고성능 CPU-RAM을 사용하여 GPU 메모리를 더욱 빠르게 준비시키는 Zero-Infinity, ZeRO-Offload 등의 최신 기술을 활용할 수 있습니다.</p>
</li>
<li>
<p>미리 예측하고 준비하는 Predictive Scheduling 기법:
짧은 버블이 시작하기 전에 미리 정확하게 예측하여, GPU가 즉각적으로 작업을 시작할 수 있도록 작업을 사전 로딩(Pre-loading)하여 준비시킵니다. 이러한 Predictive Scheduling 기법은 PipeSwitch 등의 연구에서 일부 다루어졌습니다.</p>
</li>
</ol>
<p>결과적으로, PipeFill이 짧은 버블에서도 효율적으로 작동하기 위해서는 ‘모델의 초경량화’, ‘초고속 context 전환 기술 개발’, ‘미세입자화된 scheduling 전략’, ‘적극적 메모리 Offloading 기술’, ‘버블 예측 기반 Scheduling’과 같은 복합적인 접근법을 추가적으로 고려할 필요가 있습니다. 이러한 방식의 연구를 통해 짧은 버블 상황에서도 GPU 자원을 최대한 활용할 수 있는 효율적인 구조가 구축될 수 있을 것입니다.</p>
<h1 id="q-메모리-제약이-pipefill의-gpu-활용률-향상에-미치는-구체적인-영향은-무엇이며-이-문제를-완화하기-위해-논문에서-사용한-기술-외에-다른-유망한-기술은-무엇이-있을까">Q: 메모리 제약이 PipeFill의 GPU 활용률 향상에 미치는 구체적인 영향은 무엇이며, 이 문제를 완화하기 위해 논문에서 사용한 기술 외에 다른 유망한 기술은 무엇이 있을까?</h1>
<p>메모리 제약이 PipeFill의 GPU 활용률 향상에 미치는 구체적인 영향은 크게 다음 세 가지로 요약할 수 있습니다.</p>
<ol>
<li>
<p><strong>작업 크기 제한으로 인한 GPU 병렬성 감소</strong><br>
PipeFill이 활용하는 추가 작업(fill job)은 주 작업(LLM training)이 GPU 메모리의 대부분을 점유하고 있기 때문에, 추가 작업은 제한된 메모리만 사용 가능합니다.<br>
이러한 메모리 제한은 한 번에 처리할 수 있는 batch 크기를 매우 작게 제한하여, GPU의 병렬 연산 능력을 충분히 활용하지 못하게 합니다. 결과적으로 GPU의 실질적인 사용률(TFLOPS)이 낮아집니다.</p>
</li>
<li>
<p><strong>Offloading으로 인한 높은 Latency 및 추가 Overhead 발생</strong><br>
GPU 메모리가 부족하면 논문에서 제시한 방식대로 CPU나 SSD와 같은 보조 장치로 데이터를 Offloading하게 됩니다. 하지만 이 경우 CPU 메모리에서 GPU로 데이터를 전송하는 과정에서 latency가 발생하고, 데이터 이동 자체가 GPU 연산에 병목(bottleneck)으로 작용하여 실질적인 GPU 효율이 저하됩니다.</p>
</li>
<li>
<p><strong>실행 가능한 작업의 제한</strong><br>
메모리 제약으로 인해 GPU 메모리 사용량이 큰 모델이나 training 작업은 실행이 어려워지며, 메모리 footprint가 작은 inference 작업 위주로만 제한적으로 사용 가능하게 됩니다. 이로 인해 전체 GPU 활용률 상승 효과가 제한될 수 있습니다.</p>
</li>
</ol>
<hr>
<p>이러한 메모리 제약 문제를 완화하기 위해, 논문에서 사용한 **CPU Offloading (예: ZeRO-Offload, ZeRO-Infinity)**과 <strong>activation checkpointing</strong> 기술 외에 최근 연구에서 제안하는 유망한 기술들은 다음과 같습니다.</p>
<h3 id="-1-activation-compression-activation-압축기술">✅ <strong>1. Activation Compression (Activation 압축기술)</strong></h3>
<ul>
<li><strong>기술 설명</strong>: GPU에서 Activation(활성화 데이터)은 모델 학습에서 큰 메모리를 차지합니다. 최근에는 Activation을 압축하여 GPU 메모리 사용량을 대폭 줄이는 기술이 활발히 연구되고 있습니다.</li>
<li><strong>대표 연구사례</strong>:
<ul>
<li><strong>ACTNN (Activation Compressed Training Neural Networks)</strong>: Activation을 최대 4배까지 압축하여 GPU 메모리 사용량을 크게 감소시키는 기술입니다. 압축 알고리즘을 이용해 activation을 실시간 압축/해제하여 메모리 footprint를 크게 절감합니다.</li>
</ul>
</li>
</ul>
<h3 id="-2-gradient-compression-gradient-압축기술">✅ <strong>2. Gradient Compression (Gradient 압축기술)</strong></h3>
<ul>
<li><strong>기술 설명</strong>: GPU에서 backward pass 시 발생하는 gradient 또한 메모리를 많이 차지합니다. gradient를 압축하여 GPU 메모리를 줄이고 통신량을 절약하는 방법이 존재합니다.</li>
<li><strong>대표 연구사례</strong>:
<ul>
<li><strong>Deep Gradient Compression (DGC)</strong>, <strong>Gradient Quantization</strong> 기술: gradient를 quantization하거나, 낮은 정밀도로 압축하여 GPU 메모리 사용량을 크게 낮춥니다.</li>
</ul>
</li>
</ul>
<h3 id="-3-gpu-memory-virtualization-gpu-메모리-가상화">✅ <strong>3. GPU Memory Virtualization (GPU 메모리 가상화)</strong></h3>
<ul>
<li><strong>기술 설명</strong>: GPU 메모리를 가상화하여 GPU의 물리적인 메모리 크기 이상으로 데이터를 관리할 수 있는 기법입니다.</li>
<li><strong>대표 연구사례</strong>:
<ul>
<li><strong>vDNN (Virtualized Deep Neural Networks)</strong>: GPU에서 사용하지 않는 데이터를 CPU로 동적으로 swap-in/swap-out 하며 GPU 메모리를 효율적으로 관리합니다.</li>
<li>NVIDIA의 Unified Virtual Memory (UVM)와 같은 시스템 수준의 접근도 가능하며, 최근 연구들은 이런 기술을 최적화해 GPU 메모리 제약을 완화하고 있습니다.</li>
</ul>
</li>
</ul>
<h3 id="-4-nvme-ssd-offloading-기술-스토리지-기반-offloading">✅ <strong>4. NVMe SSD Offloading 기술 (스토리지 기반 Offloading)</strong></h3>
<ul>
<li><strong>기술 설명</strong>: GPU 메모리 부족 문제를 해결하기 위해 최근에는 초고속 NVMe SSD 스토리지로 데이터를 offload하여 GPU 메모리를 실질적으로 확장하는 방법도 있습니다.</li>
<li><strong>대표 연구사례</strong>:
<ul>
<li><strong>ZeRO-Infinity (Microsoft DeepSpeed)</strong>: NVMe 스토리지로 모델의 파라미터, optimizer state, gradient 등을 offload하여 GPU 메모리를 수십 배 확장할 수 있습니다. 이 기술은 모델 크기나 병렬성을 크게 확장할 수 있습니다.</li>
</ul>
</li>
</ul>
<h3 id="-5-model-parameter-sharing--slimming-모델-파라미터-공유-및-축소-기술">✅ <strong>5. Model Parameter Sharing / Slimming (모델 파라미터 공유 및 축소 기술)</strong></h3>
<ul>
<li><strong>기술 설명</strong>: 파라미터를 공유하거나 중복되는 파라미터를 제거하여 메모리 footprint를 줄이는 기술입니다.</li>
<li><strong>대표 연구사례</strong>:
<ul>
<li><strong>ALBERT 모델</strong>: Transformer에서 Parameter sharing을 통해 메모리 footprint를 기존 모델 대비 10배 이상 줄이는 데 성공했습니다.</li>
<li><strong>Structured Pruning</strong> 기술: 구조적인 pruning을 통해 불필요한 파라미터를 제거하여 GPU 메모리 footprint를 줄일 수 있습니다.</li>
</ul>
</li>
</ul>
<h3 id="-6-hybrid-memory-systems-hbm--dram--ssd-결합">✅ <strong>6. Hybrid Memory Systems (HBM + DRAM + SSD 결합)</strong></h3>
<ul>
<li><strong>기술 설명</strong>: GPU 메모리와 CPU 메모리, SSD 스토리지를 하나의 메모리 시스템으로 보고, 데이터 접근 빈도에 따라 자동으로 계층화하여 관리하는 기술입니다.</li>
<li><strong>대표 연구사례</strong>:
<ul>
<li><strong>TensorStore (Google)</strong>, <strong>Hierarchical Memory Management</strong> 연구: 최근 GPU 클러스터에서는 데이터 접근 빈도에 따라 자동으로 SSD→CPU→GPU로 데이터를 배치하여 최적화합니다.</li>
</ul>
</li>
</ul>
<hr>
<h2 id="-결론적으로-정리하면">🎯 결론적으로 정리하면:</h2>
<table>
  <thead>
      <tr>
          <th>메모리 문제 영향 요약</th>
          <th>관련 유망한 기술</th>
          <th>대표적 사례</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Batch 크기 제한으로 GPU 활용률 감소</td>
          <td>Activation / Gradient 압축기술</td>
          <td>ACTNN, DGC</td>
      </tr>
      <tr>
          <td>CPU Offloading Latency로 인한 저하</td>
          <td>GPU 메모리 가상화 기술</td>
          <td>vDNN, UVM</td>
      </tr>
      <tr>
          <td>무거운 모델 실행 불가능</td>
          <td>NVMe SSD Offloading, Hybrid Memory 시스템</td>
          <td>ZeRO-Infinity, TensorStore</td>
      </tr>
      <tr>
          <td>한정된 메모리 내 효율적 모델 실행</td>
          <td>Model Parameter Sharing &amp; Pruning</td>
          <td>ALBERT, Structured Pruning</td>
      </tr>
  </tbody>
</table>
<p>이러한 다양한 기술적 접근을 통해 GPU 메모리 제약 문제를 완화하면 PipeFill의 추가 작업(fill job)이 더욱 큰 Batch 크기와 높은 병렬성을 활용하여, 더욱 높은 GPU 활용률 상승을 달성할 수 있을 것입니다.</p>
<h1 id="q-pipefill에서-독립된-작업fill-job을-선택하고-스케줄링할-때-작업-특성예-모델-크기-inferencetraining-여부-등에-따라-성능이-어떻게-달라지는지-자세히-설명해줄-수-있을까">Q: PipeFill에서 독립된 작업(fill job)을 선택하고 스케줄링할 때, 작업 특성(예: 모델 크기, inference/training 여부 등)에 따라 성능이 어떻게 달라지는지 자세히 설명해줄 수 있을까?</h1>
<p>PipeFill에서 독립된 추가 작업(fill job)을 선택하고 스케줄링할 때, 작업의 특성에 따라 성능이 크게 달라집니다. 논문과 GPU 병렬처리 구조의 특성을 바탕으로, 작업의 특성에 따라 성능이 구체적으로 어떻게 달라지는지 항목별로 자세히 설명해드리겠습니다.</p>
<hr>
<h2 id="-1-모델-크기-parameter-수-메모리-footprint에-따른-성능-차이">📌 1. 모델 크기 (Parameter 수, 메모리 footprint)에 따른 성능 차이</h2>
<ul>
<li>
<p><strong>작은 모델 (예: EfficientNet, BERT-base)</strong></p>
<ul>
<li>장점: GPU 메모리 사용량이 적어 작은 pipeline bubble에서도 더 큰 batch size로 실행이 가능합니다. 작은 버블이라도 활용이 쉽고, context switching 비용이 상대적으로 낮아 GPU 활용률이 높아질 수 있습니다.</li>
<li>단점: GPU의 높은 연산능력 대비 연산량이 충분하지 않아 GPU가 최대로 활용되지 않을 수 있습니다.</li>
</ul>
</li>
<li>
<p><strong>중간 크기 모델 (예: BERT-large, Swin-large)</strong></p>
<ul>
<li>장점: GPU 메모리 점유율과 연산량 간의 균형이 적절하여 GPU 병렬성을 최대한 활용하면서도 버블 내에 잘 분할하여 실행 가능합니다.</li>
<li>단점: 모델에 따라 activation 크기 및 메모리 footprint가 크다면, batch size가 제한될 가능성이 높습니다.</li>
</ul>
</li>
<li>
<p><strong>큰 모델 (예: XLM-Roberta-XL, GPT 계열의 큰 모델)</strong></p>
<ul>
<li>장점: 연산량이 크기 때문에 GPU 연산 자원을 매우 효율적으로 활용할 수 있으며, 특히 긴 버블에서는 큰 성능 향상을 얻을 수 있습니다.</li>
<li>단점: activation, gradient, optimizer state가 큰 메모리를 점유하여 GPU 메모리 부족으로 CPU/NVMe로 offloading이 필수적이며, 이로 인해 짧은 버블에서는 오히려 context switching 비용 증가 및 데이터 전송 overhead가 발생하여 성능 저하 가능성이 높습니다.</li>
</ul>
</li>
</ul>
<table>
  <thead>
      <tr>
          <th>모델 크기</th>
          <th>GPU 병렬성 활용도</th>
          <th>메모리 사용량</th>
          <th>GPU 활용률 (짧은 버블)</th>
          <th>GPU 활용률 (긴 버블)</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>작음 (EfficientNet)</td>
          <td>중간</td>
          <td>낮음</td>
          <td>높음</td>
          <td>중간</td>
      </tr>
      <tr>
          <td>중간 (BERT-large)</td>
          <td>높음</td>
          <td>중간</td>
          <td>중간~높음</td>
          <td>높음</td>
      </tr>
      <tr>
          <td>큼 (XLM-R XL)</td>
          <td>매우 높음</td>
          <td>높음</td>
          <td>낮음</td>
          <td>매우 높음</td>
      </tr>
  </tbody>
</table>
<hr>
<h2 id="-2-작업-유형inference-vs-training에-따른-성능-차이">📌 2. 작업 유형(Inference vs. Training)에 따른 성능 차이</h2>
<ul>
<li>
<p><strong>Batch Inference 작업</strong></p>
<ul>
<li>장점:
<ul>
<li>메모리 사용량이 낮고, activation, gradient 저장이 필요 없어 batch size를 더욱 크게 설정할 수 있습니다.</li>
<li>context switching이 상대적으로 가볍고 빠르게 가능해 짧은 버블에서도 효율적으로 처리 가능합니다.</li>
<li>overhead가 적고 GPU utilization을 최대한 활용할 수 있습니다.</li>
</ul>
</li>
<li>단점:
<ul>
<li>연산량이 Training 대비 상대적으로 작기 때문에, 너무 가벼운 작업만 투입하면 GPU 자원의 최대 효율을 이끌어내지 못할 가능성이 있습니다.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Training 작업</strong></p>
<ul>
<li>장점:
<ul>
<li>연산량이 많아 GPU 병렬성 및 연산 자원을 더욱 효율적으로 활용 가능합니다.</li>
<li>긴 버블에서는 GPU 활용률을 대폭 증가시킬 수 있습니다.</li>
</ul>
</li>
<li>단점:
<ul>
<li>optimizer states, gradients, activations 등 GPU 메모리 요구량이 많아 짧은 버블에서는 overhead 증가 및 성능 저하가 발생할 수 있습니다.</li>
<li>context switching 과정에서 state를 저장/복구해야 하므로 context switching 비용이 큽니다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<table>
  <thead>
      <tr>
          <th>작업 유형</th>
          <th>GPU 병렬성</th>
          <th>메모리 사용량</th>
          <th>context switching 비용</th>
          <th>GPU 활용률 (짧은 버블)</th>
          <th>GPU 활용률 (긴 버블)</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Batch Inference</td>
          <td>중간</td>
          <td>낮음</td>
          <td>낮음</td>
          <td>높음</td>
          <td>중간</td>
      </tr>
      <tr>
          <td>Training</td>
          <td>높음</td>
          <td>높음</td>
          <td>높음</td>
          <td>낮음</td>
          <td>높음</td>
      </tr>
  </tbody>
</table>
<hr>
<h2 id="-3-작업의-gpu-메모리-접근-패턴-및-연산-강도intensity에-따른-성능-차이">📌 3. 작업의 GPU 메모리 접근 패턴 및 연산 강도(Intensity)에 따른 성능 차이</h2>
<ul>
<li>
<p><strong>Compute-intensive 작업 (계산 중심)</strong></p>
<ul>
<li>예: Transformer Attention 연산 (BERT, GPT 계열 inference)</li>
<li>GPU의 TFLOPS를 최대한 활용할 수 있어 GPU 활용률이 매우 높습니다.</li>
<li>특히, 긴 버블에서 GPU utilization을 극대화할 수 있습니다.</li>
</ul>
</li>
<li>
<p><strong>Memory-intensive 작업 (메모리 접근 중심)</strong></p>
<ul>
<li>예: CNN 모델 (EfficientNet), vision transformer (Swin transformer)</li>
<li>메모리 접근이 많아 GPU 메모리 대역폭 병목이 발생하고, context switching이나 offloading 과정에서 GPU 활용률이 상대적으로 떨어질 수 있습니다.</li>
<li>버블 길이에 따라 효율성 차이가 매우 크게 나타납니다. (짧은 버블에서는 overhead 높음)</li>
</ul>
</li>
</ul>
<table>
  <thead>
      <tr>
          <th>작업 패턴</th>
          <th>GPU 연산 활용도</th>
          <th>메모리 접근 overhead</th>
          <th>GPU 활용률 (짧은 버블)</th>
          <th>GPU 활용률 (긴 버블)</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Compute-intensive (Transformer inference)</td>
          <td>매우 높음</td>
          <td>낮음</td>
          <td>중간~높음</td>
          <td>매우 높음</td>
      </tr>
      <tr>
          <td>Memory-intensive (CNN 모델)</td>
          <td>중간~낮음</td>
          <td>매우 높음</td>
          <td>낮음</td>
          <td>중간</td>
      </tr>
  </tbody>
</table>
<hr>
<h2 id="-결론적-종합-분석-및-추천-전략">📌 결론적 종합 분석 및 추천 전략</h2>
<p>PipeFill의 성능을 최대로 높이기 위해서는 다음과 같은 전략을 권장합니다.</p>
<ul>
<li>
<p><strong>짧은 버블</strong>: 메모리 footprint가 낮고 context switching 비용이 적은 <strong>작고 가벼운 inference 작업</strong> 위주로 선택하면 GPU 활용률을 최대로 높일 수 있습니다.</p>
</li>
<li>
<p><strong>긴 버블</strong>: 연산량이 크고 GPU 자원을 최대한 활용할 수 있는 <strong>큰 모델의 inference 또는 중간 크기의 모델 training 작업</strong>을 선택하면 GPU 활용률을 극대화할 수 있습니다.</p>
</li>
</ul>
<p>결과적으로 fill job의 모델 크기, 작업 유형(inference/training 여부), 메모리 접근 패턴(compute vs. memory intensive)에 따라 성능이 달라지며, 이를 파악하고 적절한 작업을 선택해 배치하는 것이 PipeFill의 전체적인 GPU 효율을 높이는 핵심 전략입니다.</p>

  </article>

  
  
  <div class="post-license bg-muted/30 border-border mb-8 rounded-xl border p-6">
    <div class="flex items-start gap-4">
      <div
        class="bg-primary/10 flex h-12 w-12 flex-shrink-0 items-center justify-center rounded-lg">
        
  <svg class="h-6 w-6"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="라이선스"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m5.618-4.016A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.04A12.02 12.02 0 003 9c0 5.591 3.824 10.29 9 11.622 5.176-1.332 9-6.03 9-11.622 0-1.042-.133-2.052-.382-3.016z" />
</svg>
      </div>

      <div class="flex-1">
        <h3 class="text-foreground mb-2 text-lg font-semibold">
          라이선스
        </h3>

        <div class="text-muted-foreground space-y-2 text-sm">
          
          <p>
            <strong>저작자:</strong>
            류재훈
          </p>
          

          <p>
            <strong>링크:</strong>
            <a
              href="http://192.168.1.11:1314/posts/PipeFill-Using-GPUs-During-Bubbles-in-Pipeline-parallel-LLM-Training/"
              class="text-primary hover:text-primary/80 transition-colors duration-200">
              http://192.168.1.11:1314/posts/PipeFill-Using-GPUs-During-Bubbles-in-Pipeline-parallel-LLM-Training/
            </a>
          </p>

          <p>
            <strong>라이선스:</strong>
            <a
              href="https://creativecommons.org/licenses/by-nc-sa/4.0/"
              target="_blank"
              rel="noopener noreferrer"
              class="text-primary hover:text-primary/80 transition-colors duration-200">
              CC BY-NC-SA 4.0
            </a>
          </p>

          <p class="text-xs">
            이 저작물은 크리에이티브 커먼즈 저작자표시-비영리-동일조건변경허락 4.0 국제 라이선스에 따라 이용할 수 있습니다. 출처를 표시하고, 비영리 목적으로만 사용하며, 동일한 라이선스를 유지해야 합니다.
          </p>
        </div>
      </div>
    </div>
  </div>


  
  





  <nav
    class="post-navigation mb-12"
    aria-label="게시글 네비게이션">
    <div class="grid grid-cols-1 gap-4 md:grid-cols-2">
      
      <div class="nav-item">
        
          <a
            href="/posts/SELF-DATA-DISTILLATION-FOR-RECOVERING-QUALITY-IN-PRUNED-LARGE-LANGUAGE-MODELS/"
            class="group bg-card border-border hover:bg-primary/5 hover:border-primary/20 focus:ring-primary/20 flex min-h-[140px] flex-col justify-between rounded-xl border p-6 transition-all duration-300 ease-out hover:-translate-y-1 hover:scale-[1.02] hover:shadow-lg focus:ring-2 focus:outline-none">
            <div>
              <div class="mb-3 flex items-center gap-3">
                
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" />
</svg>
                <span class="text-muted-foreground text-sm font-medium">
                  이전
                </span>
              </div>

              <h3
                class="text-foreground group-hover:text-primary mb-3 line-clamp-2 text-lg leading-tight font-semibold transition-colors duration-200">
                SELF-DATA DISTILLATION FOR RECOVERING QUALITY IN PRUNED LARGE LANGUAGE MODELS
              </h3>
            </div>

            <div
              class="text-muted-foreground mt-auto flex items-center gap-2 text-xs">
              
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z" />
</svg>
              <time datetime="2025-03-25">
                03月25日
              </time>
            </div>
          </a>
        
      </div>

      
      <div class="nav-item">
        
          <a
            href="/posts/NEO-Saving-GPU-Memory-Crisis-with-CPU-Offloading-for-Online-LLM-Inference/"
            class="group bg-card border-border hover:bg-primary/5 hover:border-primary/20 focus:ring-primary/20 flex min-h-[140px] flex-col justify-between rounded-xl border p-6 transition-all duration-300 ease-out hover:-translate-y-1 hover:scale-[1.02] hover:shadow-lg focus:ring-2 focus:outline-none">
            <div>
              <div class="mb-3 flex items-center justify-end gap-3">
                <span class="text-muted-foreground text-sm font-medium">
                  다음
                </span>
                
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
</svg>
              </div>

              <h3
                class="text-foreground group-hover:text-primary mb-3 line-clamp-2 text-right text-lg leading-tight font-semibold transition-colors duration-200">
                NEO: Saving GPU Memory Crisis with CPU Offloading for Online LLM Inference
              </h3>
            </div>

            <div
              class="text-muted-foreground mt-auto flex items-center justify-end gap-2 text-xs">
              <time datetime="2025-03-31">
                03月31日
              </time>
              
  <svg class="h-3 w-3"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z" />
</svg>
            </div>
          </a>
        
      </div>
    </div>
  </nav>




  
  










  
  


    </main>

    <footer class="mx-auto max-w-4xl px-4 py-8">
  <div class="px-6 py-6">
    
    
      <nav class="mb-6">
        <div class="flex flex-wrap items-center justify-center gap-1">
          
            
            
            
            <a
              href="/index.xml"
              
              class="nav-link hover:text-primary hover:bg-primary/10 text-muted-foreground flex items-center gap-2 rounded-lg px-4 py-2 text-sm font-medium transition-all duration-300 hover:scale-105">
              
                
  <svg class="h-5 w-5"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="RSS Feed">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 5c7.18 0 13 5.82 13 13M6 11a7 7 0 017 7m-6 0a1 1 0 11-2 0 1 1 0 012 0z" />

</svg>
              
              <span
                >
                  RSS Feed
                </span
              >
            </a>
          
        </div>
      </nav>
    


    
    
      <div class="border-border mb-6 border-t"></div>
    


    
    <div class="flex flex-col items-center justify-between gap-4 md:flex-row">
      
      <div class="text-muted-foreground text-sm">
        <p>
          &copy; 2025 Jaehun&#39;s Blog.
          모든 권리 보유.
        </p>
      </div>

      
      
        <div class="flex items-center gap-3">
          
            <a
              href="https://github.com/ryujaehun"
              
                target="_blank" rel="noopener noreferrer"
              
              class="text-muted-foreground hover:text-primary focus:ring-primary/20 rounded-lg p-1 transition-all duration-300 ease-out hover:scale-110 focus:ring-2 focus:outline-none"
              title="GitHub"
              aria-label="GitHub">
              
                
  <svg class="h-6 w-6"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="GitHub"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path d="M15 22v-4a4.8 4.8 0 0 0-1-3.5c3 0 6-2 6-5.5c.08-1.25-.27-2.48-1-3.5c.28-1.15.28-2.35 0-3.5c0 0-1 0-3 1.5c-2.64-.5-5.36-.5-8 0C6 2 5 2 5 2c-.3 1.15-.3 2.35 0 3.5A5.4 5.4 0 0 0 4 9c0 3.5 3 5.5 6 5.5c-.39.49-.68 1.05-.85 1.65S8.93 17.38 9 18v4"/><path d="M9 18c-4.51 2-5-2-7-2"/></g></svg>
              
            </a>
          
            <a
              href="https://www.linkedin.com/in/jaehunryu/"
              
                target="_blank" rel="noopener noreferrer"
              
              class="text-muted-foreground hover:text-primary focus:ring-primary/20 rounded-lg p-1 transition-all duration-300 ease-out hover:scale-110 focus:ring-2 focus:outline-none"
              title="Linkedin"
              aria-label="Linkedin">
              
                
  <svg class="h-6 w-6"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="Linkedin"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path d="M16 8a6 6 0 0 1 6 6v7h-4v-7a2 2 0 0 0-2-2a2 2 0 0 0-2 2v7h-4v-7a6 6 0 0 1 6-6M2 9h4v12H2z"/><circle cx="4" cy="4" r="2"/></g></svg>
              
            </a>
          
            <a
              href="mailto:jaehunryu@icloud.com"
              
              class="text-muted-foreground hover:text-primary focus:ring-primary/20 rounded-lg p-1 transition-all duration-300 ease-out hover:scale-110 focus:ring-2 focus:outline-none"
              title="Email"
              aria-label="Email">
              
                
  <svg class="h-6 w-6"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24" aria-label="Email">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 8l7.89 5.26a2 2 0 002.22 0L21 8M5 19h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z" />

</svg>
              
            </a>
          
        </div>
      

    </div>
  </div>
</footer>


    
    



<div
  id="dock"
  class="pointer-events-none fixed bottom-4 left-1/2 z-[9999] w-fit -translate-x-1/2 translate-y-24 opacity-0 transition-all duration-300 ease-out sm:right-0 sm:left-0 sm:mx-auto sm:translate-x-0"
  role="toolbar"
  aria-label="바로가기 도구 모음">
  <nav
    class="border-border bg-card/80 scrollbar-hide xs:px-3 xs:py-2 mx-auto flex max-w-[calc(100vw-2rem)] min-w-fit items-center justify-center overflow-x-auto rounded-2xl border px-4 py-3 shadow-lg backdrop-blur-sm sm:px-4 sm:py-3">
    
    
      <button
        id="dock-back"
        class="text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 xs:px-2 xs:py-1.5 flex flex-shrink-0 items-center gap-2 rounded-lg px-3 py-2 text-sm font-medium transition-all duration-300 ease-out hover:-translate-y-0.5 hover:scale-105 focus:ring-2 focus:outline-none sm:px-3 sm:py-2"
        title="뒤로"
        aria-label="뒤로">
        
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24">
  <path d="m12 19-7-7 7-7"/>
  <path d="M19 12H5"/>

</svg>
        <span class="hidden sm:inline"
          >뒤로</span
        >
      </button>

      
      <div class="bg-border xs:mx-1 mx-2 h-6 w-px sm:mx-2"></div>
    


    
    
      <button
        id="dock-toc"
        class="text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 xs:px-2 xs:py-1.5 flex flex-shrink-0 items-center gap-2 rounded-lg px-3 py-2 text-sm font-medium transition-all duration-300 ease-out hover:-translate-y-0.5 hover:scale-105 focus:ring-2 focus:outline-none sm:px-3 sm:py-2"
        title="목차"
        aria-label="목차">
        
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24">
  <line x1="8" x2="21" y1="6" y2="6"/>
  <line x1="8" x2="21" y1="12" y2="12"/>
  <line x1="8" x2="21" y1="18" y2="18"/>
  <line x1="3" x2="3.01" y1="6" y2="6"/>
  <line x1="3" x2="3.01" y1="12" y2="12"/>
  <line x1="3" x2="3.01" y1="18" y2="18"/>

</svg>
        <span class="hidden sm:inline"
          >목차</span
        >
      </button>

      
      <div class="bg-border xs:mx-1 mx-2 h-6 w-px sm:mx-2"></div>
    


    
    <button
      id="dock-search"
      class="text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 xs:px-3 xs:py-1.5 flex flex-shrink-0 items-center gap-2 rounded-lg px-4 py-2 text-sm font-medium transition-all duration-300 ease-out hover:-translate-y-0.5 hover:scale-105 focus:ring-2 focus:outline-none sm:px-4 sm:py-2"
      title="검색"
      aria-label="검색">
      
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="m21 21-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />

</svg>
      <span class="hidden md:inline"
        >검색</span
      >
    </button>

    
    <div class="bg-border xs:mx-1 mx-2 h-6 w-px sm:mx-2"></div>

    
    
    


    
    <button
      id="dock-top"
      class="text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 xs:px-2 xs:py-1.5 flex flex-shrink-0 items-center gap-2 rounded-lg px-3 py-2 text-sm font-medium transition-all duration-300 ease-out hover:-translate-y-0.5 hover:scale-105 focus:ring-2 focus:outline-none sm:px-3 sm:py-2"
      title="맨 위로"
      aria-label="맨 위로">
      
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24">
  <path d="m18 15-6-6-6 6"/>

</svg>
      <span class="hidden sm:inline"
        >맨 위로</span
      >
    </button>
  </nav>
</div>


    
      



<div
  id="toc-overlay"
  class="pointer-events-none fixed inset-0 z-40 bg-black/50 opacity-0 backdrop-blur-sm transition-all duration-300"
  role="dialog"
  aria-modal="true"
  aria-labelledby="toc-title"></div>


<div
  id="toc-card"
  class="pointer-events-none fixed inset-4 z-50 flex w-auto scale-95 items-center justify-center opacity-0 transition-all duration-300 sm:inset-auto sm:top-1/2 sm:left-1/2 sm:block sm:w-full sm:max-w-md sm:-translate-x-1/2 sm:-translate-y-1/2"
  role="dialog"
  aria-modal="true"
  aria-labelledby="toc-title">
  <div
    class="bg-card border-border w-full max-w-sm overflow-hidden rounded-xl border shadow-xl sm:max-w-md">
    
    <div
      class="border-border bg-muted/30 flex items-center justify-between border-b p-4">
      <div class="flex items-center gap-3">
        
  <svg class="h-5 w-5"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24">
  <line x1="8" x2="21" y1="6" y2="6"/>
  <line x1="8" x2="21" y1="12" y2="12"/>
  <line x1="8" x2="21" y1="18" y2="18"/>
  <line x1="3" x2="3.01" y1="6" y2="6"/>
  <line x1="3" x2="3.01" y1="12" y2="12"/>
  <line x1="3" x2="3.01" y1="18" y2="18"/>

</svg>
        <h2 id="toc-title" class="text-foreground text-lg font-semibold">
          목차
        </h2>
      </div>

      
      <button
        id="toc-close"
        class="text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 rounded-lg p-2 transition-all duration-200 ease-out hover:-translate-y-0.5 hover:scale-105 focus:ring-2 focus:outline-none"
        title="닫기"
        aria-label="닫기">
        
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />

</svg>
      </button>
    </div>

    
    <div class="max-h-96 overflow-y-auto p-4">
      <nav
        id="toc-nav"
        class="toc-scrollbar"
        aria-label="글 목차">
          
          <div id="toc-content">
            <nav id="TableOfContents">
  <ul>
    <li><a href="#-결론-요약">📌 결론 (요약)</a></li>
    <li><a href="#-논문의-강점과-독창적인-지점">🚀 논문의 강점과 독창적인 지점</a>
      <ul>
        <li><a href="#강점">강점</a></li>
        <li><a href="#독창성">독창성</a></li>
      </ul>
    </li>
    <li><a href="#-핵심-알고리즘-프로세스-예시를-포함한-설명">📗 핵심 알고리즘 프로세스 (예시를 포함한 설명)</a>
      <ul>
        <li><a href="#-pipeline-bubble-instrumentation">① Pipeline Bubble Instrumentation</a></li>
        <li><a href="#-fill-job-execution-algorithm-실행-계획">② Fill Job Execution Algorithm (실행 계획)</a></li>
        <li><a href="#-fill-job-scheduling">③ Fill Job Scheduling</a></li>
      </ul>
    </li>
    <li><a href="#-실험-및-성능-비교-테이블로-요약">📊 실험 및 성능 비교 (테이블로 요약)</a></li>
    <li><a href="#-논문의-한계점-및-개선-가능성">🔻 논문의 한계점 및 개선 가능성</a>
      <ul>
        <li><a href="#-context-switching-overhead-존재">① Context Switching Overhead 존재</a></li>
        <li><a href="#-memory-제한-문제">② Memory 제한 문제</a></li>
        <li><a href="#-실시간-작업-처리-한계">③ 실시간 작업 처리 한계</a></li>
      </ul>
    </li>
    <li><a href="#-요약-및-최종-평가">🎯 요약 및 최종 평가</a></li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#-예시-입력">🔸 예시 입력:</a></li>
      </ul>
    </li>
    <li><a href="#-step-1--pipeline-bubble-instrumentation-버블-계측">🚩 <strong>STEP 1 : Pipeline Bubble Instrumentation (버블 계측)</strong></a>
      <ul>
        <li><a href="#목적">목적:</a></li>
        <li><a href="#예시를-통한-수행-과정">예시를 통한 수행 과정:</a></li>
      </ul>
    </li>
    <li><a href="#-step-2--fill-job-execution-plan-작업-실행-계획-수립">🚩 <strong>STEP 2 : Fill Job Execution Plan (작업 실행 계획 수립)</strong></a>
      <ul>
        <li><a href="#목적-1">목적:</a></li>
        <li><a href="#구체적-과정-greedy-알고리즘-예시">구체적 과정 (Greedy 알고리즘 예시):</a></li>
      </ul>
    </li>
    <li><a href="#-step-3--fill-job-scheduling-작업-스케줄링">🚩 <strong>STEP 3 : Fill Job Scheduling (작업 스케줄링)</strong></a>
      <ul>
        <li><a href="#목적-2">목적:</a></li>
        <li><a href="#예시를-통한-scheduling-방식">예시를 통한 Scheduling 방식:</a></li>
      </ul>
    </li>
    <li><a href="#-추가-context-switching-과정">🚩 <strong>추가: Context Switching 과정</strong></a></li>
    <li><a href="#-요약정리">📋 <strong>요약정리</strong></a></li>
    <li><a href="#-결론적-요약">✨ <strong>결론적 요약</strong></a></li>
  </ul>

  <ul>
    <li><a href="#-논문에서-제시한-주요-결과-정량적-수치">📊 논문에서 제시한 주요 결과 (정량적 수치)</a></li>
    <li><a href="#-다른-방법론과-비교하여-특출난-점">🌟 다른 방법론과 비교하여 특출난 점</a>
      <ul>
        <li><a href="#-독립적인-작업의-병렬-수행">① 독립적인 작업의 병렬 수행</a></li>
        <li><a href="#-매우-낮은-성능-오버헤드-주-작업-성능-손실-최소화">② 매우 낮은 성능 오버헤드 (주 작업 성능 손실 최소화)</a></li>
        <li><a href="#-높은-gpu-활용률-향상-scaling-효과-우수">③ 높은 GPU 활용률 향상 (Scaling 효과 우수)</a></li>
      </ul>
    </li>
    <li><a href="#-논문에서-제시하는-성능-향상의-주요-원인-분석">📌 논문에서 제시하는 성능 향상의 주요 원인 분석</a>
      <ul>
        <li><a href="#-명확한-버블-계측-및-세부-실행-계획">① 명확한 버블 계측 및 세부 실행 계획</a></li>
        <li><a href="#-독립-작업의-특성-활용">② 독립 작업의 특성 활용</a></li>
        <li><a href="#-최적화된-context-switching-전략">③ 최적화된 Context Switching 전략</a></li>
      </ul>
    </li>
    <li><a href="#-추가적인-나의-생각-분석적-평가">🤔 추가적인 나의 생각 (분석적 평가)</a>
      <ul>
        <li><a href="#-gpu-병렬-처리-특성-활용">① GPU 병렬 처리 특성 활용</a></li>
        <li><a href="#-현실적인-하드웨어-환경-최적화">② 현실적인 하드웨어 환경 최적화</a></li>
        <li><a href="#-현업에서의-실질적-활용-가능성-높음">③ 현업에서의 실질적 활용 가능성 높음</a></li>
      </ul>
    </li>
    <li><a href="#-한계점-및-추가-개선-가능성-제안">🚧 한계점 및 추가 개선 가능성 제안</a></li>
    <li><a href="#-요약-및-결론적-평가">📗 요약 및 결론적 평가</a></li>
  </ul>

  <ul>
    <li><a href="#-먼저pipefill의-한계점-정리">📝 먼저『PipeFill』의 한계점 정리</a></li>
    <li><a href="#-위-한계를-극복하기-위한-최근-연구-흐름-및-방법론">🚧 위 한계를 극복하기 위한 최근 연구 흐름 및 방법론</a></li>
    <li><a href="#--짧은-버블에-대한-효율적-대응-연구">📌 ① 짧은 버블에 대한 효율적 대응 연구</a>
      <ul>
        <li><a href="#-최근-연구-흐름-및-방법">💡 최근 연구 흐름 및 방법:</a></li>
      </ul>
    </li>
    <li><a href="#--gpu-메모리-제한-해결을-위한-연구">📌 ② GPU 메모리 제한 해결을 위한 연구</a>
      <ul>
        <li><a href="#-최근-연구-흐름-및-방법-1">💡 최근 연구 흐름 및 방법:</a></li>
      </ul>
    </li>
    <li><a href="#--실시간-작업real-time-task-처리를-위한-연구">📌 ③ 실시간 작업(real-time task) 처리를 위한 연구</a>
      <ul>
        <li><a href="#-최근-연구-흐름-및-방법-2">💡 최근 연구 흐름 및 방법:</a></li>
      </ul>
    </li>
    <li><a href="#-제안하는-통합-연구-흐름-및-해결-방안-제안">🎯 제안하는 통합 연구 흐름 및 해결 방안 제안</a></li>
    <li><a href="#-결론적-평가">✨ 결론적 평가</a></li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#-1-activation-compression-activation-압축기술">✅ <strong>1. Activation Compression (Activation 압축기술)</strong></a></li>
        <li><a href="#-2-gradient-compression-gradient-압축기술">✅ <strong>2. Gradient Compression (Gradient 압축기술)</strong></a></li>
        <li><a href="#-3-gpu-memory-virtualization-gpu-메모리-가상화">✅ <strong>3. GPU Memory Virtualization (GPU 메모리 가상화)</strong></a></li>
        <li><a href="#-4-nvme-ssd-offloading-기술-스토리지-기반-offloading">✅ <strong>4. NVMe SSD Offloading 기술 (스토리지 기반 Offloading)</strong></a></li>
        <li><a href="#-5-model-parameter-sharing--slimming-모델-파라미터-공유-및-축소-기술">✅ <strong>5. Model Parameter Sharing / Slimming (모델 파라미터 공유 및 축소 기술)</strong></a></li>
        <li><a href="#-6-hybrid-memory-systems-hbm--dram--ssd-결합">✅ <strong>6. Hybrid Memory Systems (HBM + DRAM + SSD 결합)</strong></a></li>
      </ul>
    </li>
    <li><a href="#-결론적으로-정리하면">🎯 결론적으로 정리하면:</a></li>
  </ul>

  <ul>
    <li><a href="#-1-모델-크기-parameter-수-메모리-footprint에-따른-성능-차이">📌 1. 모델 크기 (Parameter 수, 메모리 footprint)에 따른 성능 차이</a></li>
    <li><a href="#-2-작업-유형inference-vs-training에-따른-성능-차이">📌 2. 작업 유형(Inference vs. Training)에 따른 성능 차이</a></li>
    <li><a href="#-3-작업의-gpu-메모리-접근-패턴-및-연산-강도intensity에-따른-성능-차이">📌 3. 작업의 GPU 메모리 접근 패턴 및 연산 강도(Intensity)에 따른 성능 차이</a></li>
    <li><a href="#-결론적-종합-분석-및-추천-전략">📌 결론적 종합 분석 및 추천 전략</a></li>
  </ul>
</nav>
          </div>
      </nav>
    </div>

    
    <div class="border-border bg-muted/20 border-t px-4 py-3">
      <div class="text-muted-foreground text-center text-xs">
        <span>제목을 클릭하면 해당 위치로 이동합니다</span>
      </div>
    </div>
  </div>
</div>

    


  <link
    rel="stylesheet"
    href="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.css"
    integrity="sha384-5TcZemv2l/9On385z///+d7MSYlvIEw9FuZTIdZ14vJLqWphw7e7ZPuOiCHJcFCP"
    crossorigin="anonymous" />
  <script
    defer
    src="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.js"
    integrity="sha384-cMkvdD8LoxVzGF/RPUKAcvmm49FQ0oxwDF3BGKtDXcEc+T1b2N+teh/OJfpU0jr6"
    crossorigin="anonymous"></script>
  <script
    defer
    src="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/contrib/auto-render.min.js"
    integrity="sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh"
    crossorigin="anonymous"></script>

<script>
    
    function initKaTeX() {
        if (typeof renderMathInElement === 'undefined') {
            setTimeout(initKaTeX, 100);
            return;
        }

        var delimiters = [{"display":true,"left":"$$","right":"$$"},{"display":false,"left":"$","right":"$"}];

        renderMathInElement(document.body, {
            delimiters: delimiters,
            throwOnError: false,
            errorColor: '#cc0000',
            fleqn: false,
            leqno: false,
            trust: false
        });
    }

    
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initKaTeX);
    } else {
        initKaTeX();
    }
</script>
    



    
    
<div
  id="search-overlay"
  class="pointer-events-none fixed inset-0 z-40 bg-black/50 opacity-0 transition-opacity duration-300"></div>


<div
  id="search-modal"
  class="bg-card border-border pointer-events-none fixed top-1/2 left-1/2 z-50 max-h-[80vh] w-full max-w-2xl -translate-x-1/2 -translate-y-1/2 scale-95 transform overflow-hidden rounded-xl border opacity-0 shadow-xl transition-all duration-300">
  
  <div class="border-border flex items-center gap-3 border-b p-4">
    
    <div class="text-muted-foreground h-5 w-5 flex-shrink-0">
      
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="m21 21-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />

</svg>
    </div>

    
    <div class="relative flex-1">
      
      <button
        id="search-clear"
        class="text-muted-foreground hover:text-foreground hover:bg-muted/50 pointer-events-none absolute top-1/2 left-0 z-10 h-5 w-5 -translate-y-1/2 rounded opacity-0 transition-all duration-200"
        title="지우기"
        aria-label="지우기">
        
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />

</svg>
      </button>

      
      <input
        id="search-input"
        type="text"
        placeholder="게시글 검색..."
        class="text-foreground placeholder:text-muted-foreground w-full border-none bg-transparent pl-8 text-lg outline-none"
        autocomplete="off"
        spellcheck="false" />
    </div>

    
    <button
      id="search-close"
      class="text-muted-foreground hover:text-foreground hover:bg-muted/50 flex h-6 w-6 items-center justify-center rounded-md p-0.5 transition-all duration-200"
      title="닫기"
      aria-label="닫기">
      
  <svg class="h-4 w-4"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />

</svg>
    </button>
  </div>

  
  <div id="search-results" class="max-h-96 overflow-y-auto">
    
    <div
      id="search-empty"
      class="flex flex-col items-center justify-center py-12 text-center">
      <div
        class="bg-muted/50 mb-4 flex h-16 w-16 items-center justify-center rounded-full">
        
  <svg class="h-6 w-6"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="m21 21-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />

</svg>
      </div>
      <h3 class="text-foreground mb-2 text-lg font-semibold">
        검색 시작
      </h3>
      <p class="text-muted-foreground text-sm">
        검색어를 입력하세요
      </p>
    </div>

    
    <div
      id="search-loading"
      class="flex hidden items-center justify-center py-8">
      <div
        class="mr-3 h-6 w-6 animate-spin rounded-full border-2 border-current border-t-transparent"></div>
      <span class="text-muted-foreground"
        >검색 중...</span
      >
    </div>

    
    <div
      id="search-no-results"
      class="flex hidden flex-col items-center justify-center py-12 text-center">
      <div
        class="bg-muted/50 mb-4 flex h-16 w-16 items-center justify-center rounded-full">
        
  <svg class="h-6 w-6"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h7" />
</svg>
      </div>
      <h3 class="text-foreground mb-2 text-lg font-semibold">
        검색 결과 없음
      </h3>
      <p class="text-muted-foreground text-sm">
        다른 검색어로 시도해보세요
      </p>
    </div>

    
    <div id="search-results-list" class="hidden">
      
      <div
        id="search-stats"
        class="text-muted-foreground border-border border-b px-4 py-3 text-sm"
        data-template="%d개의 결과 찾음">
      </div>

      
      <div id="search-items" class="divide-border divide-y">
        
      </div>
    </div>
  </div>

  
  <div class="border-border bg-muted/20 border-t px-4 py-3">
    <div
      class="text-muted-foreground flex items-center justify-between text-xs">
      <div class="flex items-center gap-2 md:gap-4">
        <div class="flex items-center gap-1">
          <kbd
            class="bg-muted border-border rounded border px-1.5 py-0.5 text-xs"
            >↑↓</kbd
          >
          <span class="hidden sm:inline"
            >이동</span
          >
        </div>
        <div class="flex items-center gap-1">
          <kbd
            class="bg-muted border-border rounded border px-1.5 py-0.5 text-xs"
            >↵</kbd
          >
          <span class="hidden sm:inline"
            >선택</span
          >
        </div>
        <div class="flex items-center gap-1">
          <kbd
            class="bg-muted border-border rounded border px-1.5 py-0.5 text-xs"
            >ESC</kbd
          >
          <span class="hidden sm:inline"
            >닫기</span
          >
        </div>
      </div>
      <div class="search-hint-desktop flex items-center gap-1">
        <kbd class="bg-muted border-border rounded border px-1.5 py-0.5 text-xs"
          >⌘K</kbd
        >
        <span>단축키</span>
      </div>
    </div>
  </div>
</div>

  </body>
</html>
