<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Compiler on Jaehun's Blog</title><link>https://jaehun.me/ko/categories/compiler/</link><description>Recent content in Compiler on Jaehun's Blog</description><generator>Hugo</generator><language>ko-kr</language><lastBuildDate>Fri, 12 Feb 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://jaehun.me/ko/categories/compiler/index.xml" rel="self" type="application/rss+xml"/><item><title>LLVM (clang) build and install (ubuntu 18.04)</title><link>https://jaehun.me/ko/ko/posts/2021-2-12-llvm-clang/</link><pubDate>Fri, 12 Feb 2021 00:00:00 +0000</pubDate><guid>https://jaehun.me/ko/ko/posts/2021-2-12-llvm-clang/</guid><description>&lt;h1 id="clone-llvm-repo">clone llvm repo&lt;/h1>
&lt;div
 class="code-block-container border-border bg-card my-6 overflow-hidden rounded-xl border shadow-sm transition-all duration-200 ease-out hover:-translate-y-0.5 hover:shadow-md">
 
 &lt;div
 class="code-block-header bg-muted/30 border-border flex items-center justify-between border-b px-4 py-3">
 
 &lt;div class="flex items-center gap-2">
 &lt;div class="text-muted-foreground flex-shrink-0">
 
 &lt;svg class="h-4 w-4"
 fill="none"
 stroke="currentColor"
 viewBox="0 0 24 24">&lt;path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4" />
&lt;/svg>
 &lt;/div>
 &lt;span class="text-muted-foreground text-sm font-medium">
 PLAINTEXT
 &lt;/span>
 &lt;/div>

 
 &lt;div class="flex items-center gap-2">
 &lt;button
 class="collapse-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
 data-code-id="code-0"
 data-default-state="expanded"
 data-collapsed="false"
 data-auto-collapse-lines="30"
 data-auto-collapse-height="400"
 data-collapsed-height="120"
 title="접기"
 aria-label="접기">
 &lt;span class="collapse-icon">
 
 &lt;svg class="h-3 w-3"
 fill="none"
 stroke="currentColor"
 viewBox="0 0 24 24">&lt;path fill="currentColor" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z"/>&lt;/svg>
 &lt;/span>
 &lt;span class="collapse-text hidden sm:inline"
 >접기&lt;/span
 >
 &lt;/button>
 &lt;button
 class="copy-code-btn text-muted-foreground hover:text-primary hover:bg-primary/10 focus:ring-primary/20 flex items-center gap-1.5 rounded-md px-2 py-1 text-xs font-medium transition-all duration-200 ease-out focus:ring-2 focus:outline-none"
 data-code-id="code-0"
 title="복사"
 aria-label="복사">
 &lt;span class="copy-icon">
 
 &lt;svg class="h-3 w-3"
 fill="none"
 stroke="currentColor"
 viewBox="0 0 24 24">&lt;path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
&lt;/svg>
 &lt;/span>
 &lt;span class="copy-text hidden sm:inline"
 >복사&lt;/span
 >
 &lt;/button>
 &lt;/div>
 &lt;/div>

 
 &lt;div class="code-block-content relative" id="code-0">
 &lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="ln">1&lt;/span>&lt;span class="cl">git clone -b llvmorg-10.0.0 https://github.com/llvm/llvm-project.git llvm10&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
 
 &lt;div
 class="collapse-overlay to-card/90 pointer-events-none absolute inset-0 bg-gradient-to-b from-transparent via-transparent opacity-0 transition-opacity duration-300">
 &lt;div
 class="text-muted-foreground bg-card/80 border-border/50 hover:bg-primary/10 hover:text-primary hover:border-primary/30 absolute bottom-4 left-1/2 -translate-x-1/2 cursor-pointer rounded-full border px-3 py-1.5 text-xs backdrop-blur-sm transition-all duration-200">
 클릭하여 더 보기
 &lt;/div>
 &lt;/div>
 &lt;/div>
&lt;/div>


&lt;script>
(function() {
 const codeId = 'code-0';
 const copyBtn = document.querySelector('.copy-code-btn[data-code-id="' + codeId + '"]');
 const collapseBtn = document.querySelector('.collapse-code-btn[data-code-id="' + codeId + '"]');
 const codeContainer = document.getElementById(codeId);

 if (!codeContainer) return;

 
 if (copyBtn) {
 const copyIcon = copyBtn.querySelector('.copy-icon');
 const copyText = copyBtn.querySelector('.copy-text');

 copyBtn.addEventListener('click', async function() {
 try {
 
 let codeText = '';

 
 const codeTableCell = codeContainer.querySelector('.lntd:last-child code');
 if (codeTableCell) {
 codeText = codeTableCell.textContent || codeTableCell.innerText;
 } else {
 
 const codeElement = codeContainer.querySelector('code');
 if (codeElement) {
 
 const hasInlineLineNumbers = codeElement.querySelector('.ln');
 if (hasInlineLineNumbers) {
 
 const codeLines = codeElement.querySelectorAll('.cl');
 if (codeLines.length > 0) {
 codeText = Array.from(codeLines)
 .map(line => {
 const text = line.textContent || line.innerText;
 
 return text.replace(/\n+$/, '');
 })
 .join('\n')
 .replace(/\n+$/, ''); 
 } else {
 
 const allText = codeElement.textContent || codeElement.innerText;
 codeText = allText.replace(/^\d+/gm, '').replace(/^\s+/gm, '');
 }
 } else {
 
 codeText = codeElement.textContent || codeElement.innerText;
 }
 } else {
 
 codeText = codeContainer.textContent || codeContainer.innerText;
 }
 }

 
 codeText = codeText.trim();

 
 await navigator.clipboard.writeText(codeText);

 
 copyIcon.innerHTML = `\n \u003csvg class=\u0022h-3 w-3\u0022\n fill=\u0022none\u0022\n stroke=\u0022currentColor\u0022\n viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M5 13l4 4L19 7\u0022 \/\u003e\n\u003c\/svg\u003e`;
 if (copyText) {
 copyText.textContent = '복사됨';
 }
 copyBtn.classList.add('text-green-600');

 
 setTimeout(() => {
 copyIcon.innerHTML = `\n \u003csvg class=\u0022h-3 w-3\u0022\n fill=\u0022none\u0022\n stroke=\u0022currentColor\u0022\n viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z\u0022 \/\u003e\n\u003c\/svg\u003e`;
 if (copyText) {
 copyText.textContent = '복사';
 }
 copyBtn.classList.remove('text-green-600');
 }, 2000);

 } catch (err) {
 console.error('复制失败:', err);

 
 const range = document.createRange();
 const codeElement = codeContainer.querySelector('code') || codeContainer;
 range.selectNodeContents(codeElement);
 const selection = window.getSelection();
 selection.removeAllRanges();
 selection.addRange(range);

 
 if (copyText) {
 copyText.textContent = '선택됨';
 }

 setTimeout(() => {
 if (copyText) {
 copyText.textContent = '복사';
 }
 selection.removeAllRanges();
 }, 2000);
 }
 });
 }

 
 if (collapseBtn) {
 const collapseIcon = collapseBtn.querySelector('.collapse-icon');
 const collapseText = collapseBtn.querySelector('.collapse-text');
 const collapseOverlay = codeContainer.querySelector('.collapse-overlay');

 
 let codeElement = codeContainer.querySelector('pre.chroma');
 if (!codeElement) {
 codeElement = codeContainer.querySelector('pre');
 }

 const defaultState = collapseBtn.dataset.defaultState || 'expanded';
 const isCollapsedAttr = collapseBtn.dataset.collapsed === 'true';
 const autoCollapseLines = parseInt(collapseBtn.dataset.autoCollapseLines) || 30;
 const autoCollapseHeight = parseInt(collapseBtn.dataset.autoCollapseHeight) || 400;
 const collapsedHeight = parseInt(collapseBtn.dataset.collapsedHeight) || 120;

 let isCollapsed = false;

 
 function initCollapse() {
 
 const shouldCollapse = isCollapsedAttr ||
 defaultState === 'collapsed' ||
 shouldAutoCollapse();

 if (shouldCollapse) {
 setCollapsed(true, false); 
 }
 }

 function shouldAutoCollapse() {
 
 if (codeElement) {
 const lines = codeElement.querySelectorAll('.line, .cl');
 const height = codeElement.offsetHeight;
 return lines.length > autoCollapseLines || height > autoCollapseHeight;
 }

 
 const containerHeight = codeContainer.offsetHeight;
 if (containerHeight > autoCollapseHeight) {
 return true;
 }

 
 const textContent = codeContainer.textContent || codeContainer.innerText || '';
 const estimatedLines = textContent.split('\n').length;
 return estimatedLines > autoCollapseLines;
 }

 function setCollapsed(collapsed, animate = true) {
 if (!collapseOverlay) return;

 isCollapsed = collapsed;

 if (collapsed) {
 
 codeContainer.style.maxHeight = collapsedHeight + 'px';
 codeContainer.style.overflow = 'hidden';
 collapseOverlay.style.opacity = '1';
 collapseOverlay.style.pointerEvents = 'auto';

 
 collapseIcon.innerHTML = `\n \u003csvg class=\u0022h-3 w-3\u0022\n fill=\u0022none\u0022\n stroke=\u0022currentColor\u0022\n viewBox=\u00220 0 24 24\u0022\u003e\u003cpath stroke-linecap=\u0022round\u0022 stroke-linejoin=\u0022round\u0022 stroke-width=\u00222\u0022 d=\u0022M19 9l-7 7-7-7\u0022 \/\u003e\n\u003c\/svg\u003e`;
 if (collapseText) {
 collapseText.textContent = '펼치기';
 }
 collapseBtn.title = '펼치기';

 } else {
 
 codeContainer.style.maxHeight = '';
 codeContainer.style.overflow = '';
 collapseOverlay.style.opacity = '0';
 collapseOverlay.style.pointerEvents = 'none';

 
 collapseIcon.innerHTML = `\n \u003csvg class=\u0022h-3 w-3\u0022\n fill=\u0022none\u0022\n stroke=\u0022currentColor\u0022\n viewBox=\u00220 0 24 24\u0022\u003e\u003cpath fill=\u0022currentColor\u0022 d=\u0022M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z\u0022\/\u003e\u003c\/svg\u003e`;
 if (collapseText) {
 collapseText.textContent = '접기';
 }
 collapseBtn.title = '접기';
 }

 
 if (animate) {
 codeContainer.style.transition = 'max-height 0.3s ease-out';
 setTimeout(() => {
 codeContainer.style.transition = '';
 }, 300);
 }
 }

 function toggleCollapse() {
 setCollapsed(!isCollapsed, true);
 }

 
 collapseBtn.addEventListener('click', toggleCollapse);

 
 if (collapseOverlay) {
 collapseOverlay.addEventListener('click', () => {
 if (isCollapsed) {
 setCollapsed(false, true);
 }
 });
 }

 
 initCollapse();
 }
})();
&lt;/script>
&lt;h1 id="configure">configure&lt;/h1>
&lt;p>Ninja를 사용하면 컴파일 시간을 많이 단축할 수 있다.&lt;/p></description></item><item><title>LLVM loop unroll and jam pass and view-cfg</title><link>https://jaehun.me/ko/ko/posts/2021-2-12-llvm-unrollandjam/</link><pubDate>Fri, 12 Feb 2021 00:00:00 +0000</pubDate><guid>https://jaehun.me/ko/ko/posts/2021-2-12-llvm-unrollandjam/</guid><description>&lt;p>
&lt;figure class="image-figure not-prose my-8" 
 data-lightbox-enabled="false"
 data-gallery-type="auto">
 &lt;div class="image-container">
 
 &lt;img
 src="https://jaehun.me/assets/images/llvm.jpeg"
 alt=""
 
 loading="lazy"
 decoding="async"
 data-gallery-src="https://jaehun.me/assets/images/llvm.jpeg"
 data-gallery-alt=""
 data-gallery-title="" />&lt;/div>

 &lt;/figure>
대학원 컴파일러 수업에서 ML을 이용하여 unroll and jam을 판별하는 모델을 학습을 하는 term project를 진행하였다.
unroll and jam pass는 이름에서 알 수 있듯이 loop 최적화에 관련된 pass로 unroll 과 jam을 수행하여 innermost loop body의 병렬성을 증가시켜서 제한된 resource의 utilization을 증가시키는 최적화이다.
내 기억이 맞다면 O2 이상의 최적화 부터 적용되는데 opt의 debug를 통하여 볼때 생각보다 잘? 사용이 안된다.
LLVM code를 보면 대부분 loop unroll과 loop fusion pass를 재활용하며 검사 정도만 하는데 이 때문에 da,lcssa,loop simplify가 조건을 만족하여도 unroll and jam pass가 동작되지 않는 경우가 많다.&lt;/p></description></item><item><title>간단논문 정리 End-to-End Deep Learning of Optimization Heuristics (PACT 17)</title><link>https://jaehun.me/ko/ko/posts/2021-2-12-paper-End-to-EndDeepLearning-of-pptimization-heuristics/</link><pubDate>Fri, 12 Feb 2021 00:00:00 +0000</pubDate><guid>https://jaehun.me/ko/ko/posts/2021-2-12-paper-End-to-EndDeepLearning-of-pptimization-heuristics/</guid><description>&lt;h1 id="제목">제목&lt;/h1>
&lt;p>End-to-End Deep Learning of Optimization Heuristics&lt;/p>
&lt;h1 id="저자">저자&lt;/h1>
&lt;p>Chris Cummins ; Pavlos Petoumenos ; Zheng Wang ; Hugh Leather&lt;/p>
&lt;h1 id="motivation">Motivation&lt;/h1>
&lt;p>기존 머신러닝을 이용한 compiler optimizaion 방법에서는 human experts를 이용한 feature engineering 이 필요&lt;/p>
&lt;h1 id="contribution">Contribution&lt;/h1>
&lt;p>논문에서 제안하는 Source Rewriter &amp;amp; Language model을 이용하여 RAW PROGRAM CODE을 직접 이용하여 compiler optimizaion을 수행 아울어 transfer learning 을 이용하여 small number of program 에서도 학습을 수행&lt;/p></description></item><item><title>간단논문 정리 Fast and Effective Orchestration of Compiler Optimizations(Zhelong Pan,Rudolf Eigenmann;Purdue University ;CGO’06)</title><link>https://jaehun.me/ko/ko/posts/2021-2-12-paper-Fast-and-EffectiveOrchestrationofCompilerOptimizations/</link><pubDate>Fri, 12 Feb 2021 00:00:00 +0000</pubDate><guid>https://jaehun.me/ko/ko/posts/2021-2-12-paper-Fast-and-EffectiveOrchestrationofCompilerOptimizations/</guid><description>&lt;h1 id="제목">제목&lt;/h1>
&lt;p>Fast and Effective Orchestration of Compiler Optimizations&lt;/p>
&lt;h1 id="저자">저자&lt;/h1>
&lt;p>Zhelong Pan,Rudolf Eigenmann&lt;/p>
&lt;h1 id="motivation">Motivation&lt;/h1>
&lt;p>compile-time optimizations 은 전반적으로 프로그램 성능을 향상시키지만 일부 기법은 성능 하락을 야기한다.
입력프로그램와 target architecture에 대한 불충분한 정보는 컴파일 시간에 정확도 향상을 향상 시키는 모델의 한계를 만든다.&lt;/p></description></item><item><title>간단논문 정리 TVM An Automated End-to-End Optimizing Compiler for Deep Learning (OSDI 18)</title><link>https://jaehun.me/ko/ko/posts/2021-2-12-paper-tvm/</link><pubDate>Fri, 12 Feb 2021 00:00:00 +0000</pubDate><guid>https://jaehun.me/ko/ko/posts/2021-2-12-paper-tvm/</guid><description>&lt;p>
&lt;figure class="image-figure not-prose my-8" 
 data-lightbox-enabled="false"
 data-gallery-type="auto">
 &lt;div class="image-container">
 
 &lt;img
 src="https://jaehun.me/assets/images/tvm1.png"
 alt=""
 
 loading="lazy"
 decoding="async"
 data-gallery-src="https://jaehun.me/assets/images/tvm1.png"
 data-gallery-alt=""
 data-gallery-title="" />&lt;/div>

 &lt;/figure>&lt;/p>
&lt;h1 id="제목">제목&lt;/h1>
&lt;p>TVM: An Automated End-to-End Optimizing Compiler for Deep Learning&lt;/p>
&lt;h1 id="tvm">TVM?&lt;/h1>
&lt;p>해당논문은 머신러닝용 컴파일러중에 대표적인 TVM에 대한 paper입니다. 현재는 apache에서 관리 하고 있으며 graph level IR 을 통한 target-independent optimization,
autotune을 통한 target-dependent optimization 을 지원하며 llvm 및 vta를 통하여 cpu,gpu뿐만 아니라 FPGA를 backend로 지원합니다.&lt;/p></description></item><item><title>논문 정리 Chameleon Adaptive Code Optimization for Expedited Deep Neural Network Compilation(ICLR 2020)</title><link>https://jaehun.me/ko/ko/posts/2021-2-12-paper-chameleon/</link><pubDate>Fri, 12 Feb 2021 00:00:00 +0000</pubDate><guid>https://jaehun.me/ko/ko/posts/2021-2-12-paper-chameleon/</guid><description>&lt;p>
&lt;figure class="image-figure not-prose my-8" 
 data-lightbox-enabled="false"
 data-gallery-type="auto">
 &lt;div class="image-container">
 
 &lt;img
 src="https://jaehun.me/assets/images/chameleon1.jpg"
 alt=""
 
 loading="lazy"
 decoding="async"
 data-gallery-src="https://jaehun.me/assets/images/chameleon1.jpg"
 data-gallery-alt=""
 data-gallery-title="" />&lt;/div>

 &lt;/figure>&lt;/p>
&lt;h1 id="제목">제목&lt;/h1>
&lt;p>Chameleon: Adaptive Code Optimization for Expedited Deep Neural Network Compilation&lt;/p>
&lt;h1 id="저자">저자&lt;/h1>
&lt;p>Byung Hoon Ahn, Prannoy Pilligundla, Amir Yazdanbakhsh, Hadi Esmaeilzadeh&lt;/p>
&lt;h1 id="motivation">Motivation&lt;/h1>
&lt;p>The current approaches are oblivious to the patterns in the design space of schedules that are available for exploitation, and causes inefficient search or even converges to solutions that may even be suboptimal.
Current solutions that rely on greedy sampling lead to significant fractions of the candidate configurations being redundant over iterations(long compilation time)&lt;/p></description></item><item><title>논문 정리 LLVM A Compilation Framework for Lifelong Program Analysis &amp; Transformation(CGO 04)</title><link>https://jaehun.me/ko/ko/posts/2021-2-12-paper-llvm/</link><pubDate>Fri, 12 Feb 2021 00:00:00 +0000</pubDate><guid>https://jaehun.me/ko/ko/posts/2021-2-12-paper-llvm/</guid><description>&lt;h1 id="제목">제목&lt;/h1>
&lt;p>LLVM: A Compilation Framework for Lifelong Program Analysis &amp;amp; Transformation&lt;/p>
&lt;h1 id="저자">저자&lt;/h1>
&lt;p>Chris Lattner Vikram Adve&lt;/p>
&lt;h1 id="개인적으로-느끼는-논문의-insight">개인적으로 느끼는 논문의 insight&lt;/h1>
&lt;p>Lifelong Program Analysis개념을 도입하여 Front-end를 제외한 부분에서 전체적인 최적화를 수행,SSA,machine-independent optimization
논문에서 제시된 개념이 지금의 llvm과 정확하게 일치하지는 않지만 대단하다..&lt;/p></description></item><item><title>논문 정리 NeuroVectorizer End-to-End Vectorization with Deep Reinforcement Learning (CGO 20)</title><link>https://jaehun.me/ko/ko/posts/2021-2-12-paper-NeuroVectorizer/</link><pubDate>Fri, 12 Feb 2021 00:00:00 +0000</pubDate><guid>https://jaehun.me/ko/ko/posts/2021-2-12-paper-NeuroVectorizer/</guid><description>&lt;p>
&lt;figure class="image-figure not-prose my-8" 
 data-lightbox-enabled="false"
 data-gallery-type="auto">
 &lt;div class="image-container">
 
 &lt;img
 src="https://jaehun.me/assets/images/nv1.png"
 alt=""
 
 loading="lazy"
 decoding="async"
 data-gallery-src="https://jaehun.me/assets/images/nv1.png"
 data-gallery-alt=""
 data-gallery-title="" />&lt;/div>

 &lt;/figure>&lt;/p>
&lt;h1 id="제목">제목&lt;/h1>
&lt;p>NeuroVectorizer: End-to-End Vectorization with Deep Reinforcement Learning&lt;/p>
&lt;h1 id="저자">저자&lt;/h1>
&lt;p>Ameer Haj-Ali, Nesreen K. Ahmed, Ted Willke, Sophia Shao, Krste Asanovic, Ion Stoica&lt;/p>
&lt;h1 id="motivation">Motivation&lt;/h1>
&lt;p>Compilers are designed today to use fixed-cost models that are based on heuristics to make vectorization decisions on loops. However, these models are unable to capture the data dependency, the computation graph, or the organization of instructions
The vectorization is critical to enhancing the performance of compute-intensive workloads in modern computers.&lt;/p></description></item></channel></rss>