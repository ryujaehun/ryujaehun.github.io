---
title: "NEO: Saving GPU Memory Crisis with CPU Offloading for Online LLM Inference"
date: 2025-03-31
categories:
 - paper-review
 - with-gpt
 - MLSYS2025
---

{% capture time %}{{ content | reading_time }}{% endcapture %}
   <p>이 포스트를 읽는데 약 {{ time }} {% if time == '1' %}분{% else %}분{% endif %} 이 소요될 수 있습니다.</p>

[논문 링크](https://arxiv.org/abs/2411.01142)

# Q : 이 논문을 아주 자세하게 읽고 논문의 강점과 독창적인 지점을 설명해주고 핵심 알고리즘을 예시 입력을 들어서 전체적인 과정을 설명해줘 추가적으로 논문의 한계점에 대해서도 알려줘



### 📌 **논문 제목:** NEO: Saving GPU Memory Crisis with CPU Offloading for Online LLM Inference  
### 📌 **저자:** Xuanlin Jiang, Yang Zhou, Shiyi Cao, Ion Stoica, Minlan Yu

---

## **1. 결론 요약 (강점 & 독창적인 지점)**
NEO는 GPU 메모리의 제한으로 인해 발생하는 LLM 추론의 병목을 해결하기 위해 **비대칭 GPU-CPU 파이프라이닝과 부하 인식 스케줄링을 적용한 새로운 시스템**입니다. 주요 강점은 다음과 같습니다.

1. **GPU 메모리 사용량 최적화:** 
   - GPU에서 모델 가중치 및 일부 KV 캐시만 유지하며, 나머지 캐시는 CPU로 오프로드하여 메모리 병목을 해결합니다.
   - GPU와 CPU 사이의 데이터 흐름을 최적화하여 병렬 연산을 극대화합니다.

2. **비대칭 파이프라이닝 (Asymmetric Pipelining):** 
   - 하나의 배치를 두 개로 나누어 GPU와 CPU에서 동시에 작업을 수행하도록 합니다. 
   - GPU의 메모리 리소스를 최대한 활용하면서도 CPU의 연산 능력을 적절히 배치합니다.
   - 기존 대칭 파이프라이닝보다 효율적으로 CPU와 GPU를 사용합니다.

3. **부하 인식 스케줄링 (Load-Aware Scheduling):**
   - GPU 및 CPU의 사용률을 실시간으로 모니터링하여 최적의 오프로드 정책을 동적으로 결정합니다.
   - 작업이 GPU 또는 CPU에서 최적으로 수행되도록 배치를 형성합니다.

4. **성능 향상:** 
   - H100 GPU에서 최대 **14%**, A10G GPU에서 **26%**, T4 GPU에서 **7.5배**의 추론 처리량 증가를 보여줍니다.
   - 보다 강력한 CPU를 사용할 경우 A10G GPU에서 **79.3%**의 성능 개선을 달성합니다.

---

## **2. 핵심 알고리즘 설명 (예시 포함)**

### 💡 **NEO의 핵심 아이디어는 GPU 메모리 제약을 피하기 위해 CPU로 일부 작업을 오프로드하는 것입니다.**

### **NEO의 구성 요소**
- **Prefilling:** 입력 텍스트를 기반으로 초기 KV 캐시를 생성합니다.
- **Decoding:** 입력을 기반으로 새로운 토큰을 예측하며, 생성된 KV 캐시를 사용합니다.
- **Scheduler:** 작업 요청을 GPU와 CPU로 분배하는 기능을 합니다.

### **알고리즘 과정**

1. **입력 및 초기화:** 
   - 예시 입력: "The quick brown fox jumps over the lazy dog."
   - 모델은 이 입력을 토큰화하고 임베딩을 생성합니다.

2. **Prefilling Stage (GPU):** 
   - 입력 토큰을 통해 초기 KV 캐시를 GPU에서 생성합니다.
   - 이 때, 모델의 파라미터는 모두 GPU 메모리에 저장되어 있습니다.

3. **Decoding Stage (GPU + CPU):**
   - 비대칭 파이프라이닝을 적용하여 일부 요청은 GPU에서, 일부는 CPU로 오프로드하여 처리합니다.
   - 예를 들어, 입력 길이가 긴 요청은 GPU에서, 짧은 요청은 CPU에서 처리하도록 분배합니다.

4. **Load-Aware Scheduling:** 
   - GPU와 CPU의 사용률을 실시간으로 평가하여 최적의 작업 분배를 결정합니다.
   - 만약 GPU가 과부하 상태라면 더 많은 요청을 CPU로 오프로드합니다.

5. **결과 생성:** 
   - 예를 들어, "dog"라는 단어 다음에 모델이 "is sleeping"을 예측했다고 가정합니다.  
   - GPU와 CPU에서 계산된 결과는 결합하여 최종 출력을 생성합니다.

---

## **3. 논문의 한계점**

1. **GPU와 CPU 간 통신 병목 (PCIe Bandwidth 문제):**
   - GPU와 CPU 간의 데이터 전송이 빈번하게 발생하면 PCIe 대역폭이 병목으로 작용할 수 있습니다.

2. **스케줄링 복잡도 증가:**
   - 부하 인식 스케줄링은 실시간으로 GPU와 CPU 사용률을 모니터링하고 최적의 배치를 찾아야 하므로 추가적인 계산 비용이 발생합니다.

3. **특정 환경에서 성능 저하:**
   - 입력 길이가 짧거나 GPU 메모리가 충분히 클 경우, CPU로의 오프로드가 오히려 성능 저하를 유발할 수 있습니다.

4. **다중 GPU 환경에서의 최적화 미흡:**
   - 논문에서는 주로 단일 GPU 또는 2-GPU 환경에서의 실험이 이루어졌으며, 4-GPU 이상의 대규모 시스템에 대한 검증이 부족합니다.

---

## **4. 결론 및 제안**
NEO는 GPU 메모리 제약을 극복하기 위해 CPU 오프로드를 효율적으로 활용하는 시스템으로, 다양한 실험에서 높은 처리량을 입증하였습니다. 그러나 다중 GPU 환경에서의 최적화와 PCIe 대역폭 문제를 해결하는 추가적인 연구가 필요합니다.  

### 제안
- **다중 GPU 환경 최적화:** Tensor 병렬 처리 및 모델 샤딩 기법을 개선하여 다중 GPU 환경에서도 높은 성능을 유지할 수 있도록 개선이 필요합니다.
- **PCIe 병목 해결:** CPU와 GPU 간 데이터 전송을 줄이기 위한 새로운 오프로드 방안을 연구해야 합니다.


# Q : 논문의 핵심알고리즘을 예시를 들어 아주 자세하게 설명해주고 정리해 줘



논문의 핵심 알고리즘을 예시 입력을 바탕으로 아주 구체적이고 단계적으로 설명하고 정리하겠습니다.

---

## 📌 핵심 알고리즘: **NEO의 비대칭 GPU-CPU 파이프라이닝 및 부하 인식 스케줄링**

NEO는 GPU 메모리 부족으로 인한 추론 성능 저하 문제를 해결하기 위해, 일부 연산(Decoding Attention)과 메모리(KV Cache)를 GPU에서 CPU로 오프로드하여 GPU의 메모리 효율을 높이고 추론 성능을 증가시키는 방법을 제안합니다.

---

## 📝 알고리즘 전체 과정 (예시를 통해 단계별로 설명)

예시 입력 텍스트:

```
"OpenAI develops powerful AI models."
```

이 입력이 들어왔을 때 LLM 추론이 어떻게 진행되는지 **기존 방식(vLLM)**과 **NEO 방식**으로 나누어 자세히 비교하며 설명합니다.

### ✅ 예시 환경
- GPU: NVIDIA A10G (GPU 메모리 제한: 24GB)
- CPU: Intel Xeon (64GB 메모리)

---

## 📍 1단계: Prefilling Stage (초기 입력 처리)

### ▪️ 기존 방식 (vLLM)
- 입력 토큰(예: ["OpenAI", "develops", "powerful", "AI", "models", "."])을 GPU에서 Transformer 층을 거쳐 임베딩 생성 및 초기 KV 캐시 생성
- 생성된 KV 캐시는 **모두 GPU 메모리에 저장**

> **문제점:**  
> 입력이 많아지면 GPU 메모리 부족으로 batch size가 제한되고 GPU 연산 자원이 낭비됨.

### 🟢 NEO 방식
- 입력 토큰은 동일하게 GPU에서 처리하여 임베딩 및 초기 KV 캐시 생성.
- 그러나 생성된 KV 캐시를 GPU 메모리가 허용하는 만큼만 GPU에 유지하고, 나머지는 즉시 **CPU 메모리로 오프로드(전송)** 합니다.
- 이때 GPU와 CPU 간 KV 캐시 전송은 계층(layer) 단위로 즉시 수행되며, 연산과 전송이 겹치게 됩니다.

> **NEO 이점:**  
> GPU 메모리 부족 문제 해결 (GPU와 CPU 메모리 동시 활용)

---

## 📍 2단계: Decoding Stage (출력 토큰 생성)

입력 문장 다음에 올 가능성이 높은 단어들을 생성하는 과정 (예: "They", "are", "widely", "used", ...)

### ▪️ 기존 방식 (vLLM)
- GPU에서 입력된 KV 캐시를 기반으로 attention을 계산하고 다음 토큰 생성 (예: "They").
- 모든 계산(KV cache 및 attention 계산)은 GPU에서만 수행.

> **문제점:**  
> GPU 메모리 제한으로 인해 batch 크기를 크게 늘리지 못하고 GPU 연산 자원을 충분히 활용 못 함.

### 🟢 NEO 방식
NEO는 비대칭 GPU-CPU 파이프라이닝을 적용하여 두 개의 서브 배치를 형성합니다:

- **Batch 0 (GPU 중심 배치)**:
  - Prefilling 단계의 요청들 (입력처리) + 일부 GPU에 적합한 Decoding 요청들을 GPU에서 처리.
  - 주로 GPU 메모리와 연산 자원을 활용하여 빠르게 진행되는 batch.
  
- **Batch 1 (CPU 중심 배치)**:
  - Decoding 단계 중 attention 계산이 무거운 요청들(길이가 길거나 KV 캐시가 큰 요청)을 CPU로 오프로드하여 처리.
  - 이 요청들의 attention 연산과 KV 캐시 접근을 CPU 메모리에서 수행.

> **이점:**  
> GPU는 GPU에 적합한 작업을 빠르게 처리하고, CPU는 attention 중심의 memory-bound 작업을 병렬로 처리함으로써 효율성 극대화.

---

## 📍 3단계: Load-Aware Scheduling (GPU-CPU 동적 부하 분배)

NEO는 매 iteration마다 다음 원칙으로 GPU와 CPU의 요청 분배를 결정합니다:

- **Greedy 방식**으로 GPU-only 방식과 GPU-CPU 파이프라이닝 방식의 예상 성능을 비교하여 높은 성능을 낼 방식을 선택.
- GPU와 CPU의 연산 시간 균형 유지 (**Balancing**)
- GPU의 빈 시간(idle)을 최소화하고 CPU의 연산을 GPU 연산 뒤에 숨겨서 동시 작업 수행 (**Hiding CPU**)
- GPU 사용을 극대화하여 가능한 많은 요청을 GPU로 처리 (**Maximizing GPU**)

이 원칙을 기반으로 batch 형성 절차는 다음과 같습니다:

| 순서 | 처리 단계       | 설명                                                      | 작업 위치 |
| ---- | --------------- | --------------------------------------------------------- | --------- |
| ①    | GPU decoding    | GPU에 최적화된 요청을 우선 GPU 배치                       | GPU       |
| ②    | Prefilling      | 새 입력 요청 처리, KV cache는 GPU에 저장하거나 CPU로 전송 | GPU→CPU   |
| ③    | CPU decoding    | GPU 처리에 방해되지 않는 요청을 CPU 배치                  | CPU       |
| ④    | Prefilling 조정 | CPU 작업 시간을 초과하지 않도록 Prefilling 요청 최적화    | GPU       |
| ⑤    | 방식 결정       | GPU-only와 GPU-CPU 병렬 처리 중 최선의 방식을 선택        | GPU-CPU   |

---

## 📍 4단계: 결과 취합 및 출력

- GPU와 CPU에서 병렬로 계산된 attention 결과는 최종적으로 GPU로 전달되어 통합됩니다.
- 최종 임베딩이 완성되면 다음 토큰(예: "They")의 확률을 계산하여 사용자에게 제공됩니다.

---

## 📌 📈 알고리즘 효과 (논문 실험 결과 기반)

| GPU 장비 | 모델 크기 | vLLM 대비 NEO 성능 향상 |
| -------- | --------- | ----------------------- |
| T4       | 7B        | 최대 **7.5배** 증가     |
| A10G     | 8B        | 최대 **26%** 증가       |
| H100     | 70B       | 최대 **14%** 증가       |

※ CPU 메모리 대역폭이 클수록 성능 증가폭 커짐 (최대 79.3%)

---

## 🔍 알고리즘 전체 요약 (정리)

NEO의 핵심은 GPU 메모리 부족 문제를 해결하기 위해 CPU로 attention 연산과 KV 캐시 일부를 효율적으로 오프로드하는 것입니다. 비대칭 파이프라이닝과 부하 인식 스케줄링을 적용하여 GPU와 CPU 자원을 동적으로 최적화하고, 결과적으로 GPU-only 시스템 대비 현저한 성능 개선을 이루었습니다.

- **기존 방식:** 모든 연산과 KV 캐시가 GPU에 위치.
- **NEO 방식:**  
  - GPU에서 적합한 작업 수행 (Prefilling, Linear 계산)
  - CPU에서 적합한 작업 수행 (Memory-bound Attention)
  - GPU와 CPU 연산이 서로 겹쳐서 병렬화

결과적으로 GPU 메모리 제한을 극복하고 GPU와 CPU의 강점을 모두 활용하여 LLM 추론 성능을 개선한 독창적인 시스템입니다.



# Q : 이 논문에서 제시한 결과를 자세하게 보고 다른 방법론에 비하여 특출난 점과 논문에서 제기하는 어떠한 방법이 이러한 결과를 도출하게 되었는지 논문에서 제시하는 이유와 너의 생각을 알려줘



논문의 실험 결과를 상세히 분석하여, **다른 방법론과 비교하여 특출난 점**과 그 이유를 논문에서 제시한 근거와 함께 분석하고, 저의 견해를 덧붙여 정리하겠습니다.

---

## 🔑 1. 실험결과 요약 (정량적 수치)

논문은 세 가지 GPU 환경(T4, A10G, H100)과 세 가지 LLM 모델(7B, 8B, 70B)에 대해 **NEO**, **vLLM (GPU-only)**, 그리고 기존의 CPU 오프로드 방식인 **FastDecode**를 비교합니다.

| GPU 환경 | 모델 크기 | Throughput (NEO vs. GPU-only(vLLM)) | Latency |
| -------- | --------- | ----------------------------------- | ------- |
| T4       | 7B        | 최대 **7.5배(750%) 증가**           | 유지    |
| A10G     | 8B        | 최대 **26% 증가**                   | 유지    |
| H100     | 70B       | 최대 **14% 증가**                   | 유지    |

추가적으로, CPU 성능을 높일 경우 A10G GPU 환경에서 최대 **79.3%의 성능향상**이 관찰되었습니다.

---

## 🔍 2. 기존 방법론 대비 특출난 점

논문에서 비교한 주요 기존 방법론은 다음과 같습니다.

- **vLLM (GPU-only)**: GPU만 사용하는 방식으로, 메모리 제한으로 인해 높은 batch 크기를 확보하지 못하는 한계가 있습니다.
- **FastDecode**: KV cache와 attention을 모두 CPU에 완전히 오프로드하는 방식으로, CPU가 병목 지점이 되어 성능이 떨어지는 문제점이 있습니다.

| 비교 기준         | NEO (본 논문) | vLLM (GPU-only)            | FastDecode (Full Offload) |
| ----------------- | ------------- | -------------------------- | ------------------------- |
| GPU 메모리 효율성 | ⭕ 높음        | ❌ 낮음 (제한적 batch size) | ⭕ 높음                    |
| CPU-GPU 병렬화    | ⭕ 매우 효율적 | ❌ 없음                     | △ 제한적 병렬화           |
| Latency 유지      | ⭕ 유지        | ⭕ 유지                     | ❌ 증가                    |
| CPU 자원 활용     | ⭕ 최적화      | ❌ 활용하지 않음            | △ 병목이 되어 비효율적    |
| Throughput 성능   | ⭕ 가장 높음   | ❌ 낮음                     | △ 일부 환경에서만 높음    |

- **특출난 지점**:
  - NEO는 GPU의 제한된 메모리 리소스를 효율적으로 확장하면서 CPU 자원을 최대한 활용하여 GPU-only 방식과 Full-offload 방식의 단점을 모두 보완했습니다.
  - 특히 GPU-only 방식(vLLM)에 비해 최대 **750%**라는 극적인 성능 향상을 보여주며, FastDecode의 CPU 병목 문제를 효과적으로 회피하였습니다.

---

## 🚀 3. 논문에서 밝힌 성능 향상의 주요 원인 (논문의 주장)

논문은 NEO가 뛰어난 성능을 낼 수 있었던 주요 이유로 다음 두 가지 핵심 기술을 제시합니다.

### ① **Asymmetric Pipelining (비대칭 파이프라이닝)**

- GPU 연산(Linear operation, Prefilling)에 최적화된 요청을 GPU에서,  
  attention 연산이 많은 요청은 CPU에서 처리하여 병렬화합니다.
- **효과:** GPU 메모리의 효율적 사용과 동시에 CPU 연산 능력까지 최대화합니다.

> _논문의 근거_:  
> "기존 대칭(symmetric) 파이프라이닝은 GPU와 CPU가 동일한 작업량을 처리하도록 강제하므로, CPU가 병목이 되는 문제가 발생합니다.  
> NEO의 비대칭(asymmetric) 파이프라이닝은 서로 다른 작업 성격을 GPU와 CPU에 적절히 배치하여 idle 시간을 최소화하고 성능을 극대화합니다."

### ② **Load-Aware Scheduling (부하 인식 스케줄링)**

- 매 iteration마다 실시간으로 GPU와 CPU의 부하를 고려해 요청을 동적으로 분배합니다.
- **효과:** GPU와 CPU 어느 한 쪽도 병목이 되지 않도록 균형 유지가 가능해집니다.

> _논문의 근거_:  
> "기존 방식은 정적인(static) 정책을 사용하여 요청의 입/출력 길이 변화를 실시간으로 대응하기 어렵습니다.  
> NEO의 동적 부하 인식 스케줄링은 실시간 환경에서 가장 효율적인 요청 배치를 결정해 성능을 향상시킵니다."

---

## 🎯 4. 나의 분석 및 견해

논문의 접근 방법은 GPU 메모리의 제약을 해결하기 위한 상당히 현실적이고 효과적인 접근입니다. 특히, 다음과 같은 측면에서 독창성과 실효성을 높게 평가합니다.

- **현실적인 GPU 메모리 문제에 대한 해결**  
  GPU 기술은 빠르게 발전하여 연산 성능은 급속히 증가했으나, 메모리 용량은 제한적인 발전 속도를 보였습니다.  
  NEO는 이러한 메모리 부족 문제에 대해 CPU 오프로드를 아주 실용적인 해법으로 제시했습니다.

- **CPU 자원을 최대한 활용하는 관점**  
  대부분 서버 환경에서는 GPU와 함께 강력한 CPU가 배치됩니다.  
  이를 활용하지 않고 GPU만을 사용하는 기존 방식과 달리, CPU를 적극 활용하여 자원의 낭비 없이 최대한 성능을 끌어낸 점이 독창적입니다.

- **CPU를 과도하게 사용하지 않는 절제된 설계**  
  FastDecode는 모든 attention 작업을 CPU로 넘기면서 CPU 병목 문제가 심각했습니다.  
  반면 NEO는 부분적인 오프로드로 CPU의 부담을 최소화하여, 현실적인 병목 문제를 회피하는 지혜로운 설계를 보였습니다.

**다만, 한 가지 우려되는 부분은:**  
- GPU-CPU 간 빈번한 데이터 전송으로 인한 PCIe bandwidth 병목 가능성이 있습니다.  
- 이는 더 높은 성능의 PCIe 또는 CXL 인터페이스를 사용할 경우 해소될 가능성이 있지만, 보다 구체적인 실험 검증이 필요합니다.

---

## 📌 최종 결론 및 제안

이 논문은 GPU 메모리 문제를 해결하는 효과적이며 실용적인 접근법으로서 매우 유의미한 결과를 도출했습니다. 이는 GPU-CPU의 자원을 효과적으로 활용하는 전략 덕분이며, 다른 방법론이 가지는 한계를 극복한 독창적인 기법입니다.

향후 연구에서는:

- PCIe 대역폭 제한을 어떻게 극복할 수 있을지에 대한 추가 실험과 분석이 필요합니다.
- 더 많은 GPU (4~8 GPU 이상)를 사용하는 대규모 환경에서의 성능을 검증하는 것이 필요합니다.

이러한 추가 연구가 이루어진다면, NEO 방식은 대규모 LLM 추론 시스템의 성능과 효율성을 크게 개선할 것으로 예상됩니다.



# Q : 이 논문의 입력데이터와 추론 과정에 대해서 예시를 들어 아주 자세하게 설명해 주겠니? 추가적으로 모델아키텍처의 구성 및 모델을 구성하는 연산과 메모리 요구량 컴퓨팅 요구량 대해서도 설명해줘



이 논문에서 제시된 NEO 시스템의 **입력 데이터 처리 과정, 추론 과정, 모델 아키텍처, 연산 및 메모리/컴퓨팅 요구량**을 예시를 들어 매우 구체적으로 설명하겠습니다.

---

## 📌 1. 입력 데이터와 추론 과정 예시 (Detailed Example)

다음과 같은 입력 문장을 예시로 들겠습니다.

**입력 문장:**  
```
"GPT models can generate high-quality text."
```

이 입력을 기반으로 NEO 시스템에서 추론이 진행되는 구체적이고 상세한 과정은 다음과 같습니다.

---

## 🔍 2. NEO 시스템의 단계별 추론 과정 상세 설명

NEO에서의 LLM 추론은 크게 **Prefilling**과 **Decoding** 두 단계로 나누어 진행됩니다.

### ✅ **단계 1: Prefilling 단계**

이 단계에서는 입력된 문장 전체를 모델이 처리하여 최초의 KV 캐시를 생성합니다.

- **입력 토큰화(Tokenization)**  
  입력 문장이 모델이 이해할 수 있는 토큰 형태로 변환됩니다.
  ```
  ["GPT", "models", "can", "generate", "high", "-", "quality", "text", "."]
  ```

- **임베딩(Embedding)**  
  각 토큰은 임베딩 레이어를 통과하여 벡터 형태로 바뀝니다.
  - 입력 차원 예시: `[토큰수 × 임베딩 크기]`

- **Transformer Layer 연산**  
  Transformer는 주로 Attention 연산과 Feed Forward Network (FFN) 연산으로 이루어집니다.

  - **Self-Attention 연산**: 입력 벡터끼리 연관성을 계산하여 context-aware한 벡터를 생성합니다.
    - Attention(Q,K,V) = softmax(QKᵀ/√d_k)V
    - 계산 복잡도: 입력 길이 \( n \)에 대해 \( O(n^2) \)

  - **KV Cache 생성**  
    Attention 연산의 중간 결과로 **Key, Value** 벡터를 생성하여 GPU 및 CPU 메모리에 저장합니다.  
    (예: "GPT models can generate"와 같은 이전 토큰의 정보가 KV cache에 저장)

  - **FFN 연산**  
    Attention 출력을 받아 FFN 층을 통과하며, 모델의 표현 능력을 증가시키는 추가 변환을 수행합니다.

이 과정 후 GPU에서 생성된 KV cache 중 일부는 CPU 메모리로 오프로드 됩니다.

---

### ✅ **단계 2: Decoding 단계**

Decoding 단계에서는 다음에 올 토큰을 하나씩 생성하는 과정입니다.

예시: 입력 문장 이후 생성할 다음 단어 `"They"`의 생성을 예측

- **Attention 연산 (Decoding Attention)**  
  새로운 입력 토큰 `"They"`에 대한 attention 연산은, 기존 KV cache와의 attention을 계산합니다.

  - 계산 복잡도: KV cache의 길이(\(m\))에 대해 \( O(m) \) (선형 복잡도)
  - 메모리 접근 중심 연산(memory bandwidth-bound 연산)

- **NEO의 GPU-CPU 오프로드 전략**  
  - GPU에 KV cache가 있는 경우: GPU에서 처리
  - CPU에 오프로드된 KV cache는 CPU 메모리에서 처리

- **비대칭 파이프라이닝 (NEO의 독창성)**  
  - GPU가 Prefilling과 Decoding 일부 연산(FFN, Linear)을 병렬 수행
  - CPU가 Attention 연산만 병렬로 수행

이렇게 GPU와 CPU에서 병렬로 계산된 결과가 다시 결합되어 다음 단어의 확률 분포를 계산하고, 가장 확률이 높은 단어를 출력합니다.

---

## 🛠️ 3. 모델 아키텍처 구성 (Transformer 구조)

NEO가 사용하는 Transformer 기반 모델 아키텍처는 다음과 같은 층(layer)들로 구성됩니다.

```
[Input] → [Embedding Layer] → [Transformer Layer (Attention + FFN)] x N → [Linear Layer] → [Output Token Probabilities]
```

각 Transformer 층은 다음과 같은 연산 구조를 가지고 있습니다.

- Multi-Head Attention  
  - Query(Q), Key(K), Value(V) 벡터 계산 및 Attention 연산
- Feed Forward Network (FFN)  
  - 두 개의 fully-connected 층으로 구성되며 중간에 활성화 함수(ReLU 또는 GELU)가 적용

> 모델 예시: LLaMa-3 8B 모델  
- 모델 파라미터: 80억 개  
- 층(layer) 수: 32개  
- 임베딩 차원: 4096 차원  
- 헤드(head)의 수: 32개 (Attention 연산의 병렬성 제공)

---

## 💻 4. 연산 요구량 (Computational Complexity)

Transformer 기반 모델의 연산은 크게 다음 두 가지로 구성됩니다.

| 연산 종류      | 연산 설명                            | 계산 복잡도                                                  |
| -------------- | ------------------------------------ | ------------------------------------------------------------ |
| Attention 연산 | 입력 시퀀스 길이 n, 벡터 차원 d일 때 | \(O(n^2 \cdot d)\) (Prefilling), \(O(n \cdot d)\) (Decoding) |
| FFN 연산       | 입력 길이 n, 벡터 차원 d일 때        | \(O(n \cdot d^2)\)                                           |

- Attention은 짧은 문장에서도 큰 메모리 bandwidth를 요구합니다.
- FFN은 GPU 연산 능력을 많이 필요로 하는 compute-bound 연산입니다.

---

## 💾 5. 메모리 요구량 (Memory Requirements)

메모리는 크게 **모델 가중치, Activations, KV Cache** 로 나눠집니다.

| 메모리 종류 | 설명                    | 메모리 요구량 예시 (LLaMa-3 8B 기준)                   |
| ----------- | ----------------------- | ------------------------------------------------------ |
| 모델 가중치 | 모델 파라미터 저장      | 약 16 GB (FP16)                                        |
| Activations | 추론 시 임시 저장       | 수백 MB ~ GB (Batch에 따라 달라짐)                     |
| KV Cache    | 이전 토큰의 정보를 저장 | 입력 길이와 출력 길이에 비례 (수 GB~수십 GB 이상 가능) |

NEO는 이 중 KV cache 일부를 CPU 메모리로 오프로드하여 GPU 메모리 부담을 줄입니다.

---

## ⚙️ 6. NEO가 연산/메모리 효율을 높이는 방법

NEO의 성능향상 원인은 다음과 같습니다.

- GPU 메모리 부족 → CPU 메모리 활용 (오프로드)
- Attention 연산의 메모리 bandwidth-bound 특성 → CPU에서 효율적 처리
- FFN 연산의 compute-bound 특성 → GPU에서 효율적 처리
- GPU와 CPU의 연산을 비대칭적으로 병렬화 → idle 시간을 최소화해 성능 극대화

이러한 전략 덕분에, 동일 하드웨어 환경에서도 GPU-only 방식 대비 **최대 7.5배**라는 놀라운 성능향상을 보일 수 있게 됩니다.

---

## 🚩 결론 및 나의 의견

NEO는 Transformer 기반 모델의 특징을 잘 분석하여 GPU의 메모리 한계를 효과적으로 해결하고 GPU와 CPU의 자원을 최적으로 활용한 시스템입니다.

이러한 구조적 이해와 효율적인 자원 배치는 앞으로도 다양한 대규모 AI 시스템 개발에 중요한 설계방식으로 활용될 수 있다고 생각합니다.



# Q : 이 논문의 한계를 극복하기 위한 방법으로 어떤 연구흐름이 있는지 정리해서 자세하게 설명해 줘




본 논문(N E O)은 GPU 메모리의 제한으로 인한 성능 저하 문제를 **CPU 오프로드 및 비대칭 파이프라이닝 기법**으로 효과적으로 해결했습니다. 하지만 논문이 밝힌 몇 가지 한계점이 있습니다. 이를 해결하기 위해 최근의 연구흐름에서 어떠한 접근법과 연구 방향들이 있는지 정리하고 제시하겠습니다.

---

## 📌 1. 논문에서 밝힌 한계점 요약

논문에서 직접적으로 제시하거나 간접적으로 언급한 NEO의 한계점은 다음과 같습니다:

1. **GPU-CPU 간 통신 병목(PCIe bandwidth 문제)**  
   - GPU와 CPU 사이 KV 캐시 데이터의 빈번한 전송으로 인해 PCIe 인터페이스가 병목이 될 가능성 존재
   - 대역폭 제한으로 인해 실제 운영 환경에서 성능 저하 우려가 있음

2. **동적 스케줄링의 복잡도 증가 문제**  
   - GPU와 CPU 자원 사용률 실시간 모니터링 및 부하 균형 유지를 위한 복잡한 스케줄링 계산 비용 발생

3. **다중 GPU 환경에서의 미흡한 최적화**  
   - 본 연구에서는 주로 단일 또는 2-GPU 환경 실험 수행
   - 수십에서 수백 GPU가 사용되는 대규모 환경에서는 성능 검증 부족

---

## 📍 2. 한계 극복을 위한 최근 연구 흐름 및 접근 방법

### 🚩 (1) GPU-CPU 간 병목 해결을 위한 접근 방법들

#### ✅ **① 차세대 고속 인터페이스 기술 활용**

- **PCIe 5.0, 6.0, CXL(Compute Express Link)**  
  - 최근 PCIe 4.0 (64GB/s)에서 PCIe 5.0 (128GB/s), 6.0 (256GB/s)로 빠르게 진화 중  
  - 특히 **CXL 기술**은 GPU-CPU 간 공유 메모리를 효율적으로 지원, 성능 극대화 가능성 있음

> **관련 최신 연구 흐름**
> - `DistServe`(2024), `FastServe`(2023): 데이터 흐름 최적화와 인터페이스 기술을 접목해 GPU-CPU 전송 효율 향상  
> - `InstInfer`(2024): 저장장치(SSD)에 일부 연산을 offloading하여 PCIe 병목 회피 시도

#### ✅ **② 압축 및 경량화 기술 (KV cache 압축, 압축 연산)**

- **KV cache 압축(KV-cache compression)** 및 **양자화(Quantization)**  
  - KV cache 압축 기술로 데이터 크기를 줄여 GPU-CPU 간 데이터 전송량 감소
  - 낮은 비트 정밀도(8-bit, 4-bit) 연산을 활용한 KV cache 연산 효율화 연구 진행 중

> **관련 최신 연구 흐름**
> - `Atom`(2024), `GPTQ`(2023): 8-bit 이하 양자화 및 sparse 압축을 활용한 KV-cache 압축
> - `AWQ`(2024): Activation-aware quantization으로 데이터 전송량 절감 및 bandwidth 요구량 감소

---

### 🚩 (2) 동적 스케줄링 복잡도 해결을 위한 연구 방향

#### ✅ **① 강화학습 기반 최적화된 동적 스케줄링**

- 복잡한 환경을 동적 최적화하는 문제에 강화학습(RL)을 활용  
- GPU 및 CPU 사용률을 예측하고, 상황에 맞는 스케줄링 정책을 학습하여 실시간 오버헤드를 최소화

> **관련 최신 연구 흐름**
> - `ORCA`(2022), `Sarathi-Serve`(2024): RL 기반 또는 휴리스틱 방법을 이용하여 스케줄링 최적화 시도
> - RL-based Scheduling (최근 Google Research 등에서 활발히 연구 중)

#### ✅ **② 휴리스틱 & 메타러닝을 통한 스케줄링 간소화**

- 복잡한 스케줄링 연산을 단순화된 휴리스틱(Heuristic) 및 메타러닝(Meta-learning) 기반의 간단한 모델로 구현하여 실시간 스케줄링 오버헤드 최소화

> **관련 최신 연구 흐름**
> - `FlexGen`(2023), `HeteGen`(2024): 휴리스틱 방식의 효율적인 스케줄링 연구
> - Lightweight meta-schedulers (스케줄링 오버헤드를 최소화하는 방법으로 최근 활발히 연구됨)

---

### 🚩 (3) 다중 GPU 환경 최적화 연구 흐름

#### ✅ **① 텐서 병렬화(Tensor Parallelism) 및 모델 샤딩(Sharding)**

- 모델 및 데이터를 GPU간 나누어 배치하여 GPU 메모리 효율화 및 연산 병렬화  
- 병렬 GPU 환경에서 효율적인 데이터 분배 및 계산 로드 밸런싱이 중요 연구 주제

> **관련 최신 연구 흐름**
> - `Megatron-LM` (NVIDIA, 2022~), `Alpa` (2023): 대규모 텐서 병렬화 및 효율적인 GPU 분산처리 연구
> - `DistServe`(2024), `DeepSpeed`(Microsoft, 2023): 데이터 및 모델 병렬화를 통한 효율적 메모리 및 연산 처리

#### ✅ **② 하이브리드 병렬화 기법 (Hybrid Parallelism)**

- 텐서 병렬화 + 데이터 병렬화 + 파이프라인 병렬화를 결합한 하이브리드 병렬화 기법
- 대규모 환경에서 연산, 데이터, 메모리를 최적화하여 GPU 자원 사용 극대화

> **관련 최신 연구 흐름**
> - `Colossal-AI`(2024), `DeepSpeed-ZeRO`(2023~2024): 하이브리드 병렬화를 통해 수백 GPU 환경 최적화 시도
> - LLaMA, GPT 시리즈 모델들을 수백대 GPU에서 처리하는 실험을 활발히 진행 중

---

## 📗 결론 및 연구 방향 정리 (한계 극복 방법 요약)

| 한계점               | 해결 접근법                         | 최신 연구 사례                                         |
| -------------------- | ----------------------------------- | ------------------------------------------------------ |
| GPU-CPU 전송 병목    | 차세대 인터페이스, 압축 및 경량화   | CXL, Atom(2024), AWQ(2024), InstInfer(2024)            |
| 동적 스케줄링 복잡성 | 강화학습, 메타러닝, 휴리스틱 기법   | ORCA(2022), FlexGen(2023), Sarathi-Serve(2024)         |
| 다중 GPU 환경 최적화 | 텐서 병렬화, 하이브리드 병렬화 기법 | Megatron-LM(2022~), DistServe(2024), Colossal-AI(2024) |

---

## 📝 나의 의견 및 전망

향후 NEO와 같은 CPU 오프로드 방식은 더 효율적인 하드웨어(CXL 등)와 병렬화 기술 발전에 힘입어 성능이 크게 개선될 가능성이 높습니다.  
특히 GPU와 CPU 자원을 동적으로 관리하는 강화학습 기반의 효율적 스케줄링 연구가 급속히 발전할 것으로 예상되며, 이는 대규모 LLM 추론 시스템의 성능을 극대화하는 핵심이 될 것입니다.

따라서 향후 연구는 이러한 최신 기술 및 방법들을 통합적으로 활용하여, NEO의 실용성과 효율성을 더욱 확장하는 방향으로 발전할 것입니다.

추가적인 질문 있으시면 언제든지 편하게 물어보세요! 😊

# Q : NEO 시스템이 GPU-only 시스템(vLLM)과 기존 CPU 오프로드 시스템(FastDecode)에 비해 성능이 더 뛰어난 근본적인 이유는 무엇이며, 이 차이를 만드는 핵심 메커니즘은 구체적으로 어떻게 동작하는가?

 

NEO 시스템이 GPU-only 시스템(vLLM) 및 기존 CPU 오프로드 시스템(FastDecode)에 비해 성능이 뛰어난 근본적인 이유는 GPU와 CPU의 자원을 동시에 균형 있게 최적화하여 활용하는 "비대칭 파이프라이닝(Asymmetric Pipelining)"과 실시간으로 자원 배분을 결정하는 "부하 인식 스케줄링(Load-Aware Scheduling)"에 있습니다.

구체적으로 살펴보면 다음과 같습니다.

첫째, 기존 GPU-only 시스템(vLLM)은 GPU 메모리의 제약으로 인해 큰 batch 크기를 확보하지 못하여 GPU 연산 능력을 충분히 활용하지 못합니다. 반면, NEO는 일부 attention 연산과 KV cache를 CPU 메모리로 오프로드하여 GPU 메모리 여유를 확보하고 batch 크기를 키울 수 있어 GPU의 계산 성능을 극대화합니다.

둘째, 기존 CPU 오프로드 시스템(FastDecode)은 모든 decoding attention 연산을 무조건 CPU로 넘기기 때문에 CPU가 병목 지점이 되어 전체 성능이 저하됩니다. NEO는 이와 달리 attention 연산의 일부만 선택적으로 CPU에 오프로드하여 CPU 과부하를 피하고, GPU와 CPU를 동시에 효율적으로 가동할 수 있도록 병렬화합니다.

핵심적으로 NEO의 "비대칭 파이프라이닝"은 GPU와 CPU가 각각 가장 잘 처리할 수 있는 작업을 나누어 동시에 병렬로 수행하게 하는 방식입니다. GPU는 주로 prefilling 단계나 계산 중심(linear, FFN 등)의 작업을 담당하고, CPU는 메모리 접근 중심의 attention 작업을 담당합니다. 두 작업이 중첩되어 수행되므로 GPU와 CPU는 거의 쉬는 시간 없이 계속 연산할 수 있게 됩니다.

추가적으로 "부하 인식 스케줄링"은 GPU와 CPU의 현재 작업 부하를 실시간으로 파악하고, 이를 기반으로 batch를 형성하여 자원을 가장 효율적으로 사용할 수 있게 합니다. 이를 통해 GPU-only 방식이나 기존 CPU 오프로드 방식 대비 높은 처리량(throughput)과 낮은 지연(latency)을 동시에 달성할 수 있게 됩니다.

결과적으로, NEO가 제안한 이러한 두 가지 메커니즘의 조합이 GPU-only 시스템 및 기존 CPU 오프로드 시스템의 단점을 극복하고 현저히 뛰어난 성능을 달성한 근본적 이유입니다.

# Q : NEO에서 사용한 비대칭 파이프라이닝과 부하 인식 스케줄링이 실시간으로 어떻게 동작하며, 이 과정에서 발생할 수 있는 병목 현상이나 오버헤드를 최소화하기 위해 논문에서 제시한 구체적인 전략은 무엇인가?

 

NEO에서 사용한 **비대칭 파이프라이닝(Asymmetric Pipelining)**과 **부하 인식 스케줄링(Load-Aware Scheduling)**은 실시간으로 다음과 같이 동작합니다. 

먼저 비대칭 파이프라이닝은 추론 요청이 들어왔을 때, 이를 두 개의 서로 비대칭적인 하위 배치로 나누어 GPU와 CPU에 동시 처리하도록 합니다. 하나의 배치(batch-0)는 GPU가 강점인 Prefilling 단계와 선형(Linear, FFN 등) 연산을 위주로 수행하고, 다른 배치(batch-1)는 CPU가 강점인 attention 연산을 주로 수행합니다. 이렇게 두 배치가 각자의 작업을 병렬로 수행하며, GPU와 CPU가 동시에 일을 함으로써 연산 자원의 idle 시간을 최소화합니다.

부하 인식 스케줄링은 GPU와 CPU의 작업 상황과 부하(load)를 실시간으로 모니터링하면서 최적의 작업 분배를 결정합니다. 매 iteration마다 다음의 원칙을 적용하여 배치를 형성합니다.

- Greedy 원칙: GPU-only 방식과 GPU-CPU 혼합 방식을 실시간으로 비교하여 가장 성능이 좋은 방식을 선택합니다.
- Balancing 원칙: GPU와 CPU의 연산 시간을 최대한 비슷하게 맞추어 어느 한 쪽이 병목(bottleneck)이 되지 않게 합니다.
- Hiding CPU 원칙: CPU 연산을 GPU 연산의 뒤에 숨겨서, CPU 연산 중 GPU가 idle 상태가 되는 현상을 최소화합니다.
- Maximizing GPU 원칙: 가능한 한 많은 요청을 GPU에서 처리하여 GPU의 연산 능력을 최대한 활용합니다.

이러한 과정을 수행하는 동안 발생할 수 있는 병목이나 오버헤드를 최소화하기 위해 논문이 제시한 구체적인 전략은 다음과 같습니다.

첫째, **부분 오프로드(Partial Offloading)** 전략을 사용하여 CPU의 부하를 과도하게 만들지 않고 적정한 수준만 CPU로 옮기며, GPU 메모리 사용률을 최적의 상태로 유지합니다.

둘째, 배치를 형성할 때 **계층 단위(layer-wise)의 KV cache 오프로드 전략**을 적용하여 GPU-CPU 간의 데이터 전송을 연산과 겹치도록(overlap) 합니다. 이를 통해 데이터 전송으로 인한 idle 시간을 최소화합니다.

셋째, 실시간 모니터링을 통해 결정하는 **동적 스케줄링(dynamic scheduling)**을 구현하여 GPU-CPU 간 균형을 맞추고, 상황 변화(입출력 길이의 변화 등)에 빠르게 대응하여 병목 발생을 방지합니다.

마지막으로, GPU 연산 커널(kernel) 호출 횟수를 최소화하는 구조(예: GPU 커널을 반복 호출하는 대신 한 번의 긴 호출로 처리하는 구조)를 통해 GPU kernel launch로 인한 오버헤드를 줄입니다.

종합적으로 NEO는 비대칭적 GPU-CPU 병렬화와 실시간 동적 스케줄링을 활용하여 연산 및 메모리 오버헤드를 최소화하고 GPU 및 CPU 자원을 최대한 효율적으로 활용하는 구조를 갖추고 있습니다.

# Q : NEO의 성능 향상이 입력 및 출력 길이, GPU/CPU 성능 등 다양한 요소들에 따라 어떻게 달라지는지 실험 결과를 통해 설명하고, 실제 환경에 적용할 때 고려해야 할 중요한 요소와 한계점은 무엇인가?

 

NEO의 성능 향상은 입력과 출력 길이, GPU 및 CPU의 성능이라는 요소들에 따라 다음과 같이 달라진다고 논문은 설명하고 있습니다.

먼저 입력 및 출력 길이에 따른 성능 변화는 다음과 같습니다.

입력 길이가 길거나 출력 길이가 길어질수록 KV 캐시의 크기가 증가하며, GPU-only 시스템은 메모리 부족으로 인해 처리 가능한 배치 크기가 급격히 줄어듭니다. 반면, NEO는 CPU 메모리로 KV 캐시 일부를 오프로드하므로, 특히 입력과 출력 길이가 중간에서 긴 경우(batch 크기가 중요한 상황)에 성능이 크게 개선됩니다.

구체적인 실험 결과로, T4 GPU 환경에서 입력 길이가 100에서 500, 출력 길이가 50에서 200 정도일 때, GPU-only 대비 NEO의 성능은 최대 7.5배까지 상승합니다. 한편, 입력과 출력 길이가 매우 짧은 경우 GPU 메모리 병목 문제가 거의 없어 NEO의 성능 향상폭은 상대적으로 줄어들거나 오히려 오프로드 과정의 오버헤드로 인해 약간 떨어질 수도 있습니다.

GPU 및 CPU 성능의 영향은 다음과 같습니다.

CPU 성능(특히 메모리 bandwidth)이 증가하면 CPU가 더 많은 KV 캐시와 Attention 연산을 처리할 수 있게 되어 GPU 부담을 덜어줍니다. 논문의 실험 결과로 AWS EC2 환경에서 CPU의 메모리 대역폭을 증가시킬 경우 A10G GPU에서 최대 79.3%까지 추가적인 성능 향상이 가능했습니다. 반면, CPU 성능이 낮은 환경에서는 CPU가 쉽게 병목 지점이 되어 성능 향상폭이 줄어듭니다.

GPU 성능의 경우, H100처럼 최신 고성능 GPU를 사용할 경우 성능 향상폭은 다소 작아지지만(약 14%), T4나 A10G처럼 중간~하위 성능 GPU를 사용할 경우 GPU 메모리 한계가 명확해지므로 성능 향상폭이 더 큽니다(26% ~ 7.5배 증가).

이러한 실험적 결과를 바탕으로 실제 환경에 NEO를 적용할 때 고려해야 할 중요한 요소와 한계점은 다음과 같습니다.

중요한 고려 요소는:

1. GPU 메모리 용량과 성능: GPU 메모리 부족 현상이 뚜렷한 환경일수록 NEO의 성능 이득이 커집니다.
2. CPU 메모리 bandwidth: CPU 메모리 대역폭이 충분히 확보된 환경이어야 CPU 오프로드 효과가 커지고, 병목이 발생하지 않습니다.
3. 입력과 출력 길이의 분포: 요청되는 추론 작업의 입력과 출력 길이가 길수록 NEO의 효과가 크며, 반대로 매우 짧은 요청이 많으면 GPU-only 방식이 더 효율적일 수 있습니다.
4. GPU-CPU 간 인터페이스(PCIe 또는 CXL)의 성능: 인터페이스 성능이 충분히 높아야 오프로드 과정에서 병목이 발생하지 않습니다.

한계점은:

1. PCIe 인터페이스 병목: 빈번한 GPU-CPU 간 데이터 전송으로 인해 PCIe bandwidth가 병목이 될 가능성이 있습니다.
2. 스케줄링 복잡성 증가: 부하 인식 스케줄링의 실시간 연산이 복잡하여, 관리 비용과 오버헤드가 증가할 수 있습니다.
3. 짧은 요청이 주를 이루는 환경에서는 오프로드 과정 자체가 오버헤드가 될 수 있어 오히려 성능을 떨어뜨릴 수 있습니다.
4. 다중 GPU 환경 최적화 미흡: 현재 논문에서 검증된 것은 단일 GPU나 소수 GPU 환경으로, 많은 수의 GPU를 사용하는 환경에서의 성능 검증은 아직 미흡합니다.

따라서 실제 환경에서는 위와 같은 요소들을 사전에 철저히 평가하고, GPU-CPU 환경 설정, 하드웨어 스펙 선정, 요청 길이 특성을 고려하여 NEO의 최적 적용 여부를 판단해야 합니다.