---
categories:
- paper-review
- with-gpt
date: "2025-06-30"
tags:
- 2401.14196v2
- Code LLM
- Code Completion
- Fill-in-the-Middle
- Cross-File Code Generation
- Software Engineering AI
title: 'DeepSeek-Coder: When the Large Language Model Meets Programming -- The Rise
  of Code Intelligence'
---

[논문 링크](https://arxiv.org/abs/2401.14196v2)


# DeepSeek-Coder: GPT-3.5 Turbo를 추월한 최초의 오픈소스 코드 LLM

AI 실무자가 꿈꿔 온 \*\*“상용 수준을 넘어서는 공개 코드 모델”\*\*이 마침내 등장했다. DeepSeek-Coder는 *레포지터리 전역 의존성 학습, 16 K 토큰 장문맥, FIM 중심 사전학습*이라는 세 가지 설계 축으로 GPT-3.5 Turbo를 넘어서는 성능을 달성한다.

---

## 한 줄 요약 (TL;DR)

> **레포지터리-단위 데이터 + 16 K RoPE + FIM 50 % 학습** 만으로, 33 B 오픈모델이 HumanEval 79 %로 GPT-3.5 Turbo를 추월했다.
<!--more-->
---

## 핵심 아이디어

1. **프로젝트 구조를 그대로 먹인 데이터**를 학습시켜 *cross-file* 의존성을 이해한다.
2. **RoPE 주파수를 재설계**해 16 K 토큰까지 문맥을 잃지 않는다.
3. **Fill-in-the-Middle 50 % 사전학습**으로 IDE에서 가장 많이 쓰는 “중간 삽입” 워크플로를 그대로 모사한다.

---

## 배경: 그들이 해결한 문제

* *상용 LLM > 오픈소스 모델* — HumanEval·LeetCode 같은 벤치마크에서 뚜렷한 성능 격차.
* 오픈모델은 대부분 **파일 단위 데이터**만 학습해 다중 파일 완성 능력이 약하다.
* **4 K 컨텍스트 제한** 때문에 레포 전체(수 만 토큰)를 입력하기 어려워 실제 개발에 쓰기 힘들다.
* 기존 FIM 연구는 “얼마나, 어떻게 섞을 것인가?”에 대한 체계적 탐색이 부족했다.

---

## 새로운 접근법: **DeepSeek-Coder**

| 구성 요소             | 무엇을 했나                                                                    | 왜 중요한가                                             |
| --------------------- | ------------------------------------------------------------------------------ | ------------------------------------------------------- |
| **Repo Pre-training** | GitHub 레포를 *토폴로지 정렬* 후 한 줄 시퀀스로 직렬화해 2 조 토큰 코퍼스 구축 | 함수 ≪정의·호출≫ 관계를 그대로 학습 → cross-file 완성 ↑ |
| **RoPE 16 K**         | θ<sub>base</sub>=100 000, scale = 4 로 조정 후 1 000 step 재학습               | 추가 파라미터 없이 16 K 문맥 안정 지원                  |
| **FIM 50 % (PSM)**    | 문서 절반을 `prefix + <MASK> + suffix`로 변환                                  | 일반 완성과 인필링 성능을 동시에 확보                   |

---

## 작동 원리: 구체적인 예시로 살펴보기

> *장난감 레포 mini-calc*
> `utils/math.py → ops.py → main.py`

1. **의존성 파싱**으로 `utils` → `ops` → `main` 순서 직렬화.
2. 16 K RoPE 덕분에 세 파일이 한 번에 어텐션 창 안에 들어온다.
3. IDE에서

   ```python
   def mul(a, b):
       # PLEASE FILL HERE
   ```

   와 같이 비워 둔 함수를 호출하면, 모델은 앞서 본 `add`, `sub`, `sqrt` 정의를 모두 참조해 `return a * b`를 완성한다.
4. 동일한 메커니즘으로 주석·테스트·빌드 스크립트까지 반영해 “프로젝트 감각”을 유지한다.

---

## 성능 검증: 주요 결과

| 벤치마크                 | DeepSeek-Coder    | 경쟁 모델             | 비고                    |
| ------------------------ | ----------------- | --------------------- | ----------------------- |
| **HumanEval Pass\@1**    | **79 %** (33 B)   | GPT-3.5 Turbo 76 %    | 오픈모델 최초 상용 추월 |
| **DS-1000**              | **40.2 %** (33 B) | CodeLlama-34 B 34.3 % | 과학·ML 라이브러리 실무 |
| **CrossCodeEval EM(Py)** | **13.1 %** (7 B)  | CodeLlama-7 B 7.3 %   | cross-file 이해 1.8×    |
| **LeetCode Contest**     | **27.8 %** (33 B) | GPT-3.5 23.3 %        | Easy-Hard 180문제       |

*FIM 한 줄 인필링*에서도 1.3 B 모델이 StarCoder 16 B를 앞서 “크기 대신 데이터·학습 전략”의 위력을 입증했다.

---

## 우리의 관점: 강점, 한계, 그리고 이 연구가 중요한 이유

**강점**

* **데이터 설계의 승리** — 레포 단위 포맷 하나로 여러 약점을 한꺼번에 해결.
* **엔지니어링 효율** — RoPE 수정 + 1 000 step 만으로 16 K 컨텍스트 달성.
* **작지만 강한 모델** — 7 B 모델이 34 B 모델을 능가, 자원 대비 생산성↑.

**한계**

* 16 K 후 구간(> 64 K)은 여전히 미지수.
* Hard LeetCode·고난도 수학 추론에선 GPT-4 Turbo와 큰 간극.
* 추론 메모리(33 B GQA ≈ 40 GB+)는 개인-GPU 환경엔 부담.

**왜 중요한가?**
DeepSeek-Coder는 “**오픈소스도 GPT-3.5를 이길 수 있다**”를 최초로 증명하며, 연구·산업 모두에 **재현 가능·상업 사용 가능**한 고성능 코드 LLM 기준선을 세웠다. 이후 등장할 모델들이 더 이상 ‘상용 대비 성능 격차’를 면죄부로 삼기 어렵게 만든다.

---

## 다음 단계는?: 앞으로의 길

1. **64 K+ 컨텍스트 & 리트리버 통합**
   모노레포(Chromium 등) 전체를 다루려면 검색 기반 RAG·세그먼트 어텐션이 필요하다.
2. **추론 효율화** — MoE, QLoRA, KV 압축으로 메모리·지연 시간을 절반 이하로.
3. **정밀 의존성 파싱 확장** — 동적 로딩·빌드 스크립트까지 잡아낼 AST-기반 파서 도입.
4. **보안·라이선스 가드** — 취약 코드·시크릿 키를 차단하는 토큰-레벨 필터 내재화.
5. **고난도 논리·알고리즘 강화** — 자동 CoT·self-refine·증명 데이터로 Hard LeetCode 격차 해소.

*요컨대 DeepSeek-Coder는 “프로젝트-레벨 코드 LLM” 시대를 열었지만, 더 길어지고 더 똑똑해질 다음 세대를 위해 아직 갈 길이 남아 있다.*



---

### 토글을 클릭하면 논문에 대한 자세한 LLM 질의응답 내용을 확인할 수 있습니다.

<details markdown="block">
<summary>▶️<strong>클릭하여 펼치기</strong></summary>


## 프롬프트 1.1.1 (연구의 공백)

```
"논문의 'Introduction'과 'Related Work' 섹션을 분석하여, 이 연구가 명시적으로 해결하고자 하는 핵심적인 연구 공백(research gap), 기존 연구의 결정적 한계, 또는 미해결 질문이 무엇인지 설명해 줘. 저자들이 설명하는, 이 논문 출판 시점의 '최신 기술(state of the art)'은 어떤 상태였는지 요약해 줘."
```

## 연구의 공백 (Research Gap)

| 핵심 이슈                               | DeepSeek-Coder가 노리는 틈새                                                                                                                                   |
| --------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **① 오픈소스 ↔ 클로즈드소스 성능 격차** | GPT-3.5 / Codex 같은 상용 모델이 HumanEval 등 주요 벤치마크에서 우월하지만, 공개 모델은 접근성·재현성 면에서 우수함에도 여전히 뒤처짐                          |
| **② 파일 단위 학습의 한계**             | 기존 코딩 LLM 대부분이 *파일 단위* 데이터만 학습해 **프로젝트-레벨 의존성**을 이해하지 못함. 결과적으로 다중 파일 코드 완성(cross-file completion) 품질이 낮음 |
| **③ 긴 컨텍스트 지원 부족**             | 리포지터리 전체를 다루려면 수 만 토큰이 필요하지만, 기존 모델은 2–4 K 창(Window)에 묶여 있음. 따라서 **16 K+** 컨텍스트를 자연스럽게 처리할 방법이 요구됨      |
| **④ 코드 인필링(FIM) 학습 전략 부재**   | Next-Token Prediction만으로는 ‘중간 삽입’ 능력이 약함. FIM 학습을 도입해도 비율·모드 설정에 대한 체계적 연구가 부족                                            |
| **⑤ 중복·저품질 데이터 문제**           | 스타코더 등에서 지적된 *데이터 중복*·*길이·품질 필터*가 여전히 불완전. 프로젝트 구조를 깨지지 않게 **레포지터리 단위**로 near-dedup 수행할 필요                |

이 논문은 위 다섯 지점을 **한꺼번에 해결**하기 위해 —

* **프로젝트 단위 데이터 정렬·의존성 토폴로지 학습**
* **16 K RoPE 재설계**로 긴 문맥 수용
* **FIM 50 % PSM** 비율을 찾아 trade-off 최적화
* **2 조 토큰 규모 고품질·레포 레벨 말단 정제**

— 를 제안한다.

---

## 기존 연구의 결정적 한계

* **StarCoder 16 B / SantaCoder 1.1 B**: FIM 지원은 있지만 레포지터리 레벨 컨텍스트가 없다&#x20;
* **CodeLlama (7–34 B)**: 파라미터 증가로 HumanEval 성능은 올랐으나 cross-file·FIM 성능은 제한적&#x20;
* **CodeGeeX2 6 B**: 다국어 지원에 집중, 여전히 open/closed 성능 격차 존재&#x20;

이처럼 \*\*“높은 재현성 + SOTA 성능 + 레포지터리 이해 + 긴 컨텍스트”\*\*를 동시에 갖춘 공개 모델은 부재했다.

---

## 논문 발표 시점의 최신 기술 (State-of-the-Art)

| 모델                              | 파라미터 | HumanEval Pass\@1                         | 특이점                                                |
| --------------------------------- | -------- | ----------------------------------------- | ----------------------------------------------------- |
| GPT-4 (closed)                    | n/a      | **84 %**                                  | 상용 최고 성능 기준                                   |
| GPT-3.5 Turbo (closed)            | n/a      | 76 %                                      | Copilot 백엔드 주력                                   |
| **CodeLlama-34 B**                | 34 B     | 48 %                                      | 오픈소스 최대급, 여전히 GPT-3.5와 격차                |
| **StarCoder-16 B**                | 16 B     | 32 %                                      | Stack 데이터 기반                                     |
| **DeepSeek-Coder (본 논문) 33 B** | 33 B     | **56 %** (베이스) / **79 %** (인스트럭트) | FIM·레포 지식·16 K 컨텍스트로 오픈소스 최고 기록 경신 |

즉, DeepSeek-Coder-Instruct 33 B는 **GPT-3.5 Turbo를 능가**하면서도 **완전 오픈 라이선스**를 제공해 “연구·상업 모두 자유”라는 새로운 지평을 열었다.

---

### 한 줄 정리

> **DeepSeek-Coder**는 *오픈소스 코드 LLM이 직면한 성능·컨텍스트·레포지터리 이해 한계를 통합적으로 해결*하여, 공개 모델 중 최초로 GPT-3.5 수준을 돌파한 모델 시리즈다.


## 프롬프트 1.1.2 (핵심 가설)

```
"이 논문의 중심 가설(central hypothesis) 또는 핵심 주장은 무엇인가? '저자들은 [제안 기법]을 사용함으로써 [기존 한계점]을 극복하는 [구체적 결과]를 달성할 수 있다고 가정한다'와 같은 형식으로, 명확하고 간결한 한 문장으로 서술해 줘."
```

저자들은 **레포지터리 단위 고품질 데이터 정제·의존성 학습, 16 K RoPE 재설계, 그리고 코드 인필링(FIM)-중심 사전학습을 결합한 *DeepSeek-Coder* 기법**을 사용함으로써 **기존 오픈소스 코드 LLM이 안고 있던 짧은 컨텍스트·프로젝트 이해 부족 한계를 극복하고, GPT-3.5 Turbo를 능가하는 HumanEval 79 % 및 cross-file 완성 성능**을 달성할 수 있다고 가정한다.


## 프롬프트 1.2.1 (독창성 식별)

```
 "논문 전체를 바탕으로, 가장 중요하고 독창적인 기여(contribution) 1~3가지를 구별되는 항목으로 나열해 줘. 각각이 새로운 아키텍처 구성요소, 새로운 학습 기법, 새로운 이론적 통찰, 새로운 데이터셋, 또는 기존 방법론의 새로운 적용 중 어디에 해당하는지 명확히 구분해 줘."
```

### 논문의 주요 독창적 기여 1-3가지

| #     | 기여 내용                                                                                                                                                                                                                                                                                                                        | 범주                                            |
| ----- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------- |
| **1** | **레포지터리-단위 의존성 파싱·Near-Dedup 기반의 2 조 토큰 고품질 코드 코퍼스 구축**<br>GitHub 전체를 대상으로 *의존성 그래프 추출 → 토폴로지 정렬 → 레포 수준 near-dedup*을 수행해 프로젝트 구조를 보존한 채 데이터를 정제 · 확장함. 이 덕분에 모델이 파일 간 참조를 자연스럽게 학습하고 cross-file 완성 성능이 크게 향상되었다. | **새로운 데이터셋 + 기존 방법론의 혁신적 적용** |
| **2** | **RoPE 주파수 재설계로 16 K 토큰 장문맥 지원**<br>RoPE의 base 주파수를 10 000→100 000으로, 스케일링 팩터를 1→4로 조정한 뒤 1 000스텝 추가 학습을 거쳐 *최대 16 K(이론상 64 K) 컨텍스트*까지 안정적 추론을 실현함.                                                                                                                | **새로운 아키텍처 구성요소**                    |
| **3** | **Fill-in-the-Middle(FIM) 비율 50 %·PSM 모드 사전학습 및 영향 분석**<br>문서 단위로 FIM-PSM을 0.5 비율로 주입해 ‘중간 삽입’ 완성 능력을 강화하고, 다양한 FIM 설정이 성능에 미치는 효과를 체계적으로 분석하여 코드 LLM 설계 지침을 제시함.                                                                                        | **새로운 학습 기법 + 이론적 통찰**              |


## 프롬프트 1.2.2 (저자 관점에서의 강점)

```
"저자들의 관점에서, 자신들의 접근법이 이전 방법들보다 우월한 이유는 무엇인가? 그들이 자신들의 연구가 지닌 독창성과 강점을 뒷받침하기 위해 사용하는 핵심 논거를 인용하거나 알기 쉽게 설명해 줘."
```

### 저자들이 주장하는 DeepSeek-Coder의 ‘우월성’ 논거 — 4가지 핵심 포인트

1. **레포지터리 단위 데이터 구성으로 *cross-file* 이해도를 획기적으로 끌어올렸다**

   * 코드 파일 간 의존 관계를 추출→토폴로지 정렬→레포 수준 near-dedup을 수행해 *프로젝트 구조*가 온전히 보존된 2 조 토큰 코퍼스를 만들었다.
   * 같은 7 B급 모델끼리 비교해도, 레포 프리트레이닝을 적용한 DeepSeek-Coder-Base 6.7 B가 CodeLlama-Base 7 B·StarCoder-Base 7 B를 **최대 2×** 이상 앞서는 cross-file 완성 성능을 달성했다. 레포 정보를 제거하면 즉시 성능이 하락해(“w/o Repo Pre-training”) 방법론의 효과가 실증된다.

2. **RoPE 재설계( base = 100 000, scale = 4 )로 16 K 토큰 장문맥을 안정 지원**

   * 1 000스텝 추가 학습만으로 최대 64 K까지 확장 가능성을 확보했으며, 16 K 범위에서 가장 신뢰도 높은 결과를 보고했다. 이는 *레포 전체*를 한 번에 입력해도 문맥 단절 없이 코드를 생성·수정할 수 있게 해 준다.&#x20;

3. **FIM 50 % – PSM 학습 전략으로 ‘중간 삽입’과 일반 완성을 모두 잡았다**

   * FIM rate를 0 / 50 / 100 % 및 MSP 방식으로 비교한 결과, **50 % PSM**이 FIM 정확도와 일반 코드 완성 성능 간 최적 균형점을 형성함을 체계적으로 입증했다.
   * 그 결과 1.3 B조차 StarCoder 16 B·CodeLlama 7 B를 앞서는 단일 라인 인필링 정확도를 기록했다.

4. **“더 작거나, 더 강하다” — 실제 벤치마크에서 GPT-3.5 Turbo 및 대형 오픈모델을 능가**

   * 33 B Instruct 모델은 HumanEval 등 다수 코딩 벤치마크에서 **GPT-3.5 Turbo를 추월**해 오픈소스 최초로 상용 모델 수준을 돌파했다.
   * 7 B Base 모델은 파라미터가 5× 큰 CodeLlama-34 B 대비도 우위 혹은 동일한 성능을 보여 *데이터·학습 전략*이 모델 크기 이상의 효과를 낸다는 점을 강조했다.

> 요약하면, **저자들은 “레포지터리 인지 데이터 + 16 K 문맥 + FIM 최적화”라는 세 축을 결합해 *작은 오픈모델로도 GPT-3.5급 성능을 달성*했다**는 점을 강력한 근거로 제시하며, 이를 통해 연구·상업 모두 자유로운 고성능 코드 LLM 생태계의 가능성을 주장한다.


## 프롬프트 1.3.1 (알고리즘 단계별 설명)

```
"핵심 알고리즘, 모델 아키텍처, 또는 주요 방법론을 단계별(step-by-step)로 설명해 줘. 독자는 AI 분야의 대학원생 수준이라고 가정해. 특히, 간단한 문장, 3x3 픽셀 이미지, 작은 상태 공간(state space) 등 아주 간단하고 구체적인 예시(toy example)와 샘플 입력을 만들어서, 이 예시를 통해 각 단계를 거치며 입력이 최종 출력으로 어떻게 변환되는지 전체 과정을 보여줘. 등장하는 모든 핵심 용어와 변수는 그 즉시 정의해 줘."
```

## DeepSeek-Coder 핵심 알고리즘 ― 단계별 Walk-through

> **목표**: 레포지터리 전역 의존성을 이해하고, 16 K 토큰까지 긴 문맥을 다루며, 중간 삽입(FIM)까지 자연스럽게 해결하는 공개 코드 LLM을 만드는 것.
> 이 과정을 *장난감 예시*에 적용해 전체 파이프라인을 따라가 보겠습니다.

---

### 0. 배경 용어 한눈에

| 용어                                    | 정의                                                                                          |
| --------------------------------------- | --------------------------------------------------------------------------------------------- |
| **레포지터리 단위 프리트레이닝**        | 여러 \*.py / *.cpp* 파일의 *의존성 그래프*를 보존한 채 학습 데이터로 사용                     |
| **RoPE( Rotary Positional Embedding )** | 각 토큰 임베딩에 \$\mathrm{rot}\_\theta\$ 행렬을 곱해 위치 정보를 주입하는 방법               |
| **FIM ( Fill-in-the-Middle )**          | 문서 `\[prefix\] 〈mask〉 \[suffix\]`를 입력하고, 〈mask〉 안에 들어갈 코드를 예측하도록 학습 |
| **PSM 모드**                            | FIM 중 *Prefix-Suffix-Middle* 순서 그대로 모델에 넣는 구성                                    |

---

### 1단계 — **레포지터리 전처리 & 토큰화**

<details>
<summary>🧸 Toy Repo (“mini-calc”) 구성</summary>

```
mini-calc/
├── main.py        # run()
├── ops.py         # add(), sub()
└── utils/math.py  # sqrt()
```

</details>

1. **의존성 그래프 추출**

   * `main.py` → `ops.py`, `utils.math` 를 `import` 함.
   * 그래프 정점 `V={main, ops, utils.math}`, 간선 `E={(main→ops), (main→utils.math)}`.

2. **토폴로지 정렬**

   * 정렬 결과: `utils.math → ops → main`.
   * 이 순서를 **연속 토큰 시퀀스**로 직렬화해 모델에 “한 번에” 보여줌.
   * 효과: 함수 호출이 *정의보다 먼저* 등장해도 참조 맥락이 유지됨.&#x20;

3. **Near-Dedup (레포 레벨 중복 제거)**

   * 해시 윈도가 **64 B** 이상 동일하면 중복으로 간주하고 *파일 단위*가 아닌 *레포 단위*로 제거 → 프로젝트 구조 보존.&#x20;

4. **BPE 토큰화 & 길이 필터**

   * 각 레포 직렬화 결과가 *최소 128 토큰, 최대 16 K 토큰* 범위에 들어올 때만 학습에 사용.

---

### 2단계 — **RoPE 재설계로 16 K 컨텍스트 지원**

| 파라미터 | 기존 GPT-3 계열 | DeepSeek-Coder |
| -------- | --------------- | -------------- |
| `θ_base` | 10 000          | **100 000**    |
| scale    | 1               | **4**          |

*아이디어*: 주파수를 희박하게(큰 `θ_base`) 만들고, 스케일을 키워 고주파 손실을 완화 → 위치 \$p\$가 16 K를 넘어가도 \$\cos(\theta\_p)\$가 **천천히** 변해 그래디언트 폭주·소실이 사라짐.
1 000 스텝 추가 학습만으로 수렴(논문 Figure 6).&#x20;

---

### 3단계 — **FIM 50 % PSM 학습**

*예시 문서 조각 (`ops.py`)*

```python
def add(a, b):
    return a + b
```

1. **샘플 분할 (50 % 확률)**

   * `prefix` = `def add(a, b):\n    `
   * `middle` = `return a + b`
   * `suffix` = \`\` (공백)

2. **PSM 시퀀스 구성**

   ```
   [prefix] <MASK:middle> [suffix]
   ```

   입력 길이는 `|prefix| + |suffix| + 1`; 목표는 `<MASK>` 자리에 `middle`을 생성.

3. **로스 계산**

   * Cross-Entropy를 `<MASK>` 토큰 이후 위치에만 적용.
   * 0 / 50 / 100 % 비율 실험 → \*\*50 %\*\*가 FIM 성능(Top-1 infill)과 일반 완성 사이 최적 타협.&#x20;

---

### 4단계 — **사전학습 → 지시어(Instruction) 파인튜닝**

1. **Base 프리트레이닝** (2 조 토큰)
2. **SFT**: “Write a function …” 등 다중 작업 지시어 600 K 쌍 학습.
3. **RLAIF**: 채점기 (greedy $>$ random) 로 RM 점수 최대화.

---

### 5단계 — **추론 흐름 예시**

사용자 프롬프트 *(16 K 토큰 내)*:

```
/// FILE: utils/math.py
def sqrt(x): ...
/// FILE: ops.py
from utils.math import sqrt
def add(a, b): return a + b
def sub(a, b): ...
### TODO: implement mul
def mul(a, b):
    # PLEASE FILL HERE
```

1. **Transformer 입력** → RoPE로 위치 임베딩(최대 16 384) 주입
2. **Self-Attention** : `mul` 정의 위치에서 `def sub/ add/ sqrt` 토큰들을 모두 어텐션 창 내에 포함
3. **출력** (Instruct 모델):

   ```python
   def mul(a, b):
       return a * b
   ```

HumanEval에서 79 % Pass\@1 기록.&#x20;

---

### 6단계 — **요약**

1. **의존성 보존** 레포 데이터 → cross-file 이해 ↑
2. **RoPE × 16 K** → 레포 전체 입력 가능
3. **FIM 50 % PSM** → 실전 코드 편집 흐름과 동일
4. **결과** 작은 파라미터(7 B)도 대형 모델·GPT-3.5 Turbo 능가

> **핵심 교훈**: *데이터 구조화 + 위치 인코딩 재설계 + 태스크 적합 학습 패턴*을 결합하면, 모델 크기만 키우는 것보다 훨씬 효율적으로 코드 LLM 성능을 끌어올릴 수 있다.


## 프롬프트 1.3.2 ('비밀 병기' 식별)

```
"이 논문의 핵심 기여를 가능하게 하는 가장 결정적인 단일 수학 공식, 알고리즘 단계, 또는 아키텍처 구성요소를 식별해 줘. 그것의 기능과, 그것이 이 방법론의 성공에 왜 필수적인지 설명해 줘."
```

### ‘비밀 병기’ — 16 K 토큰을 가능하게 한 **RoPE 주파수 재설계**

> **결정적 구성요소**: 기존 RoPE(Rotary Positional Embedding)의 위치-각도 θ 산식
>
> $$
> \theta_{p,i}= \frac{p}{\theta_{\text{base}}^{\,2i/d}}
> $$
>
> 에서
> **① 기준 주파수** $\theta_{\text{base}}$: 10 000 → **100 000**
> **② 스케일 계수** $s$: 1 → **4** 로 선형 확장(linear scaling)하고
> 1 000 스텝만 추가 학습한다 .

---

#### 어떻게 작동하나?

1. **저주파화** (θ ↑) → 토큰 간 각도 변화가 완만해져, 위치 p가 16 384를 넘어가도 cos·sin 값이 급변하지 않는다.
2. **스케일 보정** (s ↑) → 저주파화로 줄어든 구분력을 다시 끌어올려, 근접 토큰은 여전히 뚜렷이 구별된다.
3. **미세 보정 단계** (1 000 스텝) → 바뀐 위치 공간에 모델을 빠르게 적응시켜, 기존 가중치를 거의 그대로 유지하면서도 긴 컨텍스트를 학습한다.

---

#### 왜 필수적인가?

* **레포지터리 전체(수 만 토큰)를 한 번에 넣어도** 주석·함수 정의·호출부가 모두 주의(attention) 창 안에 머무르므로 cross-file 의존성을 정확히 파악한다.
* 다른 기법(FIM, 레포 데이터)도 **“긴 문맥이 유지될 때”** 최대 효과를 발휘한다. 16 K 창이 확보되지 않으면, 중간 삽입이나 프로젝트-레벨 완성 능력 자체가 급격히 떨어지는 것이 실험으로 확인됐다 .
* 추가 파라미터나 거대 재학습 없이 **“1 줄 공식 × 1 000 스텝”** 만으로 실현되므로, 계산 비용 대비 성능-향상 비율이 압도적이다.

> 요컨대, \*\*RoPE 주파수 재설계는 DeepSeek-Coder의 모든 장점을 묶어 주는 ‘토대’\*\*이자, GPT-3.5 Turbo를 넘어서는 성능을 가능케 한 단일 핵심 장치다.


## 프롬프트 1.4.1 (핵심 결과 분석)

```
"'Experiments' 또는 'Results' 섹션의 표와 그림을 포함한 주요 결과를 분석해 줘. 사용된 핵심 성능 지표(performance metrics)는 무엇인가? 어떤 벤치마크 데이터셋에서 결과가 보고되었는가? 저자들이 자신들의 방법론의 성공 증거로 가장 강조하는 주요 결과를 요약해 줘."
```

### 1. 실험에서 사용된 핵심 **성능 지표**

* **Pass\@1** : 주어진 테스트 케이스를 한 번에 통과한 정답률

  * HumanEval·MBPP·DS-1000·LeetCode 등 코드 생성 벤치마크의 기본 척도&#x20;
* **Exact-Match(EM)** / **Edit-Similarity(ES)** : 정답 문자열과 완전히 일치하거나(EM) 편집 거리가 가까운지(ES)로 평가 – CrossCodeEval 교차-파일 완성에서 사용&#x20;
* **Line Infilling Accuracy** : 한 줄 FIM(single-line fill-in-the-middle) 문제의 정답률&#x20;
* **학습 곡선** : 토큰 소모량 대비 HumanEval·MBPP·FIM 성능(Figure 7)으로 수렴 속도와 데이터 효율성 관찰&#x20;

---

### 2. 평가에 쓰인 **주요 벤치마크**

| 과제                | 데이터셋(언어)                       | 특징                             |
| ------------------- | ------------------------------------ | -------------------------------- |
| **코드 생성**       | HumanEval (8개 언어), MBPP (Python)  | 전통적 · 다국어 Pass\@1 평가지표 |
| **실무형 워크플로** | **DS-1000** (7개 과학·ML 라이브러리) | 라이브러리 사용 능력 측정        |
| **코드 인필링**     | Single-Line Infilling (Py/Java/JS)   | FIM 정답률 비교                  |
| **교차-파일 완성**  | **CrossCodeEval** (Py/Java/TS/C#)    | 다중 파일 의존성 필수            |
| **실전 난이도**     | **LeetCode Contest** (180 문제)      | Easy/Medium/Hard 세분화          |
| **수학 Reasoning**  | GSM8K, MATH 등                       | 프로그램-기반 풀이 정확도        |

---

### 3. 저자들이 **가장 강조한 성과 요약**

1. **GPT-3.5 Turbo 추월**

   * *DeepSeek-Coder-Instruct 33 B*가 HumanEval Pass\@1 \*\*79.3 %\*\*로 GPT-3.5 Turbo(76.2 %)를 능가, 오픈소스 최초로 상용 모델 격파&#x20;

2. **모델 크기 대비 압도적 효율**

   * *Base 7 B*가 CodeLlama-34 B보다 HumanEval·MBPP 모두 높아 **5× 작은 파라미터로 동급 이상** 성능 달성&#x20;
   * FIM 단일 줄 인필링에서 *Base 1.3 B*조차 StarCoder 16 B·CodeLlama 7 B를 앞섬&#x20;

3. **교차-파일 이해 능력**

   * CrossCodeEval(7 B급 비교)에서 DeepSeek-Coder-Base 7 B가 Python EM **13.06→** *without retrieval 16.41 %*, 다른 언어도 모든 기존 모델을 상회하며 **프로젝트 레벨 의존성 학습 효과**를 입증&#x20;

4. **실무 데이터 사이언스 시나리오**

   * DS-1000 전체 평균 Pass\@1 **40.2 %**(33 B)로, CodeLlama-34 B(34.3 %)를 6 pt ↑ ; 7 B 역시 30.5 %로 34 B 대비 근소 열세 → **데이터·학습 전략의 우수성** 강조&#x20;

5. **실전 난이도 LeetCode Contest**

   * Instruct 33 B가 Overall Pass\@1 \*\*27.8 %\*\*로 오픈소스 중 유일하게 GPT-3.5 Turbo(23.3 %)를 초과, CoT 프롬프트로 추가 상승 가능&#x20;

6. **장문맥·학습 곡선**

   * Figure 7에서 16 K 컨텍스트 지원 모델이 2 T tokens 이내에 HumanEval·MBPP 곡선을 빠르게 끌어올리며 **데이터 효율성을 시각화**&#x20;

> **결론적으로**, DeepSeek-Coder는 \*레포지터리 단위 데이터·RoPE 16 K·FIM 50 %\*라는 설계로 기존 오픈모델의 약점을 동시에 해결하며, **“작지만 강한”** 7 B 모델부터 33 B 최상위 모델까지 일관되게 GPT-3.5 수준 또는 그 이상을 시현했다는 점을 실험 결과로 강력히 뒷받침한다.


## 프롬프트 1.4.2 (비판적 비교)

```
"제안된 방법론은 논문에서 언급된 주요 베이스라인 및 SOTA(State-of-the-Art) 모델들과 비교하여 어떤 성능을 보이는가? 저자들의 우월성 주장을 가장 강력하게 뒷받침하는 특정 결과나 비교 지점을 식별해 줘. 반대로, 제안된 방법론이 경쟁 모델을 능가하지 못했거나 개선 효과가 미미했던 결과는 없는지 찾아봐. 만약 있다면, 저자들은 이러한 경우에 대해 어떤 이유를 제시하는가?"
```

## DeepSeek-Coder vs. 주요 베이스라인·SOTA ― 비판적 비교

### 1. 저자들이 강조하는 ‘결정적 우월성’ 근거

| 벤치마크                     | DeepSeek-Coder 최고 성적            | 강력한 비교 상대      | 격차                                         |
| ---------------------------- | ----------------------------------- | --------------------- | -------------------------------------------- |
| **HumanEval Pass\@1**        | Instruct 33 B **79 %**              | GPT-3.5 Turbo 76 %    | **+3 pp**                                    |
| **MBPP Pass\@1**             | Instruct 33 B **70 %**              | GPT-3.5 Turbo 71 %    | -1 pp (사실상 동급)                          |
| **DS-1000(실무 DS)**         | Base 33 B **40.2 %**                | CodeLlama-34 B 34.3 % | **+5.9 pp** 전 라이브러리 평균 우위          |
| **CrossCodeEval EM (Py)**    | Base 7 B **13.06 %** (Retrieval 無) | CodeLlama-7 B 7.32 %  | **≈1.8×** ↑ — 레포 단위 학습 효과            |
| **Single-Line FIM Mean**     | Base 33 B **81.2 %**                | CodeLlama-13 B 75.5 % | **+5.7 pp** — FIM 50 % 학습의 힘             |
| **LeetCode Contest Overall** | Instruct 33 B **27.8 %**            | CodeLlama-34 B 9.4 %  | **≈3×** ↑, 오픈소스 중 유일하게 GPT-3.5 초과 |

> **핵심 메시지**: *작은(7 B) 또는 동급(33 B) 파라미터에서도 기존 오픈소스·GPT-3.5를 넘었다* → 레포지터리 데이터 + 16 K RoPE + FIM 전략이 단순 모델 크기보다 효과적이라는 논거.

---

### 2. 성능 우위가 미미하거나 열세인 지점 & 저자 해석

| 사례                             | DeepSeek-Coder 성과                                              | 경쟁 모델                           | 관찰·해석                                                                                                                                                            |
| -------------------------------- | ---------------------------------------------------------------- | ----------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **MBPP Pass\@1**                 | 33 B 70 %                                                        | GPT-3.5 Turbo 71 %                  | ‘소규모 Python’ 과제에서는 GPT-3.5와 **거의 동률** → *데이터 난이도가 낮아 파라미터·데이터 품질 이점이 덜 드러난다* 고 언급                                          |
| **FIM (파이썬 세부)**            | 33 B 65.4 %                                                      | CodeLlama-13 B 68.3 %               | Python 단일 라인 인필링에서 **1.3 pp 뒤처짐**. 저자 설명 없음 → *Java·JS에서 큰 격차로 이겨 평균 역전*                                                               |
| **LeetCode Hard subset**         | 33 B 9.1 %                                                       | GPT-3.5 Turbo 15.9 %                | **복잡 추론·알고리즘** 문제에서는 여전히 열세. <br>저자들은 *Chain-of-Thought(CoT) 프롬프트를 추가*하면 33 B가 11.4 %까지 올라 “논리 전개 힌트”가 성능 병목임을 시사 |
| **GPT-4 비교 전반**              | 33 B가 **GPT-4와는 현격한 간극** (예: LeetCode 40.6 % vs 27.8 %) | GPT-4 Turbo                         | 저자들은 *긴 논리 추론·세계지식 한계*를 인정하며, **추가 CoT·대형 일반 LLM 기반 v1.5** 로 격차를 좁혔다고 보고                                                       |
| **프로그램-기반 Math Reasoning** | Base 7 B 65.8 %                                                  | 내부 33 B 71.6 % (외부 SOTA 불포함) | 오픈 비교 표가 없어 우월성 명확치 않음. 이후 **v1.5 모델에서 수학·NL 대폭 개선**으로 보완 시도                                                                       |

---

### 3. 종합 코멘트

* **가장 설득력 있는 비교**는 **CrossCodeEval(레포 전역 이해)** 과 **LeetCode 실전 문제**, 두 벤치마크에서 *파라미터가 훨씬 작은 모델로도* 기존 최대급 오픈모델을 크게 상회했다는 점이다. 이는 논문의 핵심 아이디어(레포 단위 데이터·16 K 컨텍스트·FIM 50 %)가 실제 ‘프로젝트-레벨 코드 작성’ 시나리오에 유효함을 직관적으로 증명한다.
* 반면 **고난도 추론·알고리즘 문제**에선 아직 GPT-3.5(특히 Hard subset)·GPT-4에 뒤처진다. 저자들은 이를 “논리 전개 및 문제 분석 능력 부족”으로 진단하고, **CoT 프롬프트**·**일반 LLM 상속(v1.5)** 로 보강 중임을 밝힌다.
* 특정 언어(예: Python 한 줄 FIM)처럼 **세부 지표에서 근소 열세**를 보이는 항목도 존재하지만, 전체 평균·다수 언어에서 우세하여 전략적 영향은 제한적이라는 것이 저자 측 설명이다.

> **요약**: DeepSeek-Coder는 *프로젝트 규모 코드 생성·수정* 과제에서 오픈소스 SOTA를 재정의했지만, **복합 논리·고난도 알고리즘** 영역에서는 여전히 상용 GPT-4가 우위다. 저자들은 CoT 활용·후속 프리트레이닝으로 이 격차를 계속 좁히겠다는 로드맵을 제시한다.


## 프롬프트 1.5.1 (언급된 한계와 잠재적 한계)

```
"저자들이 논문에서 명시적으로 인정한 한계점, 약점, 또는 실패 사례(failure modes)는 무엇인가? 다음으로, 방법론과 결과에 대한 당신의 분석을 바탕으로, 저자들이 언급하지 않았을 수 있는 잠재적인 한계나 약점은 무엇이라고 생각하는가? (예: 강력한 가정에 대한 의존성, 확장성 문제, 높은 연산 비용, 일반화의 한계, 잠재적인 부정적 사회 영향 등)"
```

## 논문이 **직접** 인정한 한계·약점

| 구분                             | 내용                                                                                                                                                                | 근거 |
| -------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---- |
| **장문맥 신뢰도**                | RoPE 재설계로 *이론상* 64 K 토큰까지 확장되지만, \*\*“가장 신뢰할 수 있는 출력은 16 K 범위”\*\*에 머문다고 명시. 장기적으로 더 안정적인 롱컨텍스트 적응법이 필요함. |      |
| **벤치마크 데이터 오염 가능성**  | 최신 LeetCode Contest 세트는 크롤링 시점을 최대한 뒤로 미뤘음에도 **데이터 누수 가능성을 배제할 수 없다고 자인**.                                                   |      |
| **GPT-4와의 성능 격차**          | 33 B 모델이 GPT-3.5는 추월했지만 **GPT-4-Turbo와는 여전히 상당한 차이**가 남아 있음을 스스로 언급.                                                                  |      |
| **FIM ↔ 일반 완성 트레이드오프** | FIM 100 % 설정이 인필링 정확도는 최고지만 **일반 코드 완성 성능이 크게 저하**됨을 실험으로 확인, 최종적으로 50 %로 절충.                                            |      |

---

## **추가로** 예상되는 잠재적 한계 (필자 관점)

| 영역                            | 잠재적 제약·리스크                                                                                                                                                 | 설명 |
| ------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ---- |
| **확장성·비용**                 | 33 B GQA 모델이라도 단일 GPU VRAM > 40 GB 필요. 기업·개인 현장 적용엔 **추론비용·메모리 압박**이 여전.                                                             |      |
| **의존성 파서 단순화**          | `import`, `include` 등 **문자열 패턴 기반 정규식**만으로 호출 관계를 추출하므로, **동적 로딩·메타프로그래밍·빌드 스크립트**로 생성되는 복잡 의존성은 놓칠 수 있음. |      |
| **16 K 한계 이후 시나리오**     | 대형 모노레포(예: Chromium)의 단일 변경 PR은 수십 만 토큰을 넘기기 쉽다. 16 K 초과 시 **컨텍스트 샘플링·리트리버**가 필수이나 논문은 방법을 제시하지 않음.         |      |
| **데이터 품질·편향**            | GitHub 공개레포 중심(87 %) → **대기업 사내 코드·임베디드·레거시 언어** 빈약. 라이선스·보안 취약 코드가 그대로 학습됐을 가능성도 있음.                              |      |
| **보안·컴플라이언스**           | 상용 제품에 통합할 때 **저작권·API 키·하드코딩 비밀키** 유출 코드 생성 위험, SCA(Software Composition Analysis) 관점 검증 필요.                                    |      |
| **고난도 알고리즘 & 논리 추론** | Hard LeetCode에서 GPT-3.5에 뒤지는 구간이 존재 → **Chain-of-Thought 프롬프트나 외부 툴 호출** 없이 순수 모델만으로는 복합 추론이 미흡.                             |      |
| **FIM 비율 고정의 경직성**      | 실사용 IDE 환경에서는 ‘중간 삽입’ 빈도가 파일·언어마다 상이. **고정 50 % PSM**이 다양한 워크플로에 최적일 것이라는 가정이 검증되지 않음.                           |      |

---

### 시사점

*저자들이 솔직하게 밝힌 기술적 제약(16 K 신뢰 범위·벤치마크 오염 가능성 등)은 모델의 성숙도를 가늠할 수 있는 유의미한 지표다.*
그러나 실제 배포 단계에서는 **추론 자원, 조직 내 레거시 코드 호환성, 보안 규제** 등 추가적인 현실적 제약이 얽힌다. 특히 **16 K 이후 컨텍스트 전략**과 **복합 추론 능력 강화**가 차세대 버전에서 해결해야 할 핵심 과제로 보인다.


## 프롬프트 1.5.2 (미래 연구 궤적)

```
"저자들이 제안하는 구체적인 향후 연구 방향은 무엇인가? 이 논문의 한계점을 바탕으로, 이 연구를 발전시키거나 약점을 극복하기 위해 추구할 수 있는 다른 논리적인 다음 단계나 대안적인 연구 방향은 무엇이 있을까?"
```

### 저자들이 명시한 **구체적 향후 연구 과제**

* **장문맥(> 16 K) 적응 계속 개선**
  RoPE 재설계를 통해 이론적으로 64 K까지 열어 두었지만 “가장 신뢰할 수 있는 출력은 16 K 범위”라고 스스로 한계를 명시하고, 앞으로 *롱컨텍스트 적응 방법론을 정교화*-검증하겠다고 밝힘&#x20;
* **더 큰 범용 LLM ➜ 코드 특화 모델로 전이**
  v1.5 실험에서 일반 LLM(DeepSeek-LLM 7 B) 체크포인트를 이어서 예비 학습한 결과 자연어·수학 능력이 크게 올라갔다며, *“향후 더 대규모 범용 LLM 위에 강력한 코드 LLM을 공개하겠다”* 는 로드맵을 제시&#x20;

---

### 논문의 한계와 업계 흐름을 고려한 **추가 연구 / 대안적 발전 방향** (필자 제안)

1. **64 K+ 컨텍스트 실전화 & 리트리버 통합**
   16 K를 넘어서는 모노레포에서는 *문맥 샘플링·검색 기반 RAG*가 필수다. RoPE 확장은 유지하되, *위치 재매핑 + 세그먼트 어텐션* 같은 하이브리드 기법을 탐색할 가치가 있다.
2. **메모리·지연 시간 최적화를 위한 MoE / 압축**
   33 B GQA 모델도 단일 GPU VRAM 40 GB 이상이 필요하다. *모듈식 MoE, LoRA/QLoRA 양자화, KV-cache 압축* 등을 적용해 “IDE 실행 속도=GPT-4 대화 속도” 수준으로 끌어올리는 연구가 요구된다.
3. **정적·동적 의존성 파싱 고도화**
   현재는 정규식 기반 `import/include` 분석에 의존한다. *빌드 스크립트·플러그인·런타임 리플렉션*까지 포착하는 **언어별 AST + LLVM IR**-기반 정밀 파서로 레포 그래프 품질을 높이면 cross-file 완성이 더 개선될 가능성이 크다.
4. **보안·라이선스 안전 장치 내재화**
   공개 GitHub 코드는 취약점·시크릿 키가 섞여 있을 위험이 있다. *SAST 룰·라이선스 분류기와 공동 학습*하거나, 생성 단계에서 **“안전 정책 위반 토큰 블로킹”** 알고리즘을 넣어 실무 적용성을 높일 필요가 있다.
5. **고난도 알고리즘 / 논리 추론 강화**
   LeetCode Hard에서 GPT-3.5에 뒤처진 원인은 체계적 CoT 부재다. *자동-CoT 압축, self-refine 전략, 증명 의존형 데이터*로 “설계→코드→검증” 전 과정을 학습시키는 것이 자연스러운 다음 단계다.
6. **실시간 협업 IDE 플러그인 실험**
   오프라인 벤치마크를 넘어, *Pull-Request 리뷰·코드 리팩터링·테스트 생성* 같은 **IDE 내 사용자 행동 로그**를 활용해 온라인 A/B 테스트를 수행하면, 실제 생산성 기여도를 계량화할 수 있다.
7. **도메인-특화 코드(임베디드·하드웨어 HDL 등) 확장**
   현재 GitHub 편중 데이터셋은 레거시·사내 코드가 적다. *컨소시엄 데이터셋*을 구축해 **안전 Sandbox 훈련** 또는 *연합 학습* 방법으로 편향을 줄이는 연구도 필요하다.

> **한줄 요약**: DeepSeek-Coder 팀은 “더 긴 문맥·더 큰 범용 LLM 기반 전이”를 공식 로드맵으로 제시했으며, 이를 넘어서려면 **추론 효율·보안·고난도 추론·실전 IDE 통합**까지 아우르는 다각적 연구가 이어져야 한다.


## 프롬프트 데이터 및 전처리

```
"어떤 토큰화(tokenization) 전략이 사용되었는가(예: BPE, WordPiece, SentencePiece)? 어휘에 없는 단어(Out-of-vocabulary words)는 어떻게 처리되는가? 텍스트 정제 및 정규화 단계를 설명해 줘."
```

### 1. 토크나이저(Tokenization)

* **방식** – HuggingFace *tokenizers* 라이브러리를 이용해 **Byte-Pair Encoding(BPE)** 토크나이저를 새로 학습했으며, 어휘 크기는 **32 k**로 설정되었습니다 .
* **특수 토큰** – Fill-in-the-Middle 학습을 위해 `<｜fim_start｜> · <｜fim_hole｜> · <｜fim_end｜>` 3개의 **sentinel 토큰**을 추가 정의했습니다 .
* **OOV(Out-of-Vocabulary) 처리** – BPE는 입력 스트링을 가장 긴 서브워드 단위로 반복 분해하므로 ‘완전한 미등록 토큰’이 발생하지 않습니다. 어휘에 없는 문자열은 점차 더 짧은 서브워드(최종적으로 바이트 단위)로 쪼개져 표현됩니다. 따라서 **사실상 OOV가 존재하지 않으며**, 임의의 유니코드 시퀀스도 손실 없이 인코딩됩니다.

---

### 2. 텍스트 정제 & 정규화 파이프라인

| 단계                                 | 핵심 규칙·처리 내용                                                                                                                                                                       | 출처 |
| ------------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---- |
| **① 규칙 기반 필터링**               | *라인 평균 길이 > 100*·*최대 길이 > 1000* 파일 제거, 알파벳 비율 25 % 미만 파일 제거, XML/HTML/JSON/YAML 전용 규칙 등 StarCoder 룰을 확장 적용해 \*\*초기 수집 데이터의 67 %\*\*를 컷오프 |      |
| **② 의존성 파싱 & 토폴로지 직렬화**  | `import`·`include` 등을 정규식으로 추출 → **파일 간 의존성 그래프** 생성 → 위상 정렬 후 파일 앞에 *경로 주석* 삽입 (예: `// FILE: utils/math.py`) — 레포 구조 보존                        |      |
| **③ 레포 수준 Near-Dedup**           | 동일 레포 코드를 하나의 시퀀스로 취급해 **중복 64 B 이상** substrings 제거, 파일 단위가 아닌 **프로젝트 단위**로 구조 손상 없이 중복 억제                                                 |      |
| **④ 품질 스크리닝 & 디컨태미네이션** | 컴파일러 + 품질 모델 + 휴리스틱으로 *구문 오류·가독성 저하* 코드 필터, 그리고 HumanEval·MBPP·GSM8K·MATH 등 테스트셋 **n-gram(≥10) 매칭 제거**로 데이터 누수 방지                          |      |
| **⑤ FIM 샘플링 & 패킹**              | 문서를 `prefix / middle / suffix` 세 구간으로 나눠 50 % 확률로 PSM 순서로 재배열하고 sentinel 토큰으로 연결 → 이후 **16 K 토큰 길이**로 패킹하여 모델 입력 생성                           |      |

---

#### 요약

DeepSeek-Coder는 **32 k BPE 어휘 + FIM 전용 토큰**을 사용해 OOV 리스크를 없애고,
다단계 데이터 정제(규칙 필터 → 레포 의존성 정렬 → 레포-단위 dedup → 품질/디컨태미네이션)를 거쳐 **2 조 토큰** 규모의 고품질·프로젝트 보존 코퍼스를 구축했습니다. 이런 전처리 덕분에 모델이 **cross-file 맥락**과 **중간 삽입** 시나리오를 자연스럽게 학습할 수 있었습니다.


## 프롬프트모델 아키텍처

```
"트랜스포머를 사용했다면, 어텐션 메커니즘의 구성(예: 헤드 수, 레이어 수)을 상세히 설명해 줘. 위치 인코딩(positional encodings)은 어떻게 처리되는가? Seq2Seq 모델이라면, 인코더-디코더 상호작용을 설명해 줘."
```

### 모델 전반 개요

DeepSeek-Coder 시리즈는 **디코더 전용(Decoder-only) 트랜스포머** 구조를 따르며, DeepSeek-LLM 프레임워크를 그대로 활용해 학습되었습니다. 모든 모델에 **RoPE(회전 위치 임베딩)** 를 적용하고, 연산 효율을 위해 **FlashAttention v2** 를 사용합니다. 33 B 버전에는 메모리·속도 최적화를 위한 **Grouped-Query Attention(GQA)**(group size = 8) 이 도입되었습니다.&#x20;

---

#### 층 수와 헤드 수

| 모델  | 레이어 수 | 어텐션 헤드 수 |
| ----- | --------- | -------------- |
| 1.3 B | 24        | 16             |
| 6.7 B | 32        | 32             |
| 33 B  | 62        | 56\*           |

\*33 B는 56 query heads를 8개 그룹으로 묶은 **GQA** 구성입니다.&#x20;

#### 숨김 차원과 FFN 크기

| 모델  | 히든 크기 | FFN(intermediate) 크기 |
| ----- | --------- | ---------------------- |
| 1.3 B | 2 048     | 5 504                  |
| 6.7 B | 4 096     | 11 008                 |
| 33 B  | 7 168     | 19 200                 |

활성 함수는 모두 **SwiGLU** 를 사용합니다.&#x20;

---

### 어텐션 메커니즘 세부

1. **Multi-Head Self-Attention**
   *1.3 B·6.7 B* 모델은 전통적인 MHA 구조로, 각 헤드가 고유한 Q · K · V 파라미터를 가집니다.
2. **Grouped-Query Attention(33 B)**
   56개의 **Q** 헤드를 8개 그룹으로 나누고, 각 그룹이 **공통 K/V** 세트(=7 개)와만 상호작용합니다. 이는 K/V 복제 비용을 줄이면서 Query 폭은 유지해 **메모리 사용량을 약 8× 절감**합니다.&#x20;
3. **FlashAttention v2**
   헤드별 소프트맥스-스케줄을 GPU 워프 단위로 재구성해 O(N²) 메모리 확장 문제를 완화합니다.&#x20;

---

### 위치 인코딩 — RoPE 확장

| 파라미터                     | 기본 LLaMA | DeepSeek-Coder |
| ---------------------------- | ---------- | -------------- |
| base 주파수 θ<sub>base</sub> | 10 000     | **100 000**    |
| 스케일 계수 s                | 1          | **4**          |
| 추가 학습                    | 없음       | 1 000 스텝     |

선형 스케일링으로 θ<sub>base</sub>를 10× 키우고 s를 4로 조정한 뒤 16 K 길이 시퀀스로 1 000스텝만 재학습하여 **안정적인 16 K 토큰 창**(이론상 64 K)을 확보했습니다. 실제로는 16 K 이내에서 가장 신뢰할 수 있는 출력을 보인다고 명시합니다.

RoPE는 각 토큰 임베딩 $\mathbf{x}_p$에 회전 행렬 $R(\theta_{p,i})$를 곱해 절대 좌표 대신 **상대 각도 차이**로 위치 정보를 전달하므로, 긴 컨텍스트에서도 토큰 간 거리 정보를 보존합니다.

---

### 정리

* **스케일별 세분화된 레이어·헤드 설계**로 파라미터 효율을 극대화.
* **GQA + FlashAttention** 으로 33 B 모델도 실용적 추론 속도/메모리 달성.
* **RoPE 주파수 재설계** 덕분에 16 K 토큰까지 레포 전체를 한꺼번에 입력해도 문맥 손실 없이 코드 생성을 수행합니다.

이러한 구조적 선택이 DeepSeek-Coder가 **GPT-3.5 Turbo를 능가**하는 주된 엔지니어링 기반이 됩니다.


## 프롬프트 학습 및 최적화

```
"구체적인 언어 모델링 목표(objective)는 무엇인가(예: Causal LM, Masked LM, Prefix LM)? 모델은 어떤 코퍼스로 사전학습(pre-trained)되었는가? 다운스트림 과제를 위한 파인튜닝(fine-tuning) 전략을 설명해 줘."
```

## 📚 학습 및 최적화 요약

아래 내용은 DeepSeek-Coder 시리즈(1.3 B / 6.7 B / 33 B)의 **사전학습 목표, 데이터 코퍼스, 파인튜닝 절차**를 한눈에 정리한 것이다.

---

### 1. 언어 모델링 목표(objective)

| 단계                       | 사용된 목표                                                                                                                                                                                                 | 핵심 설정                                               |
| -------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------- |
| **사전학습(Pre-training)** | **Causal Language Modeling + Fill-in-the-Middle (FIM)**<br>· 전체 시퀀스에 대해 *next-token prediction* 손실 적용<br>· 50 % 확률로 **PSM(Prefix-Suffix-Middle) FIM** 변환 후 〈mask〉 위치 토큰만 로스 계산 | - FIM rate = 0.5, PSM 모드 <br>- Next-token loss와 병행 |
| **Instruction Tuning**     | **Supervised Fine-Tuning(SFT)** — 고품질 인간 지시어/응답 쌍에 대해 교차 엔트로피                                                                                                                           | - Alpaca 포맷, <\|EOT\|> 토큰으로 턴 구분               |
| **v1.5 추가 프리트레이닝** | 범용 LLM (DeepSeek-LLM-7B) 체크포인트를 이어서 **추가 Causal LM** 학습                                                                                                                                      | - 2 B 토큰, 4 K context, 순수 next-token loss           |

> 요컨대 \*\*“Causal LM + 문서 단위 FIM”\*\*이 핵심이며, FIM-50 % 설정이 인필링 능력과 일반 완성을 동시에 끌어올리는 비밀소스다.

---

### 2. 사전학습 코퍼스 구성

| 항목           | 내용                                                                               |
| -------------- | ---------------------------------------------------------------------------------- |
| **총 토큰 수** | **2 조(trillion)**                                                                 |
| **언어 분포**  | 87 개 프로그래밍 언어 + 코드 관련 자연어                                           |
| **비율**       | 87 % 소스코드, 10 % GitHub Markdown·StackExchange 영어, 3 % 중국어 일반 NL         |
| **수집 시점**  | GitHub 공개 레포 중 **2023 년 2 월 이전** 생성본                                   |
| **전처리**     | 규칙 필터 → 의존성 파싱 → 레포 단위 dedup → 품질·디컨태미네이션 (데이터 누수 방지) |
| **패킹**       | 16 K 토큰 시퀀스로 패킹 후 학습                                                    |

---

### 3. 파인튜닝·최적화 전략

| 단계                             | 세부 설정                                                                                                                                    |
| -------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------- |
| **SFT(DeepSeek-Coder-Instruct)** | · 데이터 = 휴먼 지시어 200 만 문장 규모<br>· 학습률 1 e-5, 100 warm-up 스텝, cosine schedule<br>· **Batch = 4 M tokens**, 총 2 B tokens 소비 |
| **Optimizer**                    | AdamW (β₁ = 0.9, β₂ = 0.95) + 3-stage LR decay                                                                                               |
| **하드웨어 & 병렬화**            | A100/H800 8-GPU 노드, Tensor/ZeRO/PipeDream 병렬                                                                                             |
| **Long-context 적응**            | RoPE 주파수(10 k→100 k)·스케일(×4) 조정 후 **1 000 스텝** 추가 학습으로 16 K 창 확보                                                         |

---

### ✍️ 정리 한 줄

> DeepSeek-Coder는 \*\*“2 조 토큰 레포지터리 코퍼스 + Causal LM ⊕ FIM(50 % PSM) + RoPE 16 K”\*\*를 기본으로, SFT 지시어-튜닝과 선택적 v1.5 확장 프리트레이닝으로 **GPT-3.5 Turbo급 코드 작성·인필링 성능**을 실현한다.




</details>

